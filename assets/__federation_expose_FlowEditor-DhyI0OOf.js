window.drawingApp = window.drawingApp || {};

import { importShared } from './__federation_fn_import-Dzt68AjK.js';
import { r as requireReact, g as getDefaultExportFromCjs, c as commonjsGlobal } from './index-sElO2NqQ.js';

var jsxRuntime = {exports: {}};

var reactJsxRuntime_production = {};

/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactJsxRuntime_production;

function requireReactJsxRuntime_production () {
	if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
	hasRequiredReactJsxRuntime_production = 1;
	var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
	  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
	function jsxProd(type, config, maybeKey) {
	  var key = null;
	  void 0 !== maybeKey && (key = "" + maybeKey);
	  void 0 !== config.key && (key = "" + config.key);
	  if ("key" in config) {
	    maybeKey = {};
	    for (var propName in config)
	      "key" !== propName && (maybeKey[propName] = config[propName]);
	  } else maybeKey = config;
	  config = maybeKey.ref;
	  return {
	    $$typeof: REACT_ELEMENT_TYPE,
	    type: type,
	    key: key,
	    ref: void 0 !== config ? config : null,
	    props: maybeKey
	  };
	}
	reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
	reactJsxRuntime_production.jsx = jsxProd;
	reactJsxRuntime_production.jsxs = jsxProd;
	return reactJsxRuntime_production;
}

var hasRequiredJsxRuntime;

function requireJsxRuntime () {
	if (hasRequiredJsxRuntime) return jsxRuntime.exports;
	hasRequiredJsxRuntime = 1;
	{
	  jsxRuntime.exports = requireReactJsxRuntime_production();
	}
	return jsxRuntime.exports;
}

var jsxRuntimeExports = requireJsxRuntime();

function cc(names) {
  if (typeof names === "string" || typeof names === "number") return "" + names

  let out = "";

  if (Array.isArray(names)) {
    for (let i = 0, tmp; i < names.length; i++) {
      if ((tmp = cc(names[i])) !== "") {
        out += (out && " ") + tmp;
      }
    }
  } else {
    for (let k in names) {
      if (names[k]) out += (out && " ") + k;
    }
  }

  return out
}

var withSelector = {exports: {}};

var withSelector_production = {};

var shim = {exports: {}};

var useSyncExternalStoreShim_production = {};

/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredUseSyncExternalStoreShim_production;

function requireUseSyncExternalStoreShim_production () {
	if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
	hasRequiredUseSyncExternalStoreShim_production = 1;
	var React = requireReact();
	function is(x, y) {
	  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
	}
	var objectIs = "function" === typeof Object.is ? Object.is : is,
	  useState = React.useState,
	  useEffect = React.useEffect,
	  useLayoutEffect = React.useLayoutEffect,
	  useDebugValue = React.useDebugValue;
	function useSyncExternalStore$2(subscribe, getSnapshot) {
	  var value = getSnapshot(),
	    _useState = useState({ inst: { value: value, getSnapshot: getSnapshot } }),
	    inst = _useState[0].inst,
	    forceUpdate = _useState[1];
	  useLayoutEffect(
	    function () {
	      inst.value = value;
	      inst.getSnapshot = getSnapshot;
	      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
	    },
	    [subscribe, value, getSnapshot]
	  );
	  useEffect(
	    function () {
	      checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
	      return subscribe(function () {
	        checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });
	      });
	    },
	    [subscribe]
	  );
	  useDebugValue(value);
	  return value;
	}
	function checkIfSnapshotChanged(inst) {
	  var latestGetSnapshot = inst.getSnapshot;
	  inst = inst.value;
	  try {
	    var nextValue = latestGetSnapshot();
	    return !objectIs(inst, nextValue);
	  } catch (error) {
	    return true;
	  }
	}
	function useSyncExternalStore$1(subscribe, getSnapshot) {
	  return getSnapshot();
	}
	var shim =
	  "undefined" === typeof window ||
	  "undefined" === typeof window.document ||
	  "undefined" === typeof window.document.createElement
	    ? useSyncExternalStore$1
	    : useSyncExternalStore$2;
	useSyncExternalStoreShim_production.useSyncExternalStore =
	  void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
	return useSyncExternalStoreShim_production;
}

var hasRequiredShim;

function requireShim () {
	if (hasRequiredShim) return shim.exports;
	hasRequiredShim = 1;
	{
	  shim.exports = requireUseSyncExternalStoreShim_production();
	}
	return shim.exports;
}

/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredWithSelector_production;

function requireWithSelector_production () {
	if (hasRequiredWithSelector_production) return withSelector_production;
	hasRequiredWithSelector_production = 1;
	var React = requireReact(),
	  shim = requireShim();
	function is(x, y) {
	  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
	}
	var objectIs = "function" === typeof Object.is ? Object.is : is,
	  useSyncExternalStore = shim.useSyncExternalStore,
	  useRef = React.useRef,
	  useEffect = React.useEffect,
	  useMemo = React.useMemo,
	  useDebugValue = React.useDebugValue;
	withSelector_production.useSyncExternalStoreWithSelector = function (
	  subscribe,
	  getSnapshot,
	  getServerSnapshot,
	  selector,
	  isEqual
	) {
	  var instRef = useRef(null);
	  if (null === instRef.current) {
	    var inst = { hasValue: false, value: null };
	    instRef.current = inst;
	  } else inst = instRef.current;
	  instRef = useMemo(
	    function () {
	      function memoizedSelector(nextSnapshot) {
	        if (!hasMemo) {
	          hasMemo = true;
	          memoizedSnapshot = nextSnapshot;
	          nextSnapshot = selector(nextSnapshot);
	          if (void 0 !== isEqual && inst.hasValue) {
	            var currentSelection = inst.value;
	            if (isEqual(currentSelection, nextSnapshot))
	              return (memoizedSelection = currentSelection);
	          }
	          return (memoizedSelection = nextSnapshot);
	        }
	        currentSelection = memoizedSelection;
	        if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
	        var nextSelection = selector(nextSnapshot);
	        if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
	          return (memoizedSnapshot = nextSnapshot), currentSelection;
	        memoizedSnapshot = nextSnapshot;
	        return (memoizedSelection = nextSelection);
	      }
	      var hasMemo = false,
	        memoizedSnapshot,
	        memoizedSelection,
	        maybeGetServerSnapshot =
	          void 0 === getServerSnapshot ? null : getServerSnapshot;
	      return [
	        function () {
	          return memoizedSelector(getSnapshot());
	        },
	        null === maybeGetServerSnapshot
	          ? void 0
	          : function () {
	              return memoizedSelector(maybeGetServerSnapshot());
	            }
	      ];
	    },
	    [getSnapshot, getServerSnapshot, selector, isEqual]
	  );
	  var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
	  useEffect(
	    function () {
	      inst.hasValue = true;
	      inst.value = value;
	    },
	    [value]
	  );
	  useDebugValue(value);
	  return value;
	};
	return withSelector_production;
}

var hasRequiredWithSelector;

function requireWithSelector () {
	if (hasRequiredWithSelector) return withSelector.exports;
	hasRequiredWithSelector = 1;
	{
	  withSelector.exports = requireWithSelector_production();
	}
	return withSelector.exports;
}

var withSelectorExports = requireWithSelector();
const useSyncExternalStoreExports = /*@__PURE__*/getDefaultExportFromCjs(withSelectorExports);

const __vite_import_meta_env__$1 = {};
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState, api);
  return api;
};
const createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

const ReactExports = await importShared('react');

const { useDebugValue } = ReactExports;
const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
const identity$2 = (arg) => arg;
function useStoreWithEqualityFn(api, selector = identity$2, equalityFn) {
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
const createWithEqualityFnImpl = (createState, defaultEqualityFn) => {
  const api = createStore(createState);
  const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);
  Object.assign(useBoundStoreWithEqualityFn, api);
  return useBoundStoreWithEqualityFn;
};
const createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;

function shallow$1(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size) return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size) return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA of keysA) {
    if (!Object.prototype.hasOwnProperty.call(objB, keyA) || !Object.is(objA[keyA], objB[keyA])) {
      return false;
    }
  }
  return true;
}

var noop$1 = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames$1(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get$1(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set$1(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var xhtml = "http://www.w3.org/1999/xhtml";

const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector$h(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector$h(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection$1(subgroups, this._parents);
}

// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function arrayAll(select) {
  return function() {
    return array(select.apply(this, arguments));
  };
}

function selection_selectAll(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection$1(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

function selection_selectChild(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : childMatcher(match)));
}

var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

function selection_selectChildren(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection$1(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant$3(x) {
  return function() {
    return x;
  };
}

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

function selection_data(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant$3(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}

function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection$1(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection$1(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  return Array.from(this);
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
      : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove$1 : typeof value === "function"
            ? styleFunction$1
            : styleConstant$1)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction$1
          : textConstant$1)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector$h(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

var root = [null];

function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection$1([[document.documentElement]], root);
}

function selection_selection() {
  return this;
}

Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
      : new Selection$1([[selector]], root);
}

function sourceEvent(event) {
  let sourceEvent;
  while (sourceEvent = event.sourceEvent) event = sourceEvent;
  return event;
}

function pointer(event, node) {
  event = sourceEvent(event);
  if (node === undefined) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}

// These are typically used in conjunction with noevent to ensure that we can
// preventDefault on the event.
const nonpassive = {passive: false};
const nonpassivecapture = {capture: true, passive: false};

function nopropagation$1(event) {
  event.stopImmediatePropagation();
}

function noevent$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

function dragDisable(view) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent$1, nonpassivecapture);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent$1, nonpassivecapture);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

const constant$2 = x => () => x;

function DragEvent(type, {
  sourceEvent,
  subject,
  target,
  identifier,
  active,
  x, y, dx, dy,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    subject: {value: subject, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    identifier: {value: identifier, enumerable: true, configurable: true},
    active: {value: active, enumerable: true, configurable: true},
    x: {value: x, enumerable: true, configurable: true},
    y: {value: y, enumerable: true, configurable: true},
    dx: {value: dx, enumerable: true, configurable: true},
    dy: {value: dy, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter$1(event) {
  return !event.ctrlKey && !event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(event, d) {
  return d == null ? {x: event.x, y: event.y} : d;
}

function defaultTouchable$1() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function drag() {
  var filter = defaultFilter$1,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable$1,
      gestures = {},
      listeners = dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved, nonpassive)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned(event, d) {
    if (touchending || !filter.call(this, event, d)) return;
    var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
    if (!gesture) return;
    select(event.view)
      .on("mousemove.drag", mousemoved, nonpassivecapture)
      .on("mouseup.drag", mouseupped, nonpassivecapture);
    dragDisable(event.view);
    nopropagation$1(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }

  function mousemoved(event) {
    noevent$1(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }

  function mouseupped(event) {
    select(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent$1(event);
    gestures.mouse("end", event);
  }

  function touchstarted(event, d) {
    if (!filter.call(this, event, d)) return;
    var touches = event.changedTouches,
        c = container.call(this, event, d),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        nopropagation$1(event);
        gesture("start", event, touches[i]);
      }
    }
  }

  function touchmoved(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent$1(event);
        gesture("drag", event, touches[i]);
      }
    }
  }

  function touchended(event) {
    var touches = event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation$1(event);
        gesture("end", event, touches[i]);
      }
    }
  }

  function beforestart(that, container, event, d, identifier, touch) {
    var dispatch = listeners.copy(),
        p = pointer(touch || event, container), dx, dy,
        s;

    if ((s = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag,
        identifier,
        active,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch
      }), d)) == null) return;

    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;

    return function gesture(type, event, touch) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[identifier] = gesture, n = active++; break;
        case "end": delete gestures[identifier], --active; // falls through
        case "drag": p = pointer(touch || event, container), n = active; break;
      }
      dispatch.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event,
          subject: s,
          target: drag,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch
        }),
        d
      );
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant$2(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant$2(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$2(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

const constant$1 = x => () => x;

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
}

const interpolateRgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;

  return rgb$1;
})(1);

function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: interpolateNumber(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

var degrees = 180 / Math.PI;

var identity$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$1 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return identity$1;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$1;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

const interpolateZoom = (function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0 ≅ u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4);

var frame = 0, // is an animation frame pending?
    timeout$1 = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout$1) timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber
      : b instanceof color ? interpolateRgb
      : (c = color(b)) ? (b = c, interpolateRgb)
      : interpolateString)(a, b);
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
}

function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    set(this, id).ease = v;
  };
}

function transition_easeVarying(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}

function transition_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selector$h(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection = selection.prototype.constructor;

function transition_selection() {
  return new Selection(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

function transition_end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function newId() {
  return ++id;
}

var selection_prototype = selection.prototype;

Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

const constant = x => () => x;

function ZoomEvent(type, {
  sourceEvent,
  target,
  transform,
  dispatch
}) {
  Object.defineProperties(this, {
    type: {value: type, enumerable: true, configurable: true},
    sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
    target: {value: target, enumerable: true, configurable: true},
    transform: {value: transform, enumerable: true, configurable: true},
    _: {value: dispatch}
  });
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

Transform.prototype;

function nopropagation(event) {
  event.stopImmediatePropagation();
}

function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

// Ignore right-click, since that should open the context menu.
// except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === 'wheel') && !event.button;
}

function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}

function defaultTransform() {
  return this.__zoom || identity;
}

function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
}

function defaultTouchable() {
  return navigator.maxTouchPoints || ("ontouchstart" in this);
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

function zoom() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = interpolateZoom,
      listeners = dispatch("start", "zoom", "end"),
      touchstarting,
      touchfirst,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0,
      tapDistance = 10;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled, {passive: false})
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform, point, event) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform, point, event);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
          .event(event)
          .start()
          .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
          .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k, p, event) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };

  zoom.scaleTo = function(selection, k, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };

  zoom.translateBy = function(selection, x, y, event) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };

  zoom.translateTo = function(selection, x, y, p, event) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, point, event) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args).event(event),
              e = extent.apply(that, args),
              p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform === "function" ? transform.apply(that, args) : transform,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args, clean) {
    return (!clean && that.__zooming) || new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }

  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };

  function wheeled(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, args).event(event),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = pointer(event);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      interrupt(this);
      g.start();
    }

    noevent(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned(event, ...args) {
    if (touchending || !filter.apply(this, arguments)) return;
    var currentTarget = event.currentTarget,
        g = gesture(this, args, true).event(event),
        v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = pointer(event, currentTarget),
        x0 = event.clientX,
        y0 = event.clientY;

    dragDisable(event.view);
    nopropagation(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();

    function mousemoved(event) {
      noevent(event);
      if (!g.moved) {
        var dx = event.clientX - x0, dy = event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event)
       .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped(event) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event.view, g.moved);
      noevent(event);
      g.event(event).end();
    }
  }

  function dblclicked(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
        p1 = t0.invert(p0),
        k1 = t0.k * (event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

    noevent(event);
    if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
    else select(this).call(zoom.transform, t1, p0, event);
  }

  function touchstarted(event, ...args) {
    if (!filter.apply(this, arguments)) return;
    var touches = event.touches,
        n = touches.length,
        g = gesture(this, args, event.changedTouches.length === n).event(event),
        started, i, t, p;

    nopropagation(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }

    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      interrupt(this);
      g.start();
    }
  }

  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t, p, l;

    noevent(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event),
        touches = event.changedTouches,
        n = touches.length, i, t;

    nopropagation(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
      if (g.taps === 2) {
        t = pointer(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };

  return zoom;
}

const React$A = await importShared('react');
const {createContext,useContext,useMemo: useMemo$2,memo: memo$o,useRef: useRef$m,useState: useState$w,useEffect: useEffect$q,forwardRef: forwardRef$2,useCallback: useCallback$n} = React$A;
const {createPortal} = await importShared('react-dom');

const StoreContext = createContext(null);
const Provider$1 = StoreContext.Provider;
const errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (nodeType) => `Node type "${nodeType}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (id) => `The old edge with id=${id} does not exist.`,
  error009: (type) => `Marker type "${type}" doesn't exist.`,
  error008: (sourceHandle, edge) => `Couldn't create edge for ${!sourceHandle ? "source" : "target"} handle id: "${!sourceHandle ? edge.sourceHandle : edge.targetHandle}", edge id: ${edge.id}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (edgeType) => `Edge type "${edgeType}" not found. Using fallback type "default".`,
  error012: (id) => `Node with id "${id}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`
};
const zustandErrorMessage = errorMessages["error001"]();
function useStore(selector2, equalityFn) {
  const store = useContext(StoreContext);
  if (store === null) {
    throw new Error(zustandErrorMessage);
  }
  return useStoreWithEqualityFn(store, selector2, equalityFn);
}
const useStoreApi = () => {
  const store = useContext(StoreContext);
  if (store === null) {
    throw new Error(zustandErrorMessage);
  }
  return useMemo$2(() => ({
    getState: store.getState,
    setState: store.setState,
    subscribe: store.subscribe,
    destroy: store.destroy
  }), [store]);
};
const selector$g = (s) => s.userSelectionActive ? "none" : "all";
function Panel({ position, children, className, style: style2, ...rest }) {
  const pointerEvents = useStore(selector$g);
  const positionClasses = `${position}`.split("-");
  return React$A.createElement("div", { className: cc(["react-flow__panel", className, ...positionClasses]), style: { ...style2, pointerEvents }, ...rest }, children);
}
function Attribution({ proOptions, position = "bottom-right" }) {
  if (proOptions?.hideAttribution) {
    return null;
  }
  return React$A.createElement(
    Panel,
    { position, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://reactflow.dev/pro" },
    React$A.createElement("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution" }, "React Flow")
  );
}
const EdgeText = ({ x, y, label, labelStyle = {}, labelShowBg = true, labelBgStyle = {}, labelBgPadding = [2, 4], labelBgBorderRadius = 2, children, className, ...rest }) => {
  const edgeRef = useRef$m(null);
  const [edgeTextBbox, setEdgeTextBbox] = useState$w({ x: 0, y: 0, width: 0, height: 0 });
  const edgeTextClasses = cc(["react-flow__edge-textwrapper", className]);
  useEffect$q(() => {
    if (edgeRef.current) {
      const textBbox = edgeRef.current.getBBox();
      setEdgeTextBbox({
        x: textBbox.x,
        y: textBbox.y,
        width: textBbox.width,
        height: textBbox.height
      });
    }
  }, [label]);
  if (typeof label === "undefined" || !label) {
    return null;
  }
  return React$A.createElement(
    "g",
    { transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`, className: edgeTextClasses, visibility: edgeTextBbox.width ? "visible" : "hidden", ...rest },
    labelShowBg && React$A.createElement("rect", { width: edgeTextBbox.width + 2 * labelBgPadding[0], x: -labelBgPadding[0], y: -labelBgPadding[1], height: edgeTextBbox.height + 2 * labelBgPadding[1], className: "react-flow__edge-textbg", style: labelBgStyle, rx: labelBgBorderRadius, ry: labelBgBorderRadius }),
    React$A.createElement("text", { className: "react-flow__edge-text", y: edgeTextBbox.height / 2, dy: "0.3em", ref: edgeRef, style: labelStyle }, label),
    children
  );
};
var EdgeText$1 = memo$o(EdgeText);
const getDimensions = (node) => ({
  width: node.offsetWidth,
  height: node.offsetHeight
});
const clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);
const clampPosition = (position = { x: 0, y: 0 }, extent) => ({
  x: clamp(position.x, extent[0][0], extent[1][0]),
  y: clamp(position.y, extent[0][1], extent[1][1])
});
const calcAutoPanVelocity = (value, min, max) => {
  if (value < min) {
    return clamp(Math.abs(value - min), 1, 50) / 50;
  } else if (value > max) {
    return -clamp(Math.abs(value - max), 1, 50) / 50;
  }
  return 0;
};
const calcAutoPan = (pos, bounds) => {
  const xMovement = calcAutoPanVelocity(pos.x, 35, bounds.width - 35) * 20;
  const yMovement = calcAutoPanVelocity(pos.y, 35, bounds.height - 35) * 20;
  return [xMovement, yMovement];
};
const getHostForElement = (element) => element.getRootNode?.() || window?.document;
const getBoundsOfBoxes = (box1, box2) => ({
  x: Math.min(box1.x, box2.x),
  y: Math.min(box1.y, box2.y),
  x2: Math.max(box1.x2, box2.x2),
  y2: Math.max(box1.y2, box2.y2)
});
const rectToBox = ({ x, y, width, height }) => ({
  x,
  y,
  x2: x + width,
  y2: y + height
});
const boxToRect = ({ x, y, x2, y2 }) => ({
  x,
  y,
  width: x2 - x,
  height: y2 - y
});
const nodeToRect = (node) => ({
  ...node.positionAbsolute || { x: 0, y: 0 },
  width: node.width || 0,
  height: node.height || 0
});
const getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
const getOverlappingArea = (rectA, rectB) => {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
};
const isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
const isNumeric = (n) => !isNaN(n) && isFinite(n);
const internalsSymbol = Symbol.for("internals");
const elementSelectionKeys = ["Enter", " ", "Escape"];
const devWarn = (id, message) => {
};
const isReactKeyboardEvent = (event) => "nativeEvent" in event;
function isInputDOMNode(event) {
  const kbEvent = isReactKeyboardEvent(event) ? event.nativeEvent : event;
  const target = kbEvent.composedPath?.()?.[0] || event.target;
  const isInput = ["INPUT", "SELECT", "TEXTAREA"].includes(target?.nodeName) || target?.hasAttribute("contenteditable");
  return isInput || !!target?.closest(".nokey");
}
const isMouseEvent = (event) => "clientX" in event;
const getEventPosition = (event, bounds) => {
  const isMouseTriggered = isMouseEvent(event);
  const evtX = isMouseTriggered ? event.clientX : event.touches?.[0].clientX;
  const evtY = isMouseTriggered ? event.clientY : event.touches?.[0].clientY;
  return {
    x: evtX - (bounds?.left ?? 0),
    y: evtY - (bounds?.top ?? 0)
  };
};
const isMacOs = () => typeof navigator !== "undefined" && navigator?.userAgent?.indexOf("Mac") >= 0;
const BaseEdge = ({ id, path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth = 20 }) => {
  return React$A.createElement(
    React$A.Fragment,
    null,
    React$A.createElement("path", { id, style: style2, d: path, fill: "none", className: "react-flow__edge-path", markerEnd, markerStart }),
    interactionWidth && React$A.createElement("path", { d: path, fill: "none", strokeOpacity: 0, strokeWidth: interactionWidth, className: "react-flow__edge-interaction" }),
    label && isNumeric(labelX) && isNumeric(labelY) ? React$A.createElement(EdgeText$1, { x: labelX, y: labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius }) : null
  );
};
BaseEdge.displayName = "BaseEdge";
function getMouseHandler$1(id, getState, handler) {
  return handler === void 0 ? handler : (event) => {
    const edge = getState().edges.find((e) => e.id === id);
    if (edge) {
      handler(event, { ...edge });
    }
  };
}
function getEdgeCenter({ sourceX, sourceY, targetX, targetY }) {
  const xOffset = Math.abs(targetX - sourceX) / 2;
  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  const yOffset = Math.abs(targetY - sourceY) / 2;
  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY }) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
  const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
  const offsetX = Math.abs(centerX - sourceX);
  const offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2["Strict"] = "strict";
  ConnectionMode2["Loose"] = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(PanOnScrollMode2) {
  PanOnScrollMode2["Free"] = "free";
  PanOnScrollMode2["Vertical"] = "vertical";
  PanOnScrollMode2["Horizontal"] = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(SelectionMode2) {
  SelectionMode2["Partial"] = "partial";
  SelectionMode2["Full"] = "full";
})(SelectionMode || (SelectionMode = {}));
var ConnectionLineType;
(function(ConnectionLineType2) {
  ConnectionLineType2["Bezier"] = "default";
  ConnectionLineType2["Straight"] = "straight";
  ConnectionLineType2["Step"] = "step";
  ConnectionLineType2["SmoothStep"] = "smoothstep";
  ConnectionLineType2["SimpleBezier"] = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(MarkerType2) {
  MarkerType2["Arrow"] = "arrow";
  MarkerType2["ArrowClosed"] = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(Position2) {
  Position2["Left"] = "left";
  Position2["Top"] = "top";
  Position2["Right"] = "right";
  Position2["Bottom"] = "bottom";
})(Position || (Position = {}));
function getControl({ pos, x1, y1, x2, y2 }) {
  if (pos === Position.Left || pos === Position.Right) {
    return [0.5 * (x1 + x2), y1];
  }
  return [x1, 0.5 * (y1 + y2)];
}
function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top }) {
  const [sourceControlX, sourceControlY] = getControl({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY
  });
  const [targetControlX, targetControlY] = getControl({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY
  });
  const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
const SimpleBezierEdge = memo$o(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
  const [path, labelX, labelY] = getSimpleBezierPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  });
  return React$A.createElement(BaseEdge, { path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
});
SimpleBezierEdge.displayName = "SimpleBezierEdge";
const handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
};
const getDirection = ({ source, sourcePosition = Position.Bottom, target }) => {
  if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
    return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
  }
  return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
};
const distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
function getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset }) {
  const sourceDir = handleDirections[sourcePosition];
  const targetDir = handleDirections[targetPosition];
  const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };
  const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };
  const dir = getDirection({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  });
  const dirAccessor = dir.x !== 0 ? "x" : "y";
  const currDir = dir[dirAccessor];
  let points = [];
  let centerX, centerY;
  const sourceGapOffset = { x: 0, y: 0 };
  const targetGapOffset = { x: 0, y: 0 };
  const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target.x,
    targetY: target.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    centerX = center.x ?? defaultCenterX;
    centerY = center.y ?? defaultCenterY;
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ];
    const horizontalSplit = [
      { x: sourceGapped.x, y: centerY },
      { x: targetGapped.x, y: centerY }
    ];
    if (sourceDir[dirAccessor] === currDir) {
      points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
    } else {
      points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
    }
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
    const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x") {
      points = sourceDir.x === currDir ? targetSource : sourceTarget;
    } else {
      points = sourceDir.y === currDir ? sourceTarget : targetSource;
    }
    if (sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);
      if (diff <= offset) {
        const gapOffset = Math.min(offset - 1, offset - diff);
        if (sourceDir[dirAccessor] === currDir) {
          sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;
        } else {
          targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;
        }
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x";
      const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
      const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
      if (flipSourceTarget) {
        points = dirAccessor === "x" ? sourceTarget : targetSource;
      }
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };
    const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };
    const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
    const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    if (maxXDistance >= maxYDistance) {
      centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
      centerY = points[0].y;
    } else {
      centerX = points[0].x;
      centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
    }
  }
  const pathPoints = [
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target
  ];
  return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a, b, c, size) {
  const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);
  const { x, y } = b;
  if (a.x === x && x === c.x || a.y === y && y === c.y) {
    return `L${x} ${y}`;
  }
  if (a.y === y) {
    const xDir2 = a.x < c.x ? -1 : 1;
    const yDir2 = a.y < c.y ? 1 : -1;
    return `L ${x + bendSize * xDir2},${y}Q ${x},${y} ${x},${y + bendSize * yDir2}`;
  }
  const xDir = a.x < c.x ? 1 : -1;
  const yDir = a.y < c.y ? -1 : 1;
  return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;
}
function getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20 }) {
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY },
    offset
  });
  const path = points.reduce((res, p, i) => {
    let segment = "";
    if (i > 0 && i < points.length - 1) {
      segment = getBend(points[i - 1], p, points[i + 1], borderRadius);
    } else {
      segment = `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
    }
    res += segment;
    return res;
  }, "");
  return [path, labelX, labelY, offsetX, offsetY];
}
const SmoothStepEdge = memo$o(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, sourcePosition = Position.Bottom, targetPosition = Position.Top, markerEnd, markerStart, pathOptions, interactionWidth }) => {
  const [path, labelX, labelY] = getSmoothStepPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    borderRadius: pathOptions?.borderRadius,
    offset: pathOptions?.offset
  });
  return React$A.createElement(BaseEdge, { path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
});
SmoothStepEdge.displayName = "SmoothStepEdge";
const StepEdge = memo$o((props) => React$A.createElement(SmoothStepEdge, { ...props, pathOptions: useMemo$2(() => ({ borderRadius: 0, offset: props.pathOptions?.offset }), [props.pathOptions?.offset]) }));
StepEdge.displayName = "StepEdge";
function getStraightPath({ sourceX, sourceY, targetX, targetY }) {
  const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];
}
const StraightEdge = memo$o(({ sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth }) => {
  const [path, labelX, labelY] = getStraightPath({ sourceX, sourceY, targetX, targetY });
  return React$A.createElement(BaseEdge, { path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
});
StraightEdge.displayName = "StraightEdge";
function calculateControlOffset(distance2, curvature) {
  if (distance2 >= 0) {
    return 0.5 * distance2;
  }
  return curvature * 25 * Math.sqrt(-distance2);
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  switch (pos) {
    case Position.Left:
      return [x1 - calculateControlOffset(x1 - x2, c), y1];
    case Position.Right:
      return [x1 + calculateControlOffset(x2 - x1, c), y1];
    case Position.Top:
      return [x1, y1 - calculateControlOffset(y1 - y2, c)];
    case Position.Bottom:
      return [x1, y1 + calculateControlOffset(y2 - y1, c)];
  }
}
function getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25 }) {
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  });
  const [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  });
  const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
const BezierEdge = memo$o(({ sourceX, sourceY, targetX, targetY, sourcePosition = Position.Bottom, targetPosition = Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, pathOptions, interactionWidth }) => {
  const [path, labelX, labelY] = getBezierPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
    curvature: pathOptions?.curvature
  });
  return React$A.createElement(BaseEdge, { path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, markerEnd, markerStart, interactionWidth });
});
BezierEdge.displayName = "BezierEdge";
const NodeIdContext = createContext(null);
const Provider = NodeIdContext.Provider;
NodeIdContext.Consumer;
const useNodeId = () => {
  const nodeId = useContext(NodeIdContext);
  return nodeId;
};
const isEdge = (element) => "id" in element && "source" in element && "target" in element;
const isNode = (element) => "id" in element && !("source" in element) && !("target" in element);
const getOutgoers = (node, nodes, edges) => {
  if (!isNode(node)) {
    return [];
  }
  const outgoerIds = edges.filter((e) => e.source === node.id).map((e) => e.target);
  return nodes.filter((n) => outgoerIds.includes(n.id));
};
const getIncomers = (node, nodes, edges) => {
  if (!isNode(node)) {
    return [];
  }
  const incomersIds = edges.filter((e) => e.target === node.id).map((e) => e.source);
  return nodes.filter((n) => incomersIds.includes(n.id));
};
const getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `reactflow__edge-${source}${sourceHandle || ""}-${target}${targetHandle || ""}`;
const getMarkerId = (marker, rfId) => {
  if (typeof marker === "undefined") {
    return "";
  }
  if (typeof marker === "string") {
    return marker;
  }
  const idPrefix = rfId ? `${rfId}__` : "";
  return `${idPrefix}${Object.keys(marker).sort().map((key) => `${key}=${marker[key]}`).join("&")}`;
};
const connectionExists = (edge, edges) => {
  return edges.some((el) => el.source === edge.source && el.target === edge.target && (el.sourceHandle === edge.sourceHandle || !el.sourceHandle && !edge.sourceHandle) && (el.targetHandle === edge.targetHandle || !el.targetHandle && !edge.targetHandle));
};
const addEdge = (edgeParams, edges) => {
  if (!edgeParams.source || !edgeParams.target) {
    return edges;
  }
  let edge;
  if (isEdge(edgeParams)) {
    edge = { ...edgeParams };
  } else {
    edge = {
      ...edgeParams,
      id: getEdgeId(edgeParams)
    };
  }
  if (connectionExists(edge, edges)) {
    return edges;
  }
  return edges.concat(edge);
};
const pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid, [snapX, snapY]) => {
  const position = {
    x: (x - tx) / tScale,
    y: (y - ty) / tScale
  };
  if (snapToGrid) {
    return {
      x: snapX * Math.round(position.x / snapX),
      y: snapY * Math.round(position.y / snapY)
    };
  }
  return position;
};
const rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {
  return {
    x: x * tScale + tx,
    y: y * tScale + ty
  };
};
const getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {
  if (!node) {
    return {
      x: 0,
      y: 0,
      positionAbsolute: {
        x: 0,
        y: 0
      }
    };
  }
  const offsetX = (node.width ?? 0) * nodeOrigin[0];
  const offsetY = (node.height ?? 0) * nodeOrigin[1];
  const position = {
    x: node.position.x - offsetX,
    y: node.position.y - offsetY
  };
  return {
    ...position,
    positionAbsolute: node.positionAbsolute ? {
      x: node.positionAbsolute.x - offsetX,
      y: node.positionAbsolute.y - offsetY
    } : position
  };
};
const getNodesBounds = (nodes, nodeOrigin = [0, 0]) => {
  if (nodes.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  const box = nodes.reduce((currBox, node) => {
    const { x, y } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;
    return getBoundsOfBoxes(currBox, rectToBox({
      x,
      y,
      width: node.width || 0,
      height: node.height || 0
    }));
  }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });
  return boxToRect(box);
};
const getNodesInside = (nodeInternals, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, excludeNonSelectableNodes = false, nodeOrigin = [0, 0]) => {
  const paneRect = {
    x: (rect.x - tx) / tScale,
    y: (rect.y - ty) / tScale,
    width: rect.width / tScale,
    height: rect.height / tScale
  };
  const visibleNodes = [];
  nodeInternals.forEach((node) => {
    const { width, height, selectable = true, hidden = false } = node;
    if (excludeNonSelectableNodes && !selectable || hidden) {
      return false;
    }
    const { positionAbsolute } = getNodePositionWithOrigin(node, nodeOrigin);
    const nodeRect = {
      x: positionAbsolute.x,
      y: positionAbsolute.y,
      width: width || 0,
      height: height || 0
    };
    const overlappingArea = getOverlappingArea(paneRect, nodeRect);
    const notInitialized = typeof width === "undefined" || typeof height === "undefined" || width === null || height === null;
    const partiallyVisible = partially && overlappingArea > 0;
    const area = (width || 0) * (height || 0);
    const isVisible = notInitialized || partiallyVisible || overlappingArea >= area;
    if (isVisible || node.dragging) {
      visibleNodes.push(node);
    }
  });
  return visibleNodes;
};
const getConnectedEdges = (nodes, edges) => {
  const nodeIds = nodes.map((node) => node.id);
  return edges.filter((edge) => nodeIds.includes(edge.source) || nodeIds.includes(edge.target));
};
const getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding = 0.1) => {
  const xZoom = width / (bounds.width * (1 + padding));
  const yZoom = height / (bounds.height * (1 + padding));
  const zoom2 = Math.min(xZoom, yZoom);
  const clampedZoom = clamp(zoom2, minZoom, maxZoom);
  const boundsCenterX = bounds.x + bounds.width / 2;
  const boundsCenterY = bounds.y + bounds.height / 2;
  const x = width / 2 - boundsCenterX * clampedZoom;
  const y = height / 2 - boundsCenterY * clampedZoom;
  return { x, y, zoom: clampedZoom };
};
const getD3Transition = (selection, duration = 0) => {
  return selection.transition().duration(duration);
};
function getHandles(node, handleBounds, type, currentHandle) {
  return (handleBounds[type] || []).reduce((res, h) => {
    if (`${node.id}-${h.id}-${type}` !== currentHandle) {
      res.push({
        id: h.id || null,
        type,
        nodeId: node.id,
        x: (node.positionAbsolute?.x ?? 0) + h.x + h.width / 2,
        y: (node.positionAbsolute?.y ?? 0) + h.y + h.height / 2
      });
    }
    return res;
  }, []);
}
function getClosestHandle(event, doc, pos, connectionRadius, handles, validator) {
  const { x, y } = getEventPosition(event);
  const domNodes = doc.elementsFromPoint(x, y);
  const handleBelow = domNodes.find((el) => el.classList.contains("react-flow__handle"));
  if (handleBelow) {
    const handleNodeId = handleBelow.getAttribute("data-nodeid");
    if (handleNodeId) {
      const handleType = getHandleType(void 0, handleBelow);
      const handleId = handleBelow.getAttribute("data-handleid");
      const validHandleResult = validator({ nodeId: handleNodeId, id: handleId, type: handleType });
      if (validHandleResult) {
        const handle = handles.find((h) => h.nodeId === handleNodeId && h.type === handleType && h.id === handleId);
        return {
          handle: {
            id: handleId,
            type: handleType,
            nodeId: handleNodeId,
            x: handle?.x || pos.x,
            y: handle?.y || pos.y
          },
          validHandleResult
        };
      }
    }
  }
  let closestHandles = [];
  let minDistance = Infinity;
  handles.forEach((handle) => {
    const distance2 = Math.sqrt((handle.x - pos.x) ** 2 + (handle.y - pos.y) ** 2);
    if (distance2 <= connectionRadius) {
      const validHandleResult = validator(handle);
      if (distance2 <= minDistance) {
        if (distance2 < minDistance) {
          closestHandles = [{ handle, validHandleResult }];
        } else if (distance2 === minDistance) {
          closestHandles.push({
            handle,
            validHandleResult
          });
        }
        minDistance = distance2;
      }
    }
  });
  if (!closestHandles.length) {
    return { handle: null, validHandleResult: defaultResult() };
  }
  if (closestHandles.length === 1) {
    return closestHandles[0];
  }
  const hasValidHandle = closestHandles.some(({ validHandleResult }) => validHandleResult.isValid);
  const hasTargetHandle = closestHandles.some(({ handle }) => handle.type === "target");
  return closestHandles.find(({ handle, validHandleResult }) => hasTargetHandle ? handle.type === "target" : hasValidHandle ? validHandleResult.isValid : true) || closestHandles[0];
}
const nullConnection = { source: null, target: null, sourceHandle: null, targetHandle: null };
const defaultResult = () => ({
  handleDomNode: null,
  isValid: false,
  connection: nullConnection,
  endHandle: null
});
function isValidHandle(handle, connectionMode, fromNodeId, fromHandleId, fromType, isValidConnection, doc) {
  const isTarget = fromType === "target";
  const handleToCheck = doc.querySelector(`.react-flow__handle[data-id="${handle?.nodeId}-${handle?.id}-${handle?.type}"]`);
  const result = {
    ...defaultResult(),
    handleDomNode: handleToCheck
  };
  if (handleToCheck) {
    const handleType = getHandleType(void 0, handleToCheck);
    const handleNodeId = handleToCheck.getAttribute("data-nodeid");
    const handleId = handleToCheck.getAttribute("data-handleid");
    const connectable = handleToCheck.classList.contains("connectable");
    const connectableEnd = handleToCheck.classList.contains("connectableend");
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isConnectable = connectable && connectableEnd;
    const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    if (isValid) {
      result.endHandle = {
        nodeId: handleNodeId,
        handleId,
        type: handleType
      };
      result.isValid = isValidConnection(connection);
    }
  }
  return result;
}
function getHandleLookup({ nodes, nodeId, handleId, handleType }) {
  return nodes.reduce((res, node) => {
    if (node[internalsSymbol]) {
      const { handleBounds } = node[internalsSymbol];
      let sourceHandles = [];
      let targetHandles = [];
      if (handleBounds) {
        sourceHandles = getHandles(node, handleBounds, "source", `${nodeId}-${handleId}-${handleType}`);
        targetHandles = getHandles(node, handleBounds, "target", `${nodeId}-${handleId}-${handleType}`);
      }
      res.push(...sourceHandles, ...targetHandles);
    }
    return res;
  }, []);
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  if (edgeUpdaterType) {
    return edgeUpdaterType;
  } else if (handleDomNode?.classList.contains("target")) {
    return "target";
  } else if (handleDomNode?.classList.contains("source")) {
    return "source";
  }
  return null;
}
function resetRecentHandle(handleDomNode) {
  handleDomNode?.classList.remove("valid", "connecting", "react-flow__handle-valid", "react-flow__handle-connecting");
}
function getConnectionStatus(isInsideConnectionRadius, isHandleValid) {
  let connectionStatus = null;
  if (isHandleValid) {
    connectionStatus = "valid";
  } else if (isInsideConnectionRadius && !isHandleValid) {
    connectionStatus = "invalid";
  }
  return connectionStatus;
}
function handlePointerDown({ event, handleId, nodeId, onConnect, isTarget, getState, setState, isValidConnection, edgeUpdaterType, onReconnectEnd }) {
  const doc = getHostForElement(event.target);
  const { connectionMode, domNode, autoPanOnConnect, connectionRadius, onConnectStart, panBy, getNodes, cancelConnection } = getState();
  let autoPanId = 0;
  let closestHandle;
  const { x, y } = getEventPosition(event);
  const clickedHandle = doc?.elementFromPoint(x, y);
  const handleType = getHandleType(edgeUpdaterType, clickedHandle);
  const containerBounds = domNode?.getBoundingClientRect();
  if (!containerBounds || !handleType) {
    return;
  }
  let prevActiveHandle;
  let connectionPosition = getEventPosition(event, containerBounds);
  let autoPanStarted = false;
  let connection = null;
  let isValid = false;
  let handleDomNode = null;
  const handleLookup = getHandleLookup({
    nodes: getNodes(),
    nodeId,
    handleId,
    handleType
  });
  const autoPan = () => {
    if (!autoPanOnConnect) {
      return;
    }
    const [xMovement, yMovement] = calcAutoPan(connectionPosition, containerBounds);
    panBy({ x: xMovement, y: yMovement });
    autoPanId = requestAnimationFrame(autoPan);
  };
  setState({
    connectionPosition,
    connectionStatus: null,
    // connectionNodeId etc will be removed in the next major in favor of connectionStartHandle
    connectionNodeId: nodeId,
    connectionHandleId: handleId,
    connectionHandleType: handleType,
    connectionStartHandle: {
      nodeId,
      handleId,
      type: handleType
    },
    connectionEndHandle: null
  });
  onConnectStart?.(event, { nodeId, handleId, handleType });
  function onPointerMove(event2) {
    const { transform } = getState();
    connectionPosition = getEventPosition(event2, containerBounds);
    const { handle, validHandleResult } = getClosestHandle(event2, doc, pointToRendererPoint(connectionPosition, transform, false, [1, 1]), connectionRadius, handleLookup, (handle2) => isValidHandle(handle2, connectionMode, nodeId, handleId, isTarget ? "target" : "source", isValidConnection, doc));
    closestHandle = handle;
    if (!autoPanStarted) {
      autoPan();
      autoPanStarted = true;
    }
    handleDomNode = validHandleResult.handleDomNode;
    connection = validHandleResult.connection;
    isValid = validHandleResult.isValid;
    setState({
      connectionPosition: closestHandle && isValid ? rendererPointToPoint({
        x: closestHandle.x,
        y: closestHandle.y
      }, transform) : connectionPosition,
      connectionStatus: getConnectionStatus(!!closestHandle, isValid),
      connectionEndHandle: validHandleResult.endHandle
    });
    if (!closestHandle && !isValid && !handleDomNode) {
      return resetRecentHandle(prevActiveHandle);
    }
    if (connection.source !== connection.target && handleDomNode) {
      resetRecentHandle(prevActiveHandle);
      prevActiveHandle = handleDomNode;
      handleDomNode.classList.add("connecting", "react-flow__handle-connecting");
      handleDomNode.classList.toggle("valid", isValid);
      handleDomNode.classList.toggle("react-flow__handle-valid", isValid);
    }
  }
  function onPointerUp(event2) {
    if ((closestHandle || handleDomNode) && connection && isValid) {
      onConnect?.(connection);
    }
    getState().onConnectEnd?.(event2);
    if (edgeUpdaterType) {
      onReconnectEnd?.(event2);
    }
    resetRecentHandle(prevActiveHandle);
    cancelConnection();
    cancelAnimationFrame(autoPanId);
    autoPanStarted = false;
    isValid = false;
    connection = null;
    handleDomNode = null;
    doc.removeEventListener("mousemove", onPointerMove);
    doc.removeEventListener("mouseup", onPointerUp);
    doc.removeEventListener("touchmove", onPointerMove);
    doc.removeEventListener("touchend", onPointerUp);
  }
  doc.addEventListener("mousemove", onPointerMove);
  doc.addEventListener("mouseup", onPointerUp);
  doc.addEventListener("touchmove", onPointerMove);
  doc.addEventListener("touchend", onPointerUp);
}
const alwaysValid = () => true;
const selector$f = (s) => ({
  connectionStartHandle: s.connectionStartHandle,
  connectOnClick: s.connectOnClick,
  noPanClassName: s.noPanClassName
});
const connectingSelector = (nodeId, handleId, type) => (state) => {
  const { connectionStartHandle: startHandle, connectionEndHandle: endHandle, connectionClickStartHandle: clickHandle } = state;
  return {
    connecting: startHandle?.nodeId === nodeId && startHandle?.handleId === handleId && startHandle?.type === type || endHandle?.nodeId === nodeId && endHandle?.handleId === handleId && endHandle?.type === type,
    clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.handleId === handleId && clickHandle?.type === type
  };
};
const Handle = forwardRef$2(({ type = "source", position = Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) => {
  const handleId = id || null;
  const isTarget = type === "target";
  const store = useStoreApi();
  const nodeId = useNodeId();
  const { connectOnClick, noPanClassName } = useStore(selector$f, shallow$1);
  const { connecting, clickConnecting } = useStore(connectingSelector(nodeId, handleId, type), shallow$1);
  if (!nodeId) {
    store.getState().onError?.("010", errorMessages["error010"]());
  }
  const onConnectExtended = (params) => {
    const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();
    const edgeParams = {
      ...defaultEdgeOptions,
      ...params
    };
    if (hasDefaultEdges) {
      const { edges, setEdges } = store.getState();
      setEdges(addEdge(edgeParams, edges));
    }
    onConnectAction?.(edgeParams);
    onConnect?.(edgeParams);
  };
  const onPointerDown = (event) => {
    if (!nodeId) {
      return;
    }
    const isMouseTriggered = isMouseEvent(event);
    if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {
      handlePointerDown({
        event,
        handleId,
        nodeId,
        onConnect: onConnectExtended,
        isTarget,
        getState: store.getState,
        setState: store.setState,
        isValidConnection: isValidConnection || store.getState().isValidConnection || alwaysValid
      });
    }
    if (isMouseTriggered) {
      onMouseDown?.(event);
    } else {
      onTouchStart?.(event);
    }
  };
  const onClick = (event) => {
    const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore } = store.getState();
    if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {
      return;
    }
    if (!connectionClickStartHandle) {
      onClickConnectStart?.(event, { nodeId, handleId, handleType: type });
      store.setState({ connectionClickStartHandle: { nodeId, type, handleId } });
      return;
    }
    const doc = getHostForElement(event.target);
    const isValidConnectionHandler = isValidConnection || isValidConnectionStore || alwaysValid;
    const { connection, isValid } = isValidHandle({
      nodeId,
      id: handleId,
      type
    }, connectionMode, connectionClickStartHandle.nodeId, connectionClickStartHandle.handleId || null, connectionClickStartHandle.type, isValidConnectionHandler, doc);
    if (isValid) {
      onConnectExtended(connection);
    }
    onClickConnectEnd?.(event);
    store.setState({ connectionClickStartHandle: null });
  };
  return React$A.createElement("div", { "data-handleid": handleId, "data-nodeid": nodeId, "data-handlepos": position, "data-id": `${nodeId}-${handleId}-${type}`, className: cc([
    "react-flow__handle",
    `react-flow__handle-${position}`,
    "nodrag",
    noPanClassName,
    className,
    {
      source: !isTarget,
      target: isTarget,
      connectable: isConnectable,
      connectablestart: isConnectableStart,
      connectableend: isConnectableEnd,
      connecting: clickConnecting,
      // this class is used to style the handle when the user is connecting
      connectionindicator: isConnectable && (isConnectableStart && !connecting || isConnectableEnd && connecting)
    }
  ]), onMouseDown: onPointerDown, onTouchStart: onPointerDown, onClick: connectOnClick ? onClick : void 0, ref, ...rest }, children);
});
Handle.displayName = "Handle";
var Handle$1 = memo$o(Handle);
const DefaultNode = ({ data, isConnectable, targetPosition = Position.Top, sourcePosition = Position.Bottom }) => {
  return React$A.createElement(
    React$A.Fragment,
    null,
    React$A.createElement(Handle$1, { type: "target", position: targetPosition, isConnectable }),
    data?.label,
    React$A.createElement(Handle$1, { type: "source", position: sourcePosition, isConnectable })
  );
};
DefaultNode.displayName = "DefaultNode";
var DefaultNode$1 = memo$o(DefaultNode);
const InputNode = ({ data, isConnectable, sourcePosition = Position.Bottom }) => React$A.createElement(
  React$A.Fragment,
  null,
  data?.label,
  React$A.createElement(Handle$1, { type: "source", position: sourcePosition, isConnectable })
);
InputNode.displayName = "InputNode";
var InputNode$1 = memo$o(InputNode);
const OutputNode = ({ data, isConnectable, targetPosition = Position.Top }) => React$A.createElement(
  React$A.Fragment,
  null,
  React$A.createElement(Handle$1, { type: "target", position: targetPosition, isConnectable }),
  data?.label
);
OutputNode.displayName = "OutputNode";
var OutputNode$1 = memo$o(OutputNode);
const GroupNode = () => null;
GroupNode.displayName = "GroupNode";
const selector$e = (s) => ({
  selectedNodes: s.getNodes().filter((n) => n.selected),
  selectedEdges: s.edges.filter((e) => e.selected).map((e) => ({ ...e }))
});
const selectId = (obj) => obj.id;
function areEqual(a, b) {
  return shallow$1(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && shallow$1(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));
}
const SelectionListener = memo$o(({ onSelectionChange }) => {
  const store = useStoreApi();
  const { selectedNodes, selectedEdges } = useStore(selector$e, areEqual);
  useEffect$q(() => {
    const params = { nodes: selectedNodes, edges: selectedEdges };
    onSelectionChange?.(params);
    store.getState().onSelectionChange.forEach((fn) => fn(params));
  }, [selectedNodes, selectedEdges, onSelectionChange]);
  return null;
});
SelectionListener.displayName = "SelectionListener";
const changeSelector = (s) => !!s.onSelectionChange;
function Wrapper$1({ onSelectionChange }) {
  const storeHasSelectionChange = useStore(changeSelector);
  if (onSelectionChange || storeHasSelectionChange) {
    return React$A.createElement(SelectionListener, { onSelectionChange });
  }
  return null;
}
const selector$d = (s) => ({
  setNodes: s.setNodes,
  setEdges: s.setEdges,
  setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,
  setMinZoom: s.setMinZoom,
  setMaxZoom: s.setMaxZoom,
  setTranslateExtent: s.setTranslateExtent,
  setNodeExtent: s.setNodeExtent,
  reset: s.reset
});
function useStoreUpdater(value, setStoreState) {
  useEffect$q(() => {
    if (typeof value !== "undefined") {
      setStoreState(value);
    }
  }, [value]);
}
function useDirectStoreUpdater(key, value, setState) {
  useEffect$q(() => {
    if (typeof value !== "undefined") {
      setState({ [key]: value });
    }
  }, [value]);
}
const StoreUpdater = ({ nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesUpdatable, elevateNodesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, elementsSelectable, connectionMode, snapGrid, snapToGrid, translateExtent, connectOnClick, defaultEdgeOptions, fitView: fitView2, fitViewOptions, onNodesDelete, onEdgesDelete, onNodeDrag, onNodeDragStart, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, onError, connectionRadius, isValidConnection, nodeDragThreshold }) => {
  const { setNodes, setEdges, setDefaultNodesAndEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset } = useStore(selector$d, shallow$1);
  const store = useStoreApi();
  useEffect$q(() => {
    const edgesWithDefaults = defaultEdges?.map((e) => ({ ...e, ...defaultEdgeOptions }));
    setDefaultNodesAndEdges(defaultNodes, edgesWithDefaults);
    return () => {
      reset();
    };
  }, []);
  useDirectStoreUpdater("defaultEdgeOptions", defaultEdgeOptions, store.setState);
  useDirectStoreUpdater("connectionMode", connectionMode, store.setState);
  useDirectStoreUpdater("onConnect", onConnect, store.setState);
  useDirectStoreUpdater("onConnectStart", onConnectStart, store.setState);
  useDirectStoreUpdater("onConnectEnd", onConnectEnd, store.setState);
  useDirectStoreUpdater("onClickConnectStart", onClickConnectStart, store.setState);
  useDirectStoreUpdater("onClickConnectEnd", onClickConnectEnd, store.setState);
  useDirectStoreUpdater("nodesDraggable", nodesDraggable, store.setState);
  useDirectStoreUpdater("nodesConnectable", nodesConnectable, store.setState);
  useDirectStoreUpdater("nodesFocusable", nodesFocusable, store.setState);
  useDirectStoreUpdater("edgesFocusable", edgesFocusable, store.setState);
  useDirectStoreUpdater("edgesUpdatable", edgesUpdatable, store.setState);
  useDirectStoreUpdater("elementsSelectable", elementsSelectable, store.setState);
  useDirectStoreUpdater("elevateNodesOnSelect", elevateNodesOnSelect, store.setState);
  useDirectStoreUpdater("snapToGrid", snapToGrid, store.setState);
  useDirectStoreUpdater("snapGrid", snapGrid, store.setState);
  useDirectStoreUpdater("onNodesChange", onNodesChange, store.setState);
  useDirectStoreUpdater("onEdgesChange", onEdgesChange, store.setState);
  useDirectStoreUpdater("connectOnClick", connectOnClick, store.setState);
  useDirectStoreUpdater("fitViewOnInit", fitView2, store.setState);
  useDirectStoreUpdater("fitViewOnInitOptions", fitViewOptions, store.setState);
  useDirectStoreUpdater("onNodesDelete", onNodesDelete, store.setState);
  useDirectStoreUpdater("onEdgesDelete", onEdgesDelete, store.setState);
  useDirectStoreUpdater("onNodeDrag", onNodeDrag, store.setState);
  useDirectStoreUpdater("onNodeDragStart", onNodeDragStart, store.setState);
  useDirectStoreUpdater("onNodeDragStop", onNodeDragStop, store.setState);
  useDirectStoreUpdater("onSelectionDrag", onSelectionDrag, store.setState);
  useDirectStoreUpdater("onSelectionDragStart", onSelectionDragStart, store.setState);
  useDirectStoreUpdater("onSelectionDragStop", onSelectionDragStop, store.setState);
  useDirectStoreUpdater("noPanClassName", noPanClassName, store.setState);
  useDirectStoreUpdater("nodeOrigin", nodeOrigin, store.setState);
  useDirectStoreUpdater("rfId", rfId, store.setState);
  useDirectStoreUpdater("autoPanOnConnect", autoPanOnConnect, store.setState);
  useDirectStoreUpdater("autoPanOnNodeDrag", autoPanOnNodeDrag, store.setState);
  useDirectStoreUpdater("onError", onError, store.setState);
  useDirectStoreUpdater("connectionRadius", connectionRadius, store.setState);
  useDirectStoreUpdater("isValidConnection", isValidConnection, store.setState);
  useDirectStoreUpdater("nodeDragThreshold", nodeDragThreshold, store.setState);
  useStoreUpdater(nodes, setNodes);
  useStoreUpdater(edges, setEdges);
  useStoreUpdater(minZoom, setMinZoom);
  useStoreUpdater(maxZoom, setMaxZoom);
  useStoreUpdater(translateExtent, setTranslateExtent);
  useStoreUpdater(nodeExtent, setNodeExtent);
  return null;
};
const style = { display: "none" };
const ariaLiveStyle = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
};
const ARIA_NODE_DESC_KEY = "react-flow__node-desc";
const ARIA_EDGE_DESC_KEY = "react-flow__edge-desc";
const ARIA_LIVE_MESSAGE = "react-flow__aria-live";
const selector$c = (s) => s.ariaLiveMessage;
function AriaLiveMessage({ rfId }) {
  const ariaLiveMessage = useStore(selector$c);
  return React$A.createElement("div", { id: `${ARIA_LIVE_MESSAGE}-${rfId}`, "aria-live": "assertive", "aria-atomic": "true", style: ariaLiveStyle }, ariaLiveMessage);
}
function A11yDescriptions({ rfId, disableKeyboardA11y }) {
  return React$A.createElement(
    React$A.Fragment,
    null,
    React$A.createElement(
      "div",
      { id: `${ARIA_NODE_DESC_KEY}-${rfId}`, style },
      "Press enter or space to select a node.",
      !disableKeyboardA11y && "You can then use the arrow keys to move the node around.",
      " Press delete to remove it and escape to cancel.",
      " "
    ),
    React$A.createElement("div", { id: `${ARIA_EDGE_DESC_KEY}-${rfId}`, style }, "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel."),
    !disableKeyboardA11y && React$A.createElement(AriaLiveMessage, { rfId })
  );
}
var useKeyPress = (keyCode = null, options = { actInsideInputWithModifier: true }) => {
  const [keyPressed, setKeyPressed] = useState$w(false);
  const modifierPressed = useRef$m(false);
  const pressedKeys = useRef$m(/* @__PURE__ */ new Set([]));
  const [keyCodes, keysToWatch] = useMemo$2(() => {
    if (keyCode !== null) {
      const keyCodeArr = Array.isArray(keyCode) ? keyCode : [keyCode];
      const keys = keyCodeArr.filter((kc) => typeof kc === "string").map((kc) => kc.split("+"));
      const keysFlat = keys.reduce((res, item) => res.concat(...item), []);
      return [keys, keysFlat];
    }
    return [[], []];
  }, [keyCode]);
  useEffect$q(() => {
    const doc = typeof document !== "undefined" ? document : null;
    const target = options?.target || doc;
    if (keyCode !== null) {
      const downHandler = (event) => {
        modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;
        const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event);
        if (preventAction) {
          return false;
        }
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        pressedKeys.current.add(event[keyOrCode]);
        if (isMatchingKey(keyCodes, pressedKeys.current, false)) {
          event.preventDefault();
          setKeyPressed(true);
        }
      };
      const upHandler = (event) => {
        const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && isInputDOMNode(event);
        if (preventAction) {
          return false;
        }
        const keyOrCode = useKeyOrCode(event.code, keysToWatch);
        if (isMatchingKey(keyCodes, pressedKeys.current, true)) {
          setKeyPressed(false);
          pressedKeys.current.clear();
        } else {
          pressedKeys.current.delete(event[keyOrCode]);
        }
        if (event.key === "Meta") {
          pressedKeys.current.clear();
        }
        modifierPressed.current = false;
      };
      const resetHandler = () => {
        pressedKeys.current.clear();
        setKeyPressed(false);
      };
      target?.addEventListener("keydown", downHandler);
      target?.addEventListener("keyup", upHandler);
      window.addEventListener("blur", resetHandler);
      return () => {
        target?.removeEventListener("keydown", downHandler);
        target?.removeEventListener("keyup", upHandler);
        window.removeEventListener("blur", resetHandler);
      };
    }
  }, [keyCode, setKeyPressed]);
  return keyPressed;
};
function isMatchingKey(keyCodes, pressedKeys, isUp) {
  return keyCodes.filter((keys) => isUp || keys.length === pressedKeys.size).some((keys) => keys.every((k) => pressedKeys.has(k)));
}
function useKeyOrCode(eventCode, keysToWatch) {
  return keysToWatch.includes(eventCode) ? "code" : "key";
}
function calculateXYZPosition(node, nodeInternals, result, nodeOrigin) {
  const parentId = node.parentNode || node.parentId;
  if (!parentId) {
    return result;
  }
  const parentNode = nodeInternals.get(parentId);
  const parentNodePosition = getNodePositionWithOrigin(parentNode, nodeOrigin);
  return calculateXYZPosition(parentNode, nodeInternals, {
    x: (result.x ?? 0) + parentNodePosition.x,
    y: (result.y ?? 0) + parentNodePosition.y,
    z: (parentNode[internalsSymbol]?.z ?? 0) > (result.z ?? 0) ? parentNode[internalsSymbol]?.z ?? 0 : result.z ?? 0
  }, nodeOrigin);
}
function updateAbsoluteNodePositions(nodeInternals, nodeOrigin, parentNodes) {
  nodeInternals.forEach((node) => {
    const parentId = node.parentNode || node.parentId;
    if (parentId && !nodeInternals.has(parentId)) {
      throw new Error(`Parent node ${parentId} not found`);
    }
    if (parentId || parentNodes?.[node.id]) {
      const { x, y, z } = calculateXYZPosition(node, nodeInternals, {
        ...node.position,
        z: node[internalsSymbol]?.z ?? 0
      }, nodeOrigin);
      node.positionAbsolute = {
        x,
        y
      };
      node[internalsSymbol].z = z;
      if (parentNodes?.[node.id]) {
        node[internalsSymbol].isParent = true;
      }
    }
  });
}
function createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) {
  const nextNodeInternals = /* @__PURE__ */ new Map();
  const parentNodes = {};
  const selectedNodeZ = elevateNodesOnSelect ? 1e3 : 0;
  nodes.forEach((node) => {
    const z = (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);
    const currInternals = nodeInternals.get(node.id);
    const internals = {
      ...node,
      positionAbsolute: {
        x: node.position.x,
        y: node.position.y
      }
    };
    const parentId = node.parentNode || node.parentId;
    if (parentId) {
      parentNodes[parentId] = true;
    }
    const resetHandleBounds = currInternals?.type && currInternals?.type !== node.type;
    Object.defineProperty(internals, internalsSymbol, {
      enumerable: false,
      value: {
        handleBounds: resetHandleBounds ? void 0 : currInternals?.[internalsSymbol]?.handleBounds,
        z
      }
    });
    nextNodeInternals.set(node.id, internals);
  });
  updateAbsoluteNodePositions(nextNodeInternals, nodeOrigin, parentNodes);
  return nextNodeInternals;
}
function fitView(get, options = {}) {
  const { getNodes, width, height, minZoom, maxZoom, d3Zoom, d3Selection, fitViewOnInitDone, fitViewOnInit, nodeOrigin } = get();
  const isInitialFitView = options.initial && !fitViewOnInitDone && fitViewOnInit;
  const d3initialized = d3Zoom && d3Selection;
  if (d3initialized && (isInitialFitView || !options.initial)) {
    const nodes = getNodes().filter((n) => {
      const isVisible = options.includeHiddenNodes ? n.width && n.height : !n.hidden;
      if (options.nodes?.length) {
        return isVisible && options.nodes.some((optionNode) => optionNode.id === n.id);
      }
      return isVisible;
    });
    const nodesInitialized = nodes.every((n) => n.width && n.height);
    if (nodes.length > 0 && nodesInitialized) {
      const bounds = getNodesBounds(nodes, nodeOrigin);
      const { x, y, zoom: zoom2 } = getViewportForBounds(bounds, width, height, options.minZoom ?? minZoom, options.maxZoom ?? maxZoom, options.padding ?? 0.1);
      const nextTransform = identity.translate(x, y).scale(zoom2);
      if (typeof options.duration === "number" && options.duration > 0) {
        d3Zoom.transform(getD3Transition(d3Selection, options.duration), nextTransform);
      } else {
        d3Zoom.transform(d3Selection, nextTransform);
      }
      return true;
    }
  }
  return false;
}
function handleControlledNodeSelectionChange(nodeChanges, nodeInternals) {
  nodeChanges.forEach((change) => {
    const node = nodeInternals.get(change.id);
    if (node) {
      nodeInternals.set(node.id, {
        ...node,
        [internalsSymbol]: node[internalsSymbol],
        selected: change.selected
      });
    }
  });
  return new Map(nodeInternals);
}
function handleControlledEdgeSelectionChange(edgeChanges, edges) {
  return edges.map((e) => {
    const change = edgeChanges.find((change2) => change2.id === e.id);
    if (change) {
      e.selected = change.selected;
    }
    return e;
  });
}
function updateNodesAndEdgesSelections({ changedNodes, changedEdges, get, set }) {
  const { nodeInternals, edges, onNodesChange, onEdgesChange, hasDefaultNodes, hasDefaultEdges } = get();
  if (changedNodes?.length) {
    if (hasDefaultNodes) {
      set({ nodeInternals: handleControlledNodeSelectionChange(changedNodes, nodeInternals) });
    }
    onNodesChange?.(changedNodes);
  }
  if (changedEdges?.length) {
    if (hasDefaultEdges) {
      set({ edges: handleControlledEdgeSelectionChange(changedEdges, edges) });
    }
    onEdgesChange?.(changedEdges);
  }
}
const noop = () => {
};
const initialViewportHelper = {
  zoomIn: noop,
  zoomOut: noop,
  zoomTo: noop,
  getZoom: () => 1,
  setViewport: noop,
  getViewport: () => ({ x: 0, y: 0, zoom: 1 }),
  fitView: () => false,
  setCenter: noop,
  fitBounds: noop,
  project: (position) => position,
  screenToFlowPosition: (position) => position,
  flowToScreenPosition: (position) => position,
  viewportInitialized: false
};
const selector$b = (s) => ({
  d3Zoom: s.d3Zoom,
  d3Selection: s.d3Selection
});
const useViewportHelper = () => {
  const store = useStoreApi();
  const { d3Zoom, d3Selection } = useStore(selector$b, shallow$1);
  const viewportHelperFunctions = useMemo$2(() => {
    if (d3Selection && d3Zoom) {
      return {
        zoomIn: (options) => d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1.2),
        zoomOut: (options) => d3Zoom.scaleBy(getD3Transition(d3Selection, options?.duration), 1 / 1.2),
        zoomTo: (zoomLevel, options) => d3Zoom.scaleTo(getD3Transition(d3Selection, options?.duration), zoomLevel),
        getZoom: () => store.getState().transform[2],
        setViewport: (transform, options) => {
          const [x, y, zoom2] = store.getState().transform;
          const nextTransform = identity.translate(transform.x ?? x, transform.y ?? y).scale(transform.zoom ?? zoom2);
          d3Zoom.transform(getD3Transition(d3Selection, options?.duration), nextTransform);
        },
        getViewport: () => {
          const [x, y, zoom2] = store.getState().transform;
          return { x, y, zoom: zoom2 };
        },
        fitView: (options) => fitView(store.getState, options),
        setCenter: (x, y, options) => {
          const { width, height, maxZoom } = store.getState();
          const nextZoom = typeof options?.zoom !== "undefined" ? options.zoom : maxZoom;
          const centerX = width / 2 - x * nextZoom;
          const centerY = height / 2 - y * nextZoom;
          const transform = identity.translate(centerX, centerY).scale(nextZoom);
          d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);
        },
        fitBounds: (bounds, options) => {
          const { width, height, minZoom, maxZoom } = store.getState();
          const { x, y, zoom: zoom2 } = getViewportForBounds(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);
          const transform = identity.translate(x, y).scale(zoom2);
          d3Zoom.transform(getD3Transition(d3Selection, options?.duration), transform);
        },
        // @deprecated Use `screenToFlowPosition`.
        project: (position) => {
          const { transform, snapToGrid, snapGrid } = store.getState();
          console.warn("[DEPRECATED] `project` is deprecated. Instead use `screenToFlowPosition`. There is no need to subtract the react flow bounds anymore! https://reactflow.dev/api-reference/types/react-flow-instance#screen-to-flow-position");
          return pointToRendererPoint(position, transform, snapToGrid, snapGrid);
        },
        screenToFlowPosition: (position) => {
          const { transform, snapToGrid, snapGrid, domNode } = store.getState();
          if (!domNode) {
            return position;
          }
          const { x: domX, y: domY } = domNode.getBoundingClientRect();
          const relativePosition = {
            x: position.x - domX,
            y: position.y - domY
          };
          return pointToRendererPoint(relativePosition, transform, snapToGrid, snapGrid);
        },
        flowToScreenPosition: (position) => {
          const { transform, domNode } = store.getState();
          if (!domNode) {
            return position;
          }
          const { x: domX, y: domY } = domNode.getBoundingClientRect();
          const rendererPosition = rendererPointToPoint(position, transform);
          return {
            x: rendererPosition.x + domX,
            y: rendererPosition.y + domY
          };
        },
        viewportInitialized: true
      };
    }
    return initialViewportHelper;
  }, [d3Zoom, d3Selection]);
  return viewportHelperFunctions;
};
function useReactFlow() {
  const viewportHelper = useViewportHelper();
  const store = useStoreApi();
  const getNodes = useCallback$n(() => {
    return store.getState().getNodes().map((n) => ({ ...n }));
  }, []);
  const getNode = useCallback$n((id) => {
    return store.getState().nodeInternals.get(id);
  }, []);
  const getEdges = useCallback$n(() => {
    const { edges = [] } = store.getState();
    return edges.map((e) => ({ ...e }));
  }, []);
  const getEdge = useCallback$n((id) => {
    const { edges = [] } = store.getState();
    return edges.find((e) => e.id === id);
  }, []);
  const setNodes = useCallback$n((payload) => {
    const { getNodes: getNodes2, setNodes: setNodes2, hasDefaultNodes, onNodesChange } = store.getState();
    const nodes = getNodes2();
    const nextNodes = typeof payload === "function" ? payload(nodes) : payload;
    if (hasDefaultNodes) {
      setNodes2(nextNodes);
    } else if (onNodesChange) {
      const changes = nextNodes.length === 0 ? nodes.map((node) => ({ type: "remove", id: node.id })) : nextNodes.map((node) => ({ item: node, type: "reset" }));
      onNodesChange(changes);
    }
  }, []);
  const setEdges = useCallback$n((payload) => {
    const { edges = [], setEdges: setEdges2, hasDefaultEdges, onEdgesChange } = store.getState();
    const nextEdges = typeof payload === "function" ? payload(edges) : payload;
    if (hasDefaultEdges) {
      setEdges2(nextEdges);
    } else if (onEdgesChange) {
      const changes = nextEdges.length === 0 ? edges.map((edge) => ({ type: "remove", id: edge.id })) : nextEdges.map((edge) => ({ item: edge, type: "reset" }));
      onEdgesChange(changes);
    }
  }, []);
  const addNodes = useCallback$n((payload) => {
    const nodes = Array.isArray(payload) ? payload : [payload];
    const { getNodes: getNodes2, setNodes: setNodes2, hasDefaultNodes, onNodesChange } = store.getState();
    if (hasDefaultNodes) {
      const currentNodes = getNodes2();
      const nextNodes = [...currentNodes, ...nodes];
      setNodes2(nextNodes);
    } else if (onNodesChange) {
      const changes = nodes.map((node) => ({ item: node, type: "add" }));
      onNodesChange(changes);
    }
  }, []);
  const addEdges = useCallback$n((payload) => {
    const nextEdges = Array.isArray(payload) ? payload : [payload];
    const { edges = [], setEdges: setEdges2, hasDefaultEdges, onEdgesChange } = store.getState();
    if (hasDefaultEdges) {
      setEdges2([...edges, ...nextEdges]);
    } else if (onEdgesChange) {
      const changes = nextEdges.map((edge) => ({ item: edge, type: "add" }));
      onEdgesChange(changes);
    }
  }, []);
  const toObject = useCallback$n(() => {
    const { getNodes: getNodes2, edges = [], transform } = store.getState();
    const [x, y, zoom2] = transform;
    return {
      nodes: getNodes2().map((n) => ({ ...n })),
      edges: edges.map((e) => ({ ...e })),
      viewport: {
        x,
        y,
        zoom: zoom2
      }
    };
  }, []);
  const deleteElements = useCallback$n(({ nodes: nodesDeleted, edges: edgesDeleted }) => {
    const { nodeInternals, getNodes: getNodes2, edges, hasDefaultNodes, hasDefaultEdges, onNodesDelete, onEdgesDelete, onNodesChange, onEdgesChange } = store.getState();
    const nodeIds = (nodesDeleted || []).map((node) => node.id);
    const edgeIds = (edgesDeleted || []).map((edge) => edge.id);
    const nodesToRemove = getNodes2().reduce((res, node) => {
      const parentId = node.parentNode || node.parentId;
      const parentHit = !nodeIds.includes(node.id) && parentId && res.find((n) => n.id === parentId);
      const deletable = typeof node.deletable === "boolean" ? node.deletable : true;
      if (deletable && (nodeIds.includes(node.id) || parentHit)) {
        res.push(node);
      }
      return res;
    }, []);
    const deletableEdges = edges.filter((e) => typeof e.deletable === "boolean" ? e.deletable : true);
    const initialHitEdges = deletableEdges.filter((e) => edgeIds.includes(e.id));
    if (nodesToRemove || initialHitEdges) {
      const connectedEdges = getConnectedEdges(nodesToRemove, deletableEdges);
      const edgesToRemove = [...initialHitEdges, ...connectedEdges];
      const edgeIdsToRemove = edgesToRemove.reduce((res, edge) => {
        if (!res.includes(edge.id)) {
          res.push(edge.id);
        }
        return res;
      }, []);
      if (hasDefaultEdges || hasDefaultNodes) {
        if (hasDefaultEdges) {
          store.setState({
            edges: edges.filter((e) => !edgeIdsToRemove.includes(e.id))
          });
        }
        if (hasDefaultNodes) {
          nodesToRemove.forEach((node) => {
            nodeInternals.delete(node.id);
          });
          store.setState({
            nodeInternals: new Map(nodeInternals)
          });
        }
      }
      if (edgeIdsToRemove.length > 0) {
        onEdgesDelete?.(edgesToRemove);
        if (onEdgesChange) {
          onEdgesChange(edgeIdsToRemove.map((id) => ({
            id,
            type: "remove"
          })));
        }
      }
      if (nodesToRemove.length > 0) {
        onNodesDelete?.(nodesToRemove);
        if (onNodesChange) {
          const nodeChanges = nodesToRemove.map((n) => ({ id: n.id, type: "remove" }));
          onNodesChange(nodeChanges);
        }
      }
    }
  }, []);
  const getNodeRect = useCallback$n((nodeOrRect) => {
    const isRect = isRectObject(nodeOrRect);
    const node = isRect ? null : store.getState().nodeInternals.get(nodeOrRect.id);
    if (!isRect && !node) {
      return [null, null, isRect];
    }
    const nodeRect = isRect ? nodeOrRect : nodeToRect(node);
    return [nodeRect, node, isRect];
  }, []);
  const getIntersectingNodes = useCallback$n((nodeOrRect, partially = true, nodes) => {
    const [nodeRect, node, isRect] = getNodeRect(nodeOrRect);
    if (!nodeRect) {
      return [];
    }
    return (nodes || store.getState().getNodes()).filter((n) => {
      if (!isRect && (n.id === node.id || !n.positionAbsolute)) {
        return false;
      }
      const currNodeRect = nodeToRect(n);
      const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
      const partiallyVisible = partially && overlappingArea > 0;
      return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
    });
  }, []);
  const isNodeIntersecting = useCallback$n((nodeOrRect, area, partially = true) => {
    const [nodeRect] = getNodeRect(nodeOrRect);
    if (!nodeRect) {
      return false;
    }
    const overlappingArea = getOverlappingArea(nodeRect, area);
    const partiallyVisible = partially && overlappingArea > 0;
    return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
  }, []);
  return useMemo$2(() => {
    return {
      ...viewportHelper,
      getNodes,
      getNode,
      getEdges,
      getEdge,
      setNodes,
      setEdges,
      addNodes,
      addEdges,
      toObject,
      deleteElements,
      getIntersectingNodes,
      isNodeIntersecting
    };
  }, [
    viewportHelper,
    getNodes,
    getNode,
    getEdges,
    getEdge,
    setNodes,
    setEdges,
    addNodes,
    addEdges,
    toObject,
    deleteElements,
    getIntersectingNodes,
    isNodeIntersecting
  ]);
}
const deleteKeyOptions = { actInsideInputWithModifier: false };
var useGlobalKeyHandler = ({ deleteKeyCode, multiSelectionKeyCode }) => {
  const store = useStoreApi();
  const { deleteElements } = useReactFlow();
  const deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);
  const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode);
  useEffect$q(() => {
    if (deleteKeyPressed) {
      const { edges, getNodes } = store.getState();
      const selectedNodes = getNodes().filter((node) => node.selected);
      const selectedEdges = edges.filter((edge) => edge.selected);
      deleteElements({ nodes: selectedNodes, edges: selectedEdges });
      store.setState({ nodesSelectionActive: false });
    }
  }, [deleteKeyPressed]);
  useEffect$q(() => {
    store.setState({ multiSelectionActive: multiSelectionKeyPressed });
  }, [multiSelectionKeyPressed]);
};
function useResizeHandler(rendererNode) {
  const store = useStoreApi();
  useEffect$q(() => {
    let resizeObserver;
    const updateDimensions = () => {
      if (!rendererNode.current) {
        return;
      }
      const size = getDimensions(rendererNode.current);
      if (size.height === 0 || size.width === 0) {
        store.getState().onError?.("004", errorMessages["error004"]());
      }
      store.setState({ width: size.width || 500, height: size.height || 500 });
    };
    updateDimensions();
    window.addEventListener("resize", updateDimensions);
    if (rendererNode.current) {
      resizeObserver = new ResizeObserver(() => updateDimensions());
      resizeObserver.observe(rendererNode.current);
    }
    return () => {
      window.removeEventListener("resize", updateDimensions);
      if (resizeObserver && rendererNode.current) {
        resizeObserver.unobserve(rendererNode.current);
      }
    };
  }, []);
}
const containerStyle = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
};
const viewChanged = (prevViewport, eventTransform) => prevViewport.x !== eventTransform.x || prevViewport.y !== eventTransform.y || prevViewport.zoom !== eventTransform.k;
const eventToFlowTransform = (eventTransform) => ({
  x: eventTransform.x,
  y: eventTransform.y,
  zoom: eventTransform.k
});
const isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);
const isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);
const wheelDelta = (event) => {
  const factor = event.ctrlKey && isMacOs() ? 10 : 1;
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
};
const selector$a = (s) => ({
  d3Zoom: s.d3Zoom,
  d3Selection: s.d3Selection,
  d3ZoomHandler: s.d3ZoomHandler,
  userSelectionActive: s.userSelectionActive
});
const ZoomPane = ({ onMove, onMoveStart, onMoveEnd, onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, elementsSelectable, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName }) => {
  const timerId = useRef$m();
  const store = useStoreApi();
  const isZoomingOrPanning = useRef$m(false);
  const zoomedWithRightMouseButton = useRef$m(false);
  const zoomPane = useRef$m(null);
  const prevTransform = useRef$m({ x: 0, y: 0, zoom: 0 });
  const { d3Zoom, d3Selection, d3ZoomHandler, userSelectionActive } = useStore(selector$a, shallow$1);
  const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);
  const mouseButton = useRef$m(0);
  const isPanScrolling = useRef$m(false);
  const panScrollTimeout = useRef$m();
  useResizeHandler(zoomPane);
  useEffect$q(() => {
    if (zoomPane.current) {
      const bbox = zoomPane.current.getBoundingClientRect();
      const d3ZoomInstance = zoom().scaleExtent([minZoom, maxZoom]).translateExtent(translateExtent);
      const selection = select(zoomPane.current).call(d3ZoomInstance);
      const updatedTransform = identity.translate(defaultViewport.x, defaultViewport.y).scale(clamp(defaultViewport.zoom, minZoom, maxZoom));
      const extent = [
        [0, 0],
        [bbox.width, bbox.height]
      ];
      const constrainedTransform = d3ZoomInstance.constrain()(updatedTransform, extent, translateExtent);
      d3ZoomInstance.transform(selection, constrainedTransform);
      d3ZoomInstance.wheelDelta(wheelDelta);
      store.setState({
        d3Zoom: d3ZoomInstance,
        d3Selection: selection,
        d3ZoomHandler: selection.on("wheel.zoom"),
        // we need to pass transform because zoom handler is not registered when we set the initial transform
        transform: [constrainedTransform.x, constrainedTransform.y, constrainedTransform.k],
        domNode: zoomPane.current.closest(".react-flow")
      });
    }
  }, []);
  useEffect$q(() => {
    if (d3Selection && d3Zoom) {
      if (panOnScroll && !zoomActivationKeyPressed && !userSelectionActive) {
        d3Selection.on("wheel.zoom", (event) => {
          if (isWrappedWithClass(event, noWheelClassName)) {
            return false;
          }
          event.preventDefault();
          event.stopImmediatePropagation();
          const currentZoom = d3Selection.property("__zoom").k || 1;
          if (event.ctrlKey && zoomOnPinch) {
            const point = pointer(event);
            const pinchDelta = wheelDelta(event);
            const zoom2 = currentZoom * Math.pow(2, pinchDelta);
            d3Zoom.scaleTo(d3Selection, zoom2, point, event);
            return;
          }
          const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
          let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;
          let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
          if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {
            deltaX = event.deltaY * deltaNormalize;
            deltaY = 0;
          }
          d3Zoom.translateBy(
            d3Selection,
            -(deltaX / currentZoom) * panOnScrollSpeed,
            -(deltaY / currentZoom) * panOnScrollSpeed,
            // @ts-ignore
            { internal: true }
          );
          const nextViewport = eventToFlowTransform(d3Selection.property("__zoom"));
          const { onViewportChangeStart, onViewportChange, onViewportChangeEnd } = store.getState();
          clearTimeout(panScrollTimeout.current);
          if (!isPanScrolling.current) {
            isPanScrolling.current = true;
            onMoveStart?.(event, nextViewport);
            onViewportChangeStart?.(nextViewport);
          }
          if (isPanScrolling.current) {
            onMove?.(event, nextViewport);
            onViewportChange?.(nextViewport);
            panScrollTimeout.current = setTimeout(() => {
              onMoveEnd?.(event, nextViewport);
              onViewportChangeEnd?.(nextViewport);
              isPanScrolling.current = false;
            }, 150);
          }
        }, { passive: false });
      } else if (typeof d3ZoomHandler !== "undefined") {
        d3Selection.on("wheel.zoom", function(event, d) {
          const invalidEvent = !preventScrolling && event.type === "wheel" && !event.ctrlKey;
          if (invalidEvent || isWrappedWithClass(event, noWheelClassName)) {
            return null;
          }
          event.preventDefault();
          d3ZoomHandler.call(this, event, d);
        }, { passive: false });
      }
    }
  }, [
    userSelectionActive,
    panOnScroll,
    panOnScrollMode,
    d3Selection,
    d3Zoom,
    d3ZoomHandler,
    zoomActivationKeyPressed,
    zoomOnPinch,
    preventScrolling,
    noWheelClassName,
    onMoveStart,
    onMove,
    onMoveEnd
  ]);
  useEffect$q(() => {
    if (d3Zoom) {
      d3Zoom.on("start", (event) => {
        if (!event.sourceEvent || event.sourceEvent.internal) {
          return null;
        }
        mouseButton.current = event.sourceEvent?.button;
        const { onViewportChangeStart } = store.getState();
        const flowTransform = eventToFlowTransform(event.transform);
        isZoomingOrPanning.current = true;
        prevTransform.current = flowTransform;
        if (event.sourceEvent?.type === "mousedown") {
          store.setState({ paneDragging: true });
        }
        onViewportChangeStart?.(flowTransform);
        onMoveStart?.(event.sourceEvent, flowTransform);
      });
    }
  }, [d3Zoom, onMoveStart]);
  useEffect$q(() => {
    if (d3Zoom) {
      if (userSelectionActive && !isZoomingOrPanning.current) {
        d3Zoom.on("zoom", null);
      } else if (!userSelectionActive) {
        d3Zoom.on("zoom", (event) => {
          const { onViewportChange } = store.getState();
          store.setState({ transform: [event.transform.x, event.transform.y, event.transform.k] });
          zoomedWithRightMouseButton.current = !!(onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0));
          if ((onMove || onViewportChange) && !event.sourceEvent?.internal) {
            const flowTransform = eventToFlowTransform(event.transform);
            onViewportChange?.(flowTransform);
            onMove?.(event.sourceEvent, flowTransform);
          }
        });
      }
    }
  }, [userSelectionActive, d3Zoom, onMove, panOnDrag, onPaneContextMenu]);
  useEffect$q(() => {
    if (d3Zoom) {
      d3Zoom.on("end", (event) => {
        if (!event.sourceEvent || event.sourceEvent.internal) {
          return null;
        }
        const { onViewportChangeEnd } = store.getState();
        isZoomingOrPanning.current = false;
        store.setState({ paneDragging: false });
        if (onPaneContextMenu && isRightClickPan(panOnDrag, mouseButton.current ?? 0) && !zoomedWithRightMouseButton.current) {
          onPaneContextMenu(event.sourceEvent);
        }
        zoomedWithRightMouseButton.current = false;
        if ((onMoveEnd || onViewportChangeEnd) && viewChanged(prevTransform.current, event.transform)) {
          const flowTransform = eventToFlowTransform(event.transform);
          prevTransform.current = flowTransform;
          clearTimeout(timerId.current);
          timerId.current = setTimeout(() => {
            onViewportChangeEnd?.(flowTransform);
            onMoveEnd?.(event.sourceEvent, flowTransform);
          }, panOnScroll ? 150 : 0);
        }
      });
    }
  }, [d3Zoom, panOnScroll, panOnDrag, onMoveEnd, onPaneContextMenu]);
  useEffect$q(() => {
    if (d3Zoom) {
      d3Zoom.filter((event) => {
        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;
        const pinchZoom = zoomOnPinch && event.ctrlKey;
        if ((panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(1)) && event.button === 1 && event.type === "mousedown" && (isWrappedWithClass(event, "react-flow__node") || isWrappedWithClass(event, "react-flow__edge"))) {
          return true;
        }
        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {
          return false;
        }
        if (userSelectionActive) {
          return false;
        }
        if (!zoomOnDoubleClick && event.type === "dblclick") {
          return false;
        }
        if (isWrappedWithClass(event, noWheelClassName) && event.type === "wheel") {
          return false;
        }
        if (isWrappedWithClass(event, noPanClassName) && (event.type !== "wheel" || panOnScroll && event.type === "wheel" && !zoomActivationKeyPressed)) {
          return false;
        }
        if (!zoomOnPinch && event.ctrlKey && event.type === "wheel") {
          return false;
        }
        if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === "wheel") {
          return false;
        }
        if (!panOnDrag && (event.type === "mousedown" || event.type === "touchstart")) {
          return false;
        }
        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === "mousedown") {
          return false;
        }
        const buttonAllowed = Array.isArray(panOnDrag) && panOnDrag.includes(event.button) || !event.button || event.button <= 1;
        return (!event.ctrlKey || event.type === "wheel") && buttonAllowed;
      });
    }
  }, [
    userSelectionActive,
    d3Zoom,
    zoomOnScroll,
    zoomOnPinch,
    panOnScroll,
    zoomOnDoubleClick,
    panOnDrag,
    elementsSelectable,
    zoomActivationKeyPressed
  ]);
  return React$A.createElement("div", { className: "react-flow__renderer", ref: zoomPane, style: containerStyle }, children);
};
const selector$9 = (s) => ({
  userSelectionActive: s.userSelectionActive,
  userSelectionRect: s.userSelectionRect
});
function UserSelection() {
  const { userSelectionActive, userSelectionRect } = useStore(selector$9, shallow$1);
  const isActive = userSelectionActive && userSelectionRect;
  if (!isActive) {
    return null;
  }
  return React$A.createElement("div", { className: "react-flow__selection react-flow__container", style: {
    width: userSelectionRect.width,
    height: userSelectionRect.height,
    transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`
  } });
}
function handleParentExpand(res, updateItem) {
  const parentId = updateItem.parentNode || updateItem.parentId;
  const parent = res.find((e) => e.id === parentId);
  if (parent) {
    const extendWidth = updateItem.position.x + updateItem.width - parent.width;
    const extendHeight = updateItem.position.y + updateItem.height - parent.height;
    if (extendWidth > 0 || extendHeight > 0 || updateItem.position.x < 0 || updateItem.position.y < 0) {
      parent.style = { ...parent.style };
      parent.style.width = parent.style.width ?? parent.width;
      parent.style.height = parent.style.height ?? parent.height;
      if (extendWidth > 0) {
        parent.style.width += extendWidth;
      }
      if (extendHeight > 0) {
        parent.style.height += extendHeight;
      }
      if (updateItem.position.x < 0) {
        const xDiff = Math.abs(updateItem.position.x);
        parent.position.x = parent.position.x - xDiff;
        parent.style.width += xDiff;
        updateItem.position.x = 0;
      }
      if (updateItem.position.y < 0) {
        const yDiff = Math.abs(updateItem.position.y);
        parent.position.y = parent.position.y - yDiff;
        parent.style.height += yDiff;
        updateItem.position.y = 0;
      }
      parent.width = parent.style.width;
      parent.height = parent.style.height;
    }
  }
}
function applyChanges(changes, elements) {
  if (changes.some((c) => c.type === "reset")) {
    return changes.filter((c) => c.type === "reset").map((c) => c.item);
  }
  const initElements = changes.filter((c) => c.type === "add").map((c) => c.item);
  return elements.reduce((res, item) => {
    const currentChanges = changes.filter((c) => c.id === item.id);
    if (currentChanges.length === 0) {
      res.push(item);
      return res;
    }
    const updateItem = { ...item };
    for (const currentChange of currentChanges) {
      if (currentChange) {
        switch (currentChange.type) {
          case "select": {
            updateItem.selected = currentChange.selected;
            break;
          }
          case "position": {
            if (typeof currentChange.position !== "undefined") {
              updateItem.position = currentChange.position;
            }
            if (typeof currentChange.positionAbsolute !== "undefined") {
              updateItem.positionAbsolute = currentChange.positionAbsolute;
            }
            if (typeof currentChange.dragging !== "undefined") {
              updateItem.dragging = currentChange.dragging;
            }
            if (updateItem.expandParent) {
              handleParentExpand(res, updateItem);
            }
            break;
          }
          case "dimensions": {
            if (typeof currentChange.dimensions !== "undefined") {
              updateItem.width = currentChange.dimensions.width;
              updateItem.height = currentChange.dimensions.height;
            }
            if (typeof currentChange.updateStyle !== "undefined") {
              updateItem.style = { ...updateItem.style || {}, ...currentChange.dimensions };
            }
            if (typeof currentChange.resizing === "boolean") {
              updateItem.resizing = currentChange.resizing;
            }
            if (updateItem.expandParent) {
              handleParentExpand(res, updateItem);
            }
            break;
          }
          case "remove": {
            return res;
          }
        }
      }
    }
    res.push(updateItem);
    return res;
  }, initElements);
}
function applyNodeChanges(changes, nodes) {
  return applyChanges(changes, nodes);
}
function applyEdgeChanges(changes, edges) {
  return applyChanges(changes, edges);
}
const createSelectionChange = (id, selected) => ({
  id,
  type: "select",
  selected
});
function getSelectionChanges(items, selectedIds) {
  return items.reduce((res, item) => {
    const willBeSelected = selectedIds.includes(item.id);
    if (!item.selected && willBeSelected) {
      item.selected = true;
      res.push(createSelectionChange(item.id, true));
    } else if (item.selected && !willBeSelected) {
      item.selected = false;
      res.push(createSelectionChange(item.id, false));
    }
    return res;
  }, []);
}
const wrapHandler = (handler, containerRef) => {
  return (event) => {
    if (event.target !== containerRef.current) {
      return;
    }
    handler?.(event);
  };
};
const selector$8 = (s) => ({
  userSelectionActive: s.userSelectionActive,
  elementsSelectable: s.elementsSelectable,
  dragging: s.paneDragging
});
const Pane = memo$o(({ isSelecting, selectionMode = SelectionMode.Full, panOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) => {
  const container = useRef$m(null);
  const store = useStoreApi();
  const prevSelectedNodesCount = useRef$m(0);
  const prevSelectedEdgesCount = useRef$m(0);
  const containerBounds = useRef$m();
  const { userSelectionActive, elementsSelectable, dragging } = useStore(selector$8, shallow$1);
  const resetUserSelection = () => {
    store.setState({ userSelectionActive: false, userSelectionRect: null });
    prevSelectedNodesCount.current = 0;
    prevSelectedEdgesCount.current = 0;
  };
  const onClick = (event) => {
    onPaneClick?.(event);
    store.getState().resetSelectedElements();
    store.setState({ nodesSelectionActive: false });
  };
  const onContextMenu = (event) => {
    if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {
      event.preventDefault();
      return;
    }
    onPaneContextMenu?.(event);
  };
  const onWheel = onPaneScroll ? (event) => onPaneScroll(event) : void 0;
  const onMouseDown = (event) => {
    const { resetSelectedElements, domNode } = store.getState();
    containerBounds.current = domNode?.getBoundingClientRect();
    if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {
      return;
    }
    const { x, y } = getEventPosition(event, containerBounds.current);
    resetSelectedElements();
    store.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: x,
        startY: y,
        x,
        y
      }
    });
    onSelectionStart?.(event);
  };
  const onMouseMove = (event) => {
    const { userSelectionRect, nodeInternals, edges, transform, onNodesChange, onEdgesChange, nodeOrigin, getNodes } = store.getState();
    if (!isSelecting || !containerBounds.current || !userSelectionRect) {
      return;
    }
    store.setState({ userSelectionActive: true, nodesSelectionActive: false });
    const mousePos = getEventPosition(event, containerBounds.current);
    const startX = userSelectionRect.startX ?? 0;
    const startY = userSelectionRect.startY ?? 0;
    const nextUserSelectRect = {
      ...userSelectionRect,
      x: mousePos.x < startX ? mousePos.x : startX,
      y: mousePos.y < startY ? mousePos.y : startY,
      width: Math.abs(mousePos.x - startX),
      height: Math.abs(mousePos.y - startY)
    };
    const nodes = getNodes();
    const selectedNodes = getNodesInside(nodeInternals, nextUserSelectRect, transform, selectionMode === SelectionMode.Partial, true, nodeOrigin);
    const selectedEdgeIds = getConnectedEdges(selectedNodes, edges).map((e) => e.id);
    const selectedNodeIds = selectedNodes.map((n) => n.id);
    if (prevSelectedNodesCount.current !== selectedNodeIds.length) {
      prevSelectedNodesCount.current = selectedNodeIds.length;
      const changes = getSelectionChanges(nodes, selectedNodeIds);
      if (changes.length) {
        onNodesChange?.(changes);
      }
    }
    if (prevSelectedEdgesCount.current !== selectedEdgeIds.length) {
      prevSelectedEdgesCount.current = selectedEdgeIds.length;
      const changes = getSelectionChanges(edges, selectedEdgeIds);
      if (changes.length) {
        onEdgesChange?.(changes);
      }
    }
    store.setState({
      userSelectionRect: nextUserSelectRect
    });
  };
  const onMouseUp = (event) => {
    if (event.button !== 0) {
      return;
    }
    const { userSelectionRect } = store.getState();
    if (!userSelectionActive && userSelectionRect && event.target === container.current) {
      onClick?.(event);
    }
    store.setState({ nodesSelectionActive: prevSelectedNodesCount.current > 0 });
    resetUserSelection();
    onSelectionEnd?.(event);
  };
  const onMouseLeave = (event) => {
    if (userSelectionActive) {
      store.setState({ nodesSelectionActive: prevSelectedNodesCount.current > 0 });
      onSelectionEnd?.(event);
    }
    resetUserSelection();
  };
  const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);
  return React$A.createElement(
    "div",
    { className: cc(["react-flow__pane", { dragging, selection: isSelecting }]), onClick: hasActiveSelection ? void 0 : wrapHandler(onClick, container), onContextMenu: wrapHandler(onContextMenu, container), onWheel: wrapHandler(onWheel, container), onMouseEnter: hasActiveSelection ? void 0 : onPaneMouseEnter, onMouseDown: hasActiveSelection ? onMouseDown : void 0, onMouseMove: hasActiveSelection ? onMouseMove : onPaneMouseMove, onMouseUp: hasActiveSelection ? onMouseUp : void 0, onMouseLeave: hasActiveSelection ? onMouseLeave : onPaneMouseLeave, ref: container, style: containerStyle },
    children,
    React$A.createElement(UserSelection, null)
  );
});
Pane.displayName = "Pane";
function isParentSelected(node, nodeInternals) {
  const parentId = node.parentNode || node.parentId;
  if (!parentId) {
    return false;
  }
  const parentNode = nodeInternals.get(parentId);
  if (!parentNode) {
    return false;
  }
  if (parentNode.selected) {
    return true;
  }
  return isParentSelected(parentNode, nodeInternals);
}
function hasSelector(target, selector2, nodeRef) {
  let current = target;
  do {
    if (current?.matches(selector2))
      return true;
    if (current === nodeRef.current)
      return false;
    current = current.parentElement;
  } while (current);
  return false;
}
function getDragItems(nodeInternals, nodesDraggable, mousePos, nodeId) {
  return Array.from(nodeInternals.values()).filter((n) => (n.selected || n.id === nodeId) && (!n.parentNode || n.parentId || !isParentSelected(n, nodeInternals)) && (n.draggable || nodesDraggable && typeof n.draggable === "undefined")).map((n) => ({
    id: n.id,
    position: n.position || { x: 0, y: 0 },
    positionAbsolute: n.positionAbsolute || { x: 0, y: 0 },
    distance: {
      x: mousePos.x - (n.positionAbsolute?.x ?? 0),
      y: mousePos.y - (n.positionAbsolute?.y ?? 0)
    },
    delta: {
      x: 0,
      y: 0
    },
    extent: n.extent,
    parentNode: n.parentNode || n.parentId,
    parentId: n.parentNode || n.parentId,
    width: n.width,
    height: n.height,
    expandParent: n.expandParent
  }));
}
function clampNodeExtent(node, extent) {
  if (!extent || extent === "parent") {
    return extent;
  }
  return [extent[0], [extent[1][0] - (node.width || 0), extent[1][1] - (node.height || 0)]];
}
function calcNextPosition(node, nextPosition, nodeInternals, nodeExtent, nodeOrigin = [0, 0], onError) {
  const clampedNodeExtent = clampNodeExtent(node, node.extent || nodeExtent);
  let currentExtent = clampedNodeExtent;
  const parentId = node.parentNode || node.parentId;
  if (node.extent === "parent" && !node.expandParent) {
    if (parentId && node.width && node.height) {
      const parent = nodeInternals.get(parentId);
      const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;
      currentExtent = parent && isNumeric(parentX) && isNumeric(parentY) && isNumeric(parent.width) && isNumeric(parent.height) ? [
        [parentX + node.width * nodeOrigin[0], parentY + node.height * nodeOrigin[1]],
        [
          parentX + parent.width - node.width + node.width * nodeOrigin[0],
          parentY + parent.height - node.height + node.height * nodeOrigin[1]
        ]
      ] : currentExtent;
    } else {
      onError?.("005", errorMessages["error005"]());
      currentExtent = clampedNodeExtent;
    }
  } else if (node.extent && parentId && node.extent !== "parent") {
    const parent = nodeInternals.get(parentId);
    const { x: parentX, y: parentY } = getNodePositionWithOrigin(parent, nodeOrigin).positionAbsolute;
    currentExtent = [
      [node.extent[0][0] + parentX, node.extent[0][1] + parentY],
      [node.extent[1][0] + parentX, node.extent[1][1] + parentY]
    ];
  }
  let parentPosition = { x: 0, y: 0 };
  if (parentId) {
    const parentNode = nodeInternals.get(parentId);
    parentPosition = getNodePositionWithOrigin(parentNode, nodeOrigin).positionAbsolute;
  }
  const positionAbsolute = currentExtent && currentExtent !== "parent" ? clampPosition(nextPosition, currentExtent) : nextPosition;
  return {
    position: {
      x: positionAbsolute.x - parentPosition.x,
      y: positionAbsolute.y - parentPosition.y
    },
    positionAbsolute
  };
}
function getEventHandlerParams({ nodeId, dragItems, nodeInternals }) {
  const extentedDragItems = dragItems.map((n) => {
    const node = nodeInternals.get(n.id);
    return {
      ...node,
      position: n.position,
      positionAbsolute: n.positionAbsolute
    };
  });
  return [nodeId ? extentedDragItems.find((n) => n.id === nodeId) : extentedDragItems[0], extentedDragItems];
}
const getHandleBounds = (selector2, nodeElement, zoom2, nodeOrigin) => {
  const handles = nodeElement.querySelectorAll(selector2);
  if (!handles || !handles.length) {
    return null;
  }
  const handlesArray = Array.from(handles);
  const nodeBounds = nodeElement.getBoundingClientRect();
  const nodeOffset = {
    x: nodeBounds.width * nodeOrigin[0],
    y: nodeBounds.height * nodeOrigin[1]
  };
  return handlesArray.map((handle) => {
    const handleBounds = handle.getBoundingClientRect();
    return {
      id: handle.getAttribute("data-handleid"),
      position: handle.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left - nodeOffset.x) / zoom2,
      y: (handleBounds.top - nodeBounds.top - nodeOffset.y) / zoom2,
      ...getDimensions(handle)
    };
  });
};
function getMouseHandler(id, getState, handler) {
  return handler === void 0 ? handler : (event) => {
    const node = getState().nodeInternals.get(id);
    if (node) {
      handler(event, { ...node });
    }
  };
}
function handleNodeClick({ id, store, unselect = false, nodeRef }) {
  const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeInternals, onError } = store.getState();
  const node = nodeInternals.get(id);
  if (!node) {
    onError?.("012", errorMessages["error012"](id));
    return;
  }
  store.setState({ nodesSelectionActive: false });
  if (!node.selected) {
    addSelectedNodes([id]);
  } else if (unselect || node.selected && multiSelectionActive) {
    unselectNodesAndEdges({ nodes: [node], edges: [] });
    requestAnimationFrame(() => nodeRef?.current?.blur());
  }
}
function useGetPointerPosition() {
  const store = useStoreApi();
  const getPointerPosition = useCallback$n(({ sourceEvent }) => {
    const { transform, snapGrid, snapToGrid } = store.getState();
    const x = sourceEvent.touches ? sourceEvent.touches[0].clientX : sourceEvent.clientX;
    const y = sourceEvent.touches ? sourceEvent.touches[0].clientY : sourceEvent.clientY;
    const pointerPos = {
      x: (x - transform[0]) / transform[2],
      y: (y - transform[1]) / transform[2]
    };
    return {
      xSnapped: snapToGrid ? snapGrid[0] * Math.round(pointerPos.x / snapGrid[0]) : pointerPos.x,
      ySnapped: snapToGrid ? snapGrid[1] * Math.round(pointerPos.y / snapGrid[1]) : pointerPos.y,
      ...pointerPos
    };
  }, []);
  return getPointerPosition;
}
function wrapSelectionDragFunc(selectionFunc) {
  return (event, _, nodes) => selectionFunc?.(event, nodes);
}
function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, selectNodesOnDrag }) {
  const store = useStoreApi();
  const [dragging, setDragging] = useState$w(false);
  const dragItems = useRef$m([]);
  const lastPos = useRef$m({ x: null, y: null });
  const autoPanId = useRef$m(0);
  const containerBounds = useRef$m(null);
  const mousePosition = useRef$m({ x: 0, y: 0 });
  const dragEvent = useRef$m(null);
  const autoPanStarted = useRef$m(false);
  const dragStarted = useRef$m(false);
  const abortDrag = useRef$m(false);
  const getPointerPosition = useGetPointerPosition();
  useEffect$q(() => {
    if (nodeRef?.current) {
      const selection = select(nodeRef.current);
      const updateNodes = ({ x, y }) => {
        const { nodeInternals, onNodeDrag, onSelectionDrag, updateNodePositions, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onError } = store.getState();
        lastPos.current = { x, y };
        let hasChange = false;
        let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };
        if (dragItems.current.length > 1 && nodeExtent) {
          const rect = getNodesBounds(dragItems.current, nodeOrigin);
          nodesBox = rectToBox(rect);
        }
        dragItems.current = dragItems.current.map((n) => {
          const nextPosition = { x: x - n.distance.x, y: y - n.distance.y };
          if (snapToGrid) {
            nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);
            nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);
          }
          const adjustedNodeExtent = [
            [nodeExtent[0][0], nodeExtent[0][1]],
            [nodeExtent[1][0], nodeExtent[1][1]]
          ];
          if (dragItems.current.length > 1 && nodeExtent && !n.extent) {
            adjustedNodeExtent[0][0] = n.positionAbsolute.x - nodesBox.x + nodeExtent[0][0];
            adjustedNodeExtent[1][0] = n.positionAbsolute.x + (n.width ?? 0) - nodesBox.x2 + nodeExtent[1][0];
            adjustedNodeExtent[0][1] = n.positionAbsolute.y - nodesBox.y + nodeExtent[0][1];
            adjustedNodeExtent[1][1] = n.positionAbsolute.y + (n.height ?? 0) - nodesBox.y2 + nodeExtent[1][1];
          }
          const updatedPos = calcNextPosition(n, nextPosition, nodeInternals, adjustedNodeExtent, nodeOrigin, onError);
          hasChange = hasChange || n.position.x !== updatedPos.position.x || n.position.y !== updatedPos.position.y;
          n.position = updatedPos.position;
          n.positionAbsolute = updatedPos.positionAbsolute;
          return n;
        });
        if (!hasChange) {
          return;
        }
        updateNodePositions(dragItems.current, true, true);
        setDragging(true);
        const onDrag = nodeId ? onNodeDrag : wrapSelectionDragFunc(onSelectionDrag);
        if (onDrag && dragEvent.current) {
          const [currentNode, nodes] = getEventHandlerParams({
            nodeId,
            dragItems: dragItems.current,
            nodeInternals
          });
          onDrag(dragEvent.current, currentNode, nodes);
        }
      };
      const autoPan = () => {
        if (!containerBounds.current) {
          return;
        }
        const [xMovement, yMovement] = calcAutoPan(mousePosition.current, containerBounds.current);
        if (xMovement !== 0 || yMovement !== 0) {
          const { transform, panBy } = store.getState();
          lastPos.current.x = (lastPos.current.x ?? 0) - xMovement / transform[2];
          lastPos.current.y = (lastPos.current.y ?? 0) - yMovement / transform[2];
          if (panBy({ x: xMovement, y: yMovement })) {
            updateNodes(lastPos.current);
          }
        }
        autoPanId.current = requestAnimationFrame(autoPan);
      };
      const startDrag = (event) => {
        const { nodeInternals, multiSelectionActive, nodesDraggable, unselectNodesAndEdges, onNodeDragStart, onSelectionDragStart } = store.getState();
        dragStarted.current = true;
        const onStart = nodeId ? onNodeDragStart : wrapSelectionDragFunc(onSelectionDragStart);
        if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {
          if (!nodeInternals.get(nodeId)?.selected) {
            unselectNodesAndEdges();
          }
        }
        if (nodeId && isSelectable && selectNodesOnDrag) {
          handleNodeClick({
            id: nodeId,
            store,
            nodeRef
          });
        }
        const pointerPos = getPointerPosition(event);
        lastPos.current = pointerPos;
        dragItems.current = getDragItems(nodeInternals, nodesDraggable, pointerPos, nodeId);
        if (onStart && dragItems.current) {
          const [currentNode, nodes] = getEventHandlerParams({
            nodeId,
            dragItems: dragItems.current,
            nodeInternals
          });
          onStart(event.sourceEvent, currentNode, nodes);
        }
      };
      if (disabled) {
        selection.on(".drag", null);
      } else {
        const dragHandler = drag().on("start", (event) => {
          const { domNode, nodeDragThreshold } = store.getState();
          if (nodeDragThreshold === 0) {
            startDrag(event);
          }
          abortDrag.current = false;
          const pointerPos = getPointerPosition(event);
          lastPos.current = pointerPos;
          containerBounds.current = domNode?.getBoundingClientRect() || null;
          mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);
        }).on("drag", (event) => {
          const pointerPos = getPointerPosition(event);
          const { autoPanOnNodeDrag, nodeDragThreshold } = store.getState();
          if (event.sourceEvent.type === "touchmove" && event.sourceEvent.touches.length > 1) {
            abortDrag.current = true;
          }
          if (abortDrag.current) {
            return;
          }
          if (!autoPanStarted.current && dragStarted.current && autoPanOnNodeDrag) {
            autoPanStarted.current = true;
            autoPan();
          }
          if (!dragStarted.current) {
            const x = pointerPos.xSnapped - (lastPos?.current?.x ?? 0);
            const y = pointerPos.ySnapped - (lastPos?.current?.y ?? 0);
            const distance2 = Math.sqrt(x * x + y * y);
            if (distance2 > nodeDragThreshold) {
              startDrag(event);
            }
          }
          if ((lastPos.current.x !== pointerPos.xSnapped || lastPos.current.y !== pointerPos.ySnapped) && dragItems.current && dragStarted.current) {
            dragEvent.current = event.sourceEvent;
            mousePosition.current = getEventPosition(event.sourceEvent, containerBounds.current);
            updateNodes(pointerPos);
          }
        }).on("end", (event) => {
          if (!dragStarted.current || abortDrag.current) {
            return;
          }
          setDragging(false);
          autoPanStarted.current = false;
          dragStarted.current = false;
          cancelAnimationFrame(autoPanId.current);
          if (dragItems.current) {
            const { updateNodePositions, nodeInternals, onNodeDragStop, onSelectionDragStop } = store.getState();
            const onStop = nodeId ? onNodeDragStop : wrapSelectionDragFunc(onSelectionDragStop);
            updateNodePositions(dragItems.current, false, false);
            if (onStop) {
              const [currentNode, nodes] = getEventHandlerParams({
                nodeId,
                dragItems: dragItems.current,
                nodeInternals
              });
              onStop(event.sourceEvent, currentNode, nodes);
            }
          }
        }).filter((event) => {
          const target = event.target;
          const isDraggable = !event.button && (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, nodeRef)) && (!handleSelector || hasSelector(target, handleSelector, nodeRef));
          return isDraggable;
        });
        selection.call(dragHandler);
        return () => {
          selection.on(".drag", null);
        };
      }
    }
  }, [
    nodeRef,
    disabled,
    noDragClassName,
    handleSelector,
    isSelectable,
    store,
    nodeId,
    selectNodesOnDrag,
    getPointerPosition
  ]);
  return dragging;
}
function useUpdateNodePositions() {
  const store = useStoreApi();
  const updatePositions = useCallback$n((params) => {
    const { nodeInternals, nodeExtent, updateNodePositions, getNodes, snapToGrid, snapGrid, onError, nodesDraggable } = store.getState();
    const selectedNodes = getNodes().filter((n) => n.selected && (n.draggable || nodesDraggable && typeof n.draggable === "undefined"));
    const xVelo = snapToGrid ? snapGrid[0] : 5;
    const yVelo = snapToGrid ? snapGrid[1] : 5;
    const factor = params.isShiftPressed ? 4 : 1;
    const positionDiffX = params.x * xVelo * factor;
    const positionDiffY = params.y * yVelo * factor;
    const nodeUpdates = selectedNodes.map((n) => {
      if (n.positionAbsolute) {
        const nextPosition = { x: n.positionAbsolute.x + positionDiffX, y: n.positionAbsolute.y + positionDiffY };
        if (snapToGrid) {
          nextPosition.x = snapGrid[0] * Math.round(nextPosition.x / snapGrid[0]);
          nextPosition.y = snapGrid[1] * Math.round(nextPosition.y / snapGrid[1]);
        }
        const { positionAbsolute, position } = calcNextPosition(n, nextPosition, nodeInternals, nodeExtent, void 0, onError);
        n.position = position;
        n.positionAbsolute = positionAbsolute;
      }
      return n;
    });
    updateNodePositions(nodeUpdates, true, false);
  }, []);
  return updatePositions;
}
const arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};
var wrapNode = (NodeComponent) => {
  const NodeWrapper = ({ id, type, data, xPos, yPos, xPosOrigin, yPosOrigin, selected, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, style: style2, className, isDraggable, isSelectable, isConnectable, isFocusable, selectNodesOnDrag, sourcePosition, targetPosition, hidden, resizeObserver, dragHandle, zIndex, isParent, noDragClassName, noPanClassName, initialized, disableKeyboardA11y, ariaLabel, rfId, hasHandleBounds }) => {
    const store = useStoreApi();
    const nodeRef = useRef$m(null);
    const prevNodeRef = useRef$m(null);
    const prevSourcePosition = useRef$m(sourcePosition);
    const prevTargetPosition = useRef$m(targetPosition);
    const prevType = useRef$m(type);
    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;
    const updatePositions = useUpdateNodePositions();
    const onMouseEnterHandler = getMouseHandler(id, store.getState, onMouseEnter);
    const onMouseMoveHandler = getMouseHandler(id, store.getState, onMouseMove);
    const onMouseLeaveHandler = getMouseHandler(id, store.getState, onMouseLeave);
    const onContextMenuHandler = getMouseHandler(id, store.getState, onContextMenu);
    const onDoubleClickHandler = getMouseHandler(id, store.getState, onDoubleClick);
    const onSelectNodeHandler = (event) => {
      const { nodeDragThreshold } = store.getState();
      if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {
        handleNodeClick({
          id,
          store,
          nodeRef
        });
      }
      if (onClick) {
        const node = store.getState().nodeInternals.get(id);
        if (node) {
          onClick(event, { ...node });
        }
      }
    };
    const onKeyDown = (event) => {
      if (isInputDOMNode(event)) {
        return;
      }
      if (disableKeyboardA11y) {
        return;
      }
      if (elementSelectionKeys.includes(event.key) && isSelectable) {
        const unselect = event.key === "Escape";
        handleNodeClick({
          id,
          store,
          unselect,
          nodeRef
        });
      } else if (isDraggable && selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
        store.setState({
          ariaLiveMessage: `Moved selected node ${event.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~xPos}, y: ${~~yPos}`
        });
        updatePositions({
          x: arrowKeyDiffs[event.key].x,
          y: arrowKeyDiffs[event.key].y,
          isShiftPressed: event.shiftKey
        });
      }
    };
    useEffect$q(() => {
      return () => {
        if (prevNodeRef.current) {
          resizeObserver?.unobserve(prevNodeRef.current);
          prevNodeRef.current = null;
        }
      };
    }, []);
    useEffect$q(() => {
      if (nodeRef.current && !hidden) {
        const currNode = nodeRef.current;
        if (!initialized || !hasHandleBounds || prevNodeRef.current !== currNode) {
          if (prevNodeRef.current) {
            resizeObserver?.unobserve(prevNodeRef.current);
          }
          resizeObserver?.observe(currNode);
          prevNodeRef.current = currNode;
        }
      }
    }, [hidden, initialized, hasHandleBounds]);
    useEffect$q(() => {
      const typeChanged = prevType.current !== type;
      const sourcePosChanged = prevSourcePosition.current !== sourcePosition;
      const targetPosChanged = prevTargetPosition.current !== targetPosition;
      if (nodeRef.current && (typeChanged || sourcePosChanged || targetPosChanged)) {
        if (typeChanged) {
          prevType.current = type;
        }
        if (sourcePosChanged) {
          prevSourcePosition.current = sourcePosition;
        }
        if (targetPosChanged) {
          prevTargetPosition.current = targetPosition;
        }
        store.getState().updateNodeDimensions([{ id, nodeElement: nodeRef.current, forceUpdate: true }]);
      }
    }, [id, type, sourcePosition, targetPosition]);
    const dragging = useDrag({
      nodeRef,
      disabled: hidden || !isDraggable,
      noDragClassName,
      handleSelector: dragHandle,
      nodeId: id,
      isSelectable,
      selectNodesOnDrag
    });
    if (hidden) {
      return null;
    }
    return React$A.createElement(
      "div",
      { className: cc([
        "react-flow__node",
        `react-flow__node-${type}`,
        {
          // this is overwritable by passing `nopan` as a class name
          [noPanClassName]: isDraggable
        },
        className,
        {
          selected,
          selectable: isSelectable,
          parent: isParent,
          dragging
        }
      ]), ref: nodeRef, style: {
        zIndex,
        transform: `translate(${xPosOrigin}px,${yPosOrigin}px)`,
        pointerEvents: hasPointerEvents ? "all" : "none",
        visibility: initialized ? "visible" : "hidden",
        ...style2
      }, "data-id": id, "data-testid": `rf__node-${id}`, onMouseEnter: onMouseEnterHandler, onMouseMove: onMouseMoveHandler, onMouseLeave: onMouseLeaveHandler, onContextMenu: onContextMenuHandler, onClick: onSelectNodeHandler, onDoubleClick: onDoubleClickHandler, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: isFocusable ? "button" : void 0, "aria-describedby": disableKeyboardA11y ? void 0 : `${ARIA_NODE_DESC_KEY}-${rfId}`, "aria-label": ariaLabel },
      React$A.createElement(
        Provider,
        { value: id },
        React$A.createElement(NodeComponent, { id, data, type, xPos, yPos, selected, isConnectable, sourcePosition, targetPosition, dragging, dragHandle, zIndex })
      )
    );
  };
  NodeWrapper.displayName = "NodeWrapper";
  return memo$o(NodeWrapper);
};
const selector$7 = (s) => {
  const selectedNodes = s.getNodes().filter((n) => n.selected);
  return {
    ...getNodesBounds(selectedNodes, s.nodeOrigin),
    transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`,
    userSelectionActive: s.userSelectionActive
  };
};
function NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {
  const store = useStoreApi();
  const { width, height, x: left, y: top, transformString, userSelectionActive } = useStore(selector$7, shallow$1);
  const updatePositions = useUpdateNodePositions();
  const nodeRef = useRef$m(null);
  useEffect$q(() => {
    if (!disableKeyboardA11y) {
      nodeRef.current?.focus({
        preventScroll: true
      });
    }
  }, [disableKeyboardA11y]);
  useDrag({
    nodeRef
  });
  if (userSelectionActive || !width || !height) {
    return null;
  }
  const onContextMenu = onSelectionContextMenu ? (event) => {
    const selectedNodes = store.getState().getNodes().filter((n) => n.selected);
    onSelectionContextMenu(event, selectedNodes);
  } : void 0;
  const onKeyDown = (event) => {
    if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {
      updatePositions({
        x: arrowKeyDiffs[event.key].x,
        y: arrowKeyDiffs[event.key].y,
        isShiftPressed: event.shiftKey
      });
    }
  };
  return React$A.createElement(
    "div",
    { className: cc(["react-flow__nodesselection", "react-flow__container", noPanClassName]), style: {
      transform: transformString
    } },
    React$A.createElement("div", { ref: nodeRef, className: "react-flow__nodesselection-rect", onContextMenu, tabIndex: disableKeyboardA11y ? void 0 : -1, onKeyDown: disableKeyboardA11y ? void 0 : onKeyDown, style: {
      width,
      height,
      top,
      left
    } })
  );
}
var NodesSelection$1 = memo$o(NodesSelection);
const selector$6 = (s) => s.nodesSelectionActive;
const FlowRenderer = ({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, deleteKeyCode, onMove, onMoveStart, onMoveEnd, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y }) => {
  const nodesSelectionActive = useStore(selector$6);
  const selectionKeyPressed = useKeyPress(selectionKeyCode);
  const panActivationKeyPressed = useKeyPress(panActivationKeyCode);
  const panOnDrag = panActivationKeyPressed || _panOnDrag;
  const panOnScroll = panActivationKeyPressed || _panOnScroll;
  const isSelecting = selectionKeyPressed || selectionOnDrag && panOnDrag !== true;
  useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode });
  return React$A.createElement(
    ZoomPane,
    { onMove, onMoveStart, onMoveEnd, onPaneContextMenu, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: !selectionKeyPressed && panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling, noWheelClassName, noPanClassName },
    React$A.createElement(
      Pane,
      { onSelectionStart, onSelectionEnd, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, panOnDrag, isSelecting: !!isSelecting, selectionMode },
      children,
      nodesSelectionActive && React$A.createElement(NodesSelection$1, { onSelectionContextMenu, noPanClassName, disableKeyboardA11y })
    )
  );
};
FlowRenderer.displayName = "FlowRenderer";
var FlowRenderer$1 = memo$o(FlowRenderer);
function useVisibleNodes(onlyRenderVisible) {
  const nodes = useStore(useCallback$n((s) => onlyRenderVisible ? getNodesInside(s.nodeInternals, { x: 0, y: 0, width: s.width, height: s.height }, s.transform, true) : s.getNodes(), [onlyRenderVisible]));
  return nodes;
}
function createNodeTypes(nodeTypes) {
  const standardTypes = {
    input: wrapNode(nodeTypes.input || InputNode$1),
    default: wrapNode(nodeTypes.default || DefaultNode$1),
    output: wrapNode(nodeTypes.output || OutputNode$1),
    group: wrapNode(nodeTypes.group || GroupNode)
  };
  const wrappedTypes = {};
  const specialTypes = Object.keys(nodeTypes).filter((k) => !["input", "default", "output", "group"].includes(k)).reduce((res, key) => {
    res[key] = wrapNode(nodeTypes[key] || DefaultNode$1);
    return res;
  }, wrappedTypes);
  return {
    ...standardTypes,
    ...specialTypes
  };
}
const getPositionWithOrigin = ({ x, y, width, height, origin }) => {
  if (!width || !height) {
    return { x, y };
  }
  if (origin[0] < 0 || origin[1] < 0 || origin[0] > 1 || origin[1] > 1) {
    return { x, y };
  }
  return {
    x: x - width * origin[0],
    y: y - height * origin[1]
  };
};
const selector$5 = (s) => ({
  nodesDraggable: s.nodesDraggable,
  nodesConnectable: s.nodesConnectable,
  nodesFocusable: s.nodesFocusable,
  elementsSelectable: s.elementsSelectable,
  updateNodeDimensions: s.updateNodeDimensions,
  onError: s.onError
});
const NodeRenderer = (props) => {
  const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, updateNodeDimensions, onError } = useStore(selector$5, shallow$1);
  const nodes = useVisibleNodes(props.onlyRenderVisibleElements);
  const resizeObserverRef = useRef$m();
  const resizeObserver = useMemo$2(() => {
    if (typeof ResizeObserver === "undefined") {
      return null;
    }
    const observer = new ResizeObserver((entries) => {
      const updates = entries.map((entry) => ({
        id: entry.target.getAttribute("data-id"),
        nodeElement: entry.target,
        forceUpdate: true
      }));
      updateNodeDimensions(updates);
    });
    resizeObserverRef.current = observer;
    return observer;
  }, []);
  useEffect$q(() => {
    return () => {
      resizeObserverRef?.current?.disconnect();
    };
  }, []);
  return React$A.createElement("div", { className: "react-flow__nodes", style: containerStyle }, nodes.map((node) => {
    let nodeType = node.type || "default";
    if (!props.nodeTypes[nodeType]) {
      onError?.("003", errorMessages["error003"](nodeType));
      nodeType = "default";
    }
    const NodeComponent = props.nodeTypes[nodeType] || props.nodeTypes.default;
    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === "undefined");
    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === "undefined");
    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === "undefined");
    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === "undefined");
    const clampedPosition = props.nodeExtent ? clampPosition(node.positionAbsolute, props.nodeExtent) : node.positionAbsolute;
    const posX = clampedPosition?.x ?? 0;
    const posY = clampedPosition?.y ?? 0;
    const posOrigin = getPositionWithOrigin({
      x: posX,
      y: posY,
      width: node.width ?? 0,
      height: node.height ?? 0,
      origin: props.nodeOrigin
    });
    return React$A.createElement(NodeComponent, { key: node.id, id: node.id, className: node.className, style: node.style, type: nodeType, data: node.data, sourcePosition: node.sourcePosition || Position.Bottom, targetPosition: node.targetPosition || Position.Top, hidden: node.hidden, xPos: posX, yPos: posY, xPosOrigin: posOrigin.x, yPosOrigin: posOrigin.y, selectNodesOnDrag: props.selectNodesOnDrag, onClick: props.onNodeClick, onMouseEnter: props.onNodeMouseEnter, onMouseMove: props.onNodeMouseMove, onMouseLeave: props.onNodeMouseLeave, onContextMenu: props.onNodeContextMenu, onDoubleClick: props.onNodeDoubleClick, selected: !!node.selected, isDraggable, isSelectable, isConnectable, isFocusable, resizeObserver, dragHandle: node.dragHandle, zIndex: node[internalsSymbol]?.z ?? 0, isParent: !!node[internalsSymbol]?.isParent, noDragClassName: props.noDragClassName, noPanClassName: props.noPanClassName, initialized: !!node.width && !!node.height, rfId: props.rfId, disableKeyboardA11y: props.disableKeyboardA11y, ariaLabel: node.ariaLabel, hasHandleBounds: !!node[internalsSymbol]?.handleBounds });
  }));
};
NodeRenderer.displayName = "NodeRenderer";
var NodeRenderer$1 = memo$o(NodeRenderer);
const shiftX = (x, shift, position) => {
  if (position === Position.Left)
    return x - shift;
  if (position === Position.Right)
    return x + shift;
  return x;
};
const shiftY = (y, shift, position) => {
  if (position === Position.Top)
    return y - shift;
  if (position === Position.Bottom)
    return y + shift;
  return y;
};
const EdgeUpdaterClassName = "react-flow__edgeupdater";
const EdgeAnchor = ({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) => React$A.createElement("circle", { onMouseDown, onMouseEnter, onMouseOut, className: cc([EdgeUpdaterClassName, `${EdgeUpdaterClassName}-${type}`]), cx: shiftX(centerX, radius, position), cy: shiftY(centerY, radius, position), r: radius, stroke: "transparent", fill: "transparent" });
const alwaysValidConnection = () => true;
var wrapEdge = (EdgeComponent) => {
  const EdgeWrapper = ({ id, className, type, data, onClick, onEdgeDoubleClick, selected, animated, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style: style2, source, target, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, elementsSelectable, hidden, sourceHandleId, targetHandleId, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, markerEnd, markerStart, rfId, ariaLabel, isFocusable, isReconnectable, pathOptions, interactionWidth, disableKeyboardA11y }) => {
    const edgeRef = useRef$m(null);
    const [updateHover, setUpdateHover] = useState$w(false);
    const [updating, setUpdating] = useState$w(false);
    const store = useStoreApi();
    const markerStartUrl = useMemo$2(() => `url('#${getMarkerId(markerStart, rfId)}')`, [markerStart, rfId]);
    const markerEndUrl = useMemo$2(() => `url('#${getMarkerId(markerEnd, rfId)}')`, [markerEnd, rfId]);
    if (hidden) {
      return null;
    }
    const onEdgeClick = (event) => {
      const { edges, addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();
      const edge = edges.find((e) => e.id === id);
      if (!edge) {
        return;
      }
      if (elementsSelectable) {
        store.setState({ nodesSelectionActive: false });
        if (edge.selected && multiSelectionActive) {
          unselectNodesAndEdges({ nodes: [], edges: [edge] });
          edgeRef.current?.blur();
        } else {
          addSelectedEdges([id]);
        }
      }
      if (onClick) {
        onClick(event, edge);
      }
    };
    const onEdgeDoubleClickHandler = getMouseHandler$1(id, store.getState, onEdgeDoubleClick);
    const onEdgeContextMenu = getMouseHandler$1(id, store.getState, onContextMenu);
    const onEdgeMouseEnter = getMouseHandler$1(id, store.getState, onMouseEnter);
    const onEdgeMouseMove = getMouseHandler$1(id, store.getState, onMouseMove);
    const onEdgeMouseLeave = getMouseHandler$1(id, store.getState, onMouseLeave);
    const handleEdgeUpdater = (event, isSourceHandle) => {
      if (event.button !== 0) {
        return;
      }
      const { edges, isValidConnection: isValidConnectionStore } = store.getState();
      const nodeId = isSourceHandle ? target : source;
      const handleId = (isSourceHandle ? targetHandleId : sourceHandleId) || null;
      const handleType = isSourceHandle ? "target" : "source";
      const isValidConnection = isValidConnectionStore || alwaysValidConnection;
      const isTarget = isSourceHandle;
      const edge = edges.find((e) => e.id === id);
      setUpdating(true);
      onReconnectStart?.(event, edge, handleType);
      const _onReconnectEnd = (evt) => {
        setUpdating(false);
        onReconnectEnd?.(evt, edge, handleType);
      };
      const onConnectEdge = (connection) => onReconnect?.(edge, connection);
      handlePointerDown({
        event,
        handleId,
        nodeId,
        onConnect: onConnectEdge,
        isTarget,
        getState: store.getState,
        setState: store.setState,
        isValidConnection,
        edgeUpdaterType: handleType,
        onReconnectEnd: _onReconnectEnd
      });
    };
    const onEdgeUpdaterSourceMouseDown = (event) => handleEdgeUpdater(event, true);
    const onEdgeUpdaterTargetMouseDown = (event) => handleEdgeUpdater(event, false);
    const onEdgeUpdaterMouseEnter = () => setUpdateHover(true);
    const onEdgeUpdaterMouseOut = () => setUpdateHover(false);
    const inactive = !elementsSelectable && !onClick;
    const onKeyDown = (event) => {
      if (!disableKeyboardA11y && elementSelectionKeys.includes(event.key) && elementsSelectable) {
        const { unselectNodesAndEdges, addSelectedEdges, edges } = store.getState();
        const unselect = event.key === "Escape";
        if (unselect) {
          edgeRef.current?.blur();
          unselectNodesAndEdges({ edges: [edges.find((e) => e.id === id)] });
        } else {
          addSelectedEdges([id]);
        }
      }
    };
    return React$A.createElement(
      "g",
      { className: cc([
        "react-flow__edge",
        `react-flow__edge-${type}`,
        className,
        { selected, animated, inactive, updating: updateHover }
      ]), onClick: onEdgeClick, onDoubleClick: onEdgeDoubleClickHandler, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onKeyDown: isFocusable ? onKeyDown : void 0, tabIndex: isFocusable ? 0 : void 0, role: isFocusable ? "button" : "img", "data-testid": `rf__edge-${id}`, "aria-label": ariaLabel === null ? void 0 : ariaLabel ? ariaLabel : `Edge from ${source} to ${target}`, "aria-describedby": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : void 0, ref: edgeRef },
      !updating && React$A.createElement(EdgeComponent, { id, source, target, selected, animated, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, data, style: style2, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, sourceHandleId, targetHandleId, markerStart: markerStartUrl, markerEnd: markerEndUrl, pathOptions, interactionWidth }),
      isReconnectable && React$A.createElement(
        React$A.Fragment,
        null,
        (isReconnectable === "source" || isReconnectable === true) && React$A.createElement(EdgeAnchor, { position: sourcePosition, centerX: sourceX, centerY: sourceY, radius: reconnectRadius, onMouseDown: onEdgeUpdaterSourceMouseDown, onMouseEnter: onEdgeUpdaterMouseEnter, onMouseOut: onEdgeUpdaterMouseOut, type: "source" }),
        (isReconnectable === "target" || isReconnectable === true) && React$A.createElement(EdgeAnchor, { position: targetPosition, centerX: targetX, centerY: targetY, radius: reconnectRadius, onMouseDown: onEdgeUpdaterTargetMouseDown, onMouseEnter: onEdgeUpdaterMouseEnter, onMouseOut: onEdgeUpdaterMouseOut, type: "target" })
      )
    );
  };
  EdgeWrapper.displayName = "EdgeWrapper";
  return memo$o(EdgeWrapper);
};
function createEdgeTypes(edgeTypes) {
  const standardTypes = {
    default: wrapEdge(edgeTypes.default || BezierEdge),
    straight: wrapEdge(edgeTypes.bezier || StraightEdge),
    step: wrapEdge(edgeTypes.step || StepEdge),
    smoothstep: wrapEdge(edgeTypes.step || SmoothStepEdge),
    simplebezier: wrapEdge(edgeTypes.simplebezier || SimpleBezierEdge)
  };
  const wrappedTypes = {};
  const specialTypes = Object.keys(edgeTypes).filter((k) => !["default", "bezier"].includes(k)).reduce((res, key) => {
    res[key] = wrapEdge(edgeTypes[key] || BezierEdge);
    return res;
  }, wrappedTypes);
  return {
    ...standardTypes,
    ...specialTypes
  };
}
function getHandlePosition(position, nodeRect, handle = null) {
  const x = (handle?.x || 0) + nodeRect.x;
  const y = (handle?.y || 0) + nodeRect.y;
  const width = handle?.width || nodeRect.width;
  const height = handle?.height || nodeRect.height;
  switch (position) {
    case Position.Top:
      return {
        x: x + width / 2,
        y
      };
    case Position.Right:
      return {
        x: x + width,
        y: y + height / 2
      };
    case Position.Bottom:
      return {
        x: x + width / 2,
        y: y + height
      };
    case Position.Left:
      return {
        x,
        y: y + height / 2
      };
  }
}
function getHandle(bounds, handleId) {
  if (!bounds) {
    return null;
  }
  if (bounds.length === 1 || !handleId) {
    return bounds[0];
  } else if (handleId) {
    return bounds.find((d) => d.id === handleId) || null;
  }
  return null;
}
const getEdgePositions = (sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition) => {
  const sourceHandlePos = getHandlePosition(sourcePosition, sourceNodeRect, sourceHandle);
  const targetHandlePos = getHandlePosition(targetPosition, targetNodeRect, targetHandle);
  return {
    sourceX: sourceHandlePos.x,
    sourceY: sourceHandlePos.y,
    targetX: targetHandlePos.x,
    targetY: targetHandlePos.y
  };
};
function isEdgeVisible({ sourcePos, targetPos, sourceWidth, sourceHeight, targetWidth, targetHeight, width, height, transform }) {
  const edgeBox = {
    x: Math.min(sourcePos.x, targetPos.x),
    y: Math.min(sourcePos.y, targetPos.y),
    x2: Math.max(sourcePos.x + sourceWidth, targetPos.x + targetWidth),
    y2: Math.max(sourcePos.y + sourceHeight, targetPos.y + targetHeight)
  };
  if (edgeBox.x === edgeBox.x2) {
    edgeBox.x2 += 1;
  }
  if (edgeBox.y === edgeBox.y2) {
    edgeBox.y2 += 1;
  }
  const viewBox = rectToBox({
    x: (0 - transform[0]) / transform[2],
    y: (0 - transform[1]) / transform[2],
    width: width / transform[2],
    height: height / transform[2]
  });
  const xOverlap = Math.max(0, Math.min(viewBox.x2, edgeBox.x2) - Math.max(viewBox.x, edgeBox.x));
  const yOverlap = Math.max(0, Math.min(viewBox.y2, edgeBox.y2) - Math.max(viewBox.y, edgeBox.y));
  const overlappingArea = Math.ceil(xOverlap * yOverlap);
  return overlappingArea > 0;
}
function getNodeData(node) {
  const handleBounds = node?.[internalsSymbol]?.handleBounds || null;
  const isValid = handleBounds && node?.width && node?.height && typeof node?.positionAbsolute?.x !== "undefined" && typeof node?.positionAbsolute?.y !== "undefined";
  return [
    {
      x: node?.positionAbsolute?.x || 0,
      y: node?.positionAbsolute?.y || 0,
      width: node?.width || 0,
      height: node?.height || 0
    },
    handleBounds,
    !!isValid
  ];
}
const defaultEdgeTree = [{ level: 0, isMaxLevel: true, edges: [] }];
function groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect = false) {
  let maxLevel = -1;
  const levelLookup = edges.reduce((tree, edge) => {
    const hasZIndex = isNumeric(edge.zIndex);
    let z = hasZIndex ? edge.zIndex : 0;
    if (elevateEdgesOnSelect) {
      const targetNode = nodeInternals.get(edge.target);
      const sourceNode = nodeInternals.get(edge.source);
      const edgeOrConnectedNodeSelected = edge.selected || targetNode?.selected || sourceNode?.selected;
      const selectedZIndex = Math.max(sourceNode?.[internalsSymbol]?.z || 0, targetNode?.[internalsSymbol]?.z || 0, 1e3);
      z = (hasZIndex ? edge.zIndex : 0) + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);
    }
    if (tree[z]) {
      tree[z].push(edge);
    } else {
      tree[z] = [edge];
    }
    maxLevel = z > maxLevel ? z : maxLevel;
    return tree;
  }, {});
  const edgeTree = Object.entries(levelLookup).map(([key, edges2]) => {
    const level = +key;
    return {
      edges: edges2,
      level,
      isMaxLevel: level === maxLevel
    };
  });
  if (edgeTree.length === 0) {
    return defaultEdgeTree;
  }
  return edgeTree;
}
function useVisibleEdges(onlyRenderVisible, nodeInternals, elevateEdgesOnSelect) {
  const edges = useStore(useCallback$n((s) => {
    if (!onlyRenderVisible) {
      return s.edges;
    }
    return s.edges.filter((e) => {
      const sourceNode = nodeInternals.get(e.source);
      const targetNode = nodeInternals.get(e.target);
      return sourceNode?.width && sourceNode?.height && targetNode?.width && targetNode?.height && isEdgeVisible({
        sourcePos: sourceNode.positionAbsolute || { x: 0, y: 0 },
        targetPos: targetNode.positionAbsolute || { x: 0, y: 0 },
        sourceWidth: sourceNode.width,
        sourceHeight: sourceNode.height,
        targetWidth: targetNode.width,
        targetHeight: targetNode.height,
        width: s.width,
        height: s.height,
        transform: s.transform
      });
    });
  }, [onlyRenderVisible, nodeInternals]));
  return groupEdgesByZLevel(edges, nodeInternals, elevateEdgesOnSelect);
}
const ArrowSymbol = ({ color = "none", strokeWidth = 1 }) => {
  return React$A.createElement("polyline", { style: {
    stroke: color,
    strokeWidth
  }, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" });
};
const ArrowClosedSymbol = ({ color = "none", strokeWidth = 1 }) => {
  return React$A.createElement("polyline", { style: {
    stroke: color,
    fill: color,
    strokeWidth
  }, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" });
};
const MarkerSymbols = {
  [MarkerType.Arrow]: ArrowSymbol,
  [MarkerType.ArrowClosed]: ArrowClosedSymbol
};
function useMarkerSymbol(type) {
  const store = useStoreApi();
  const symbol = useMemo$2(() => {
    const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);
    if (!symbolExists) {
      store.getState().onError?.("009", errorMessages["error009"](type));
      return null;
    }
    return MarkerSymbols[type];
  }, [type]);
  return symbol;
}
const Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = "strokeWidth", strokeWidth, orient = "auto-start-reverse" }) => {
  const Symbol2 = useMarkerSymbol(type);
  if (!Symbol2) {
    return null;
  }
  return React$A.createElement(
    "marker",
    { className: "react-flow__arrowhead", id, markerWidth: `${width}`, markerHeight: `${height}`, viewBox: "-10 -10 20 20", markerUnits, orient, refX: "0", refY: "0" },
    React$A.createElement(Symbol2, { color, strokeWidth })
  );
};
const markerSelector = ({ defaultColor, rfId }) => (s) => {
  const ids = [];
  return s.edges.reduce((markers, edge) => {
    [edge.markerStart, edge.markerEnd].forEach((marker) => {
      if (marker && typeof marker === "object") {
        const markerId = getMarkerId(marker, rfId);
        if (!ids.includes(markerId)) {
          markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });
          ids.push(markerId);
        }
      }
    });
    return markers;
  }, []).sort((a, b) => a.id.localeCompare(b.id));
};
const MarkerDefinitions = ({ defaultColor, rfId }) => {
  const markers = useStore(
    useCallback$n(markerSelector({ defaultColor, rfId }), [defaultColor, rfId]),
    // the id includes all marker options, so we just need to look at that part of the marker
    (a, b) => !(a.length !== b.length || a.some((m, i) => m.id !== b[i].id))
  );
  return React$A.createElement("defs", null, markers.map((marker) => React$A.createElement(Marker, { id: marker.id, key: marker.id, type: marker.type, color: marker.color, width: marker.width, height: marker.height, markerUnits: marker.markerUnits, strokeWidth: marker.strokeWidth, orient: marker.orient })));
};
MarkerDefinitions.displayName = "MarkerDefinitions";
var MarkerDefinitions$1 = memo$o(MarkerDefinitions);
const selector$4 = (s) => ({
  nodesConnectable: s.nodesConnectable,
  edgesFocusable: s.edgesFocusable,
  edgesUpdatable: s.edgesUpdatable,
  elementsSelectable: s.elementsSelectable,
  width: s.width,
  height: s.height,
  connectionMode: s.connectionMode,
  nodeInternals: s.nodeInternals,
  onError: s.onError
});
const EdgeRenderer = ({ defaultMarkerColor, onlyRenderVisibleElements, elevateEdgesOnSelect, rfId, edgeTypes, noPanClassName, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, onEdgeDoubleClick, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, children, disableKeyboardA11y }) => {
  const { edgesFocusable, edgesUpdatable, elementsSelectable, width, height, connectionMode, nodeInternals, onError } = useStore(selector$4, shallow$1);
  const edgeTree = useVisibleEdges(onlyRenderVisibleElements, nodeInternals, elevateEdgesOnSelect);
  if (!width) {
    return null;
  }
  return React$A.createElement(
    React$A.Fragment,
    null,
    edgeTree.map(({ level, edges, isMaxLevel }) => React$A.createElement(
      "svg",
      { key: level, style: { zIndex: level }, width, height, className: "react-flow__edges react-flow__container" },
      isMaxLevel && React$A.createElement(MarkerDefinitions$1, { defaultColor: defaultMarkerColor, rfId }),
      React$A.createElement("g", null, edges.map((edge) => {
        const [sourceNodeRect, sourceHandleBounds, sourceIsValid] = getNodeData(nodeInternals.get(edge.source));
        const [targetNodeRect, targetHandleBounds, targetIsValid] = getNodeData(nodeInternals.get(edge.target));
        if (!sourceIsValid || !targetIsValid) {
          return null;
        }
        let edgeType = edge.type || "default";
        if (!edgeTypes[edgeType]) {
          onError?.("011", errorMessages["error011"](edgeType));
          edgeType = "default";
        }
        const EdgeComponent = edgeTypes[edgeType] || edgeTypes.default;
        const targetNodeHandles = connectionMode === ConnectionMode.Strict ? targetHandleBounds.target : (targetHandleBounds.target ?? []).concat(targetHandleBounds.source ?? []);
        const sourceHandle = getHandle(sourceHandleBounds.source, edge.sourceHandle);
        const targetHandle = getHandle(targetNodeHandles, edge.targetHandle);
        const sourcePosition = sourceHandle?.position || Position.Bottom;
        const targetPosition = targetHandle?.position || Position.Top;
        const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === "undefined");
        const edgeReconnectable = edge.reconnectable || edge.updatable;
        const isReconnectable = typeof onReconnect !== "undefined" && (edgeReconnectable || edgesUpdatable && typeof edgeReconnectable === "undefined");
        if (!sourceHandle || !targetHandle) {
          onError?.("008", errorMessages["error008"](sourceHandle, edge));
          return null;
        }
        const { sourceX, sourceY, targetX, targetY } = getEdgePositions(sourceNodeRect, sourceHandle, sourcePosition, targetNodeRect, targetHandle, targetPosition);
        return React$A.createElement(EdgeComponent, { key: edge.id, id: edge.id, className: cc([edge.className, noPanClassName]), type: edgeType, data: edge.data, selected: !!edge.selected, animated: !!edge.animated, hidden: !!edge.hidden, label: edge.label, labelStyle: edge.labelStyle, labelShowBg: edge.labelShowBg, labelBgStyle: edge.labelBgStyle, labelBgPadding: edge.labelBgPadding, labelBgBorderRadius: edge.labelBgBorderRadius, style: edge.style, source: edge.source, target: edge.target, sourceHandleId: edge.sourceHandle, targetHandleId: edge.targetHandle, markerEnd: edge.markerEnd, markerStart: edge.markerStart, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, elementsSelectable, onContextMenu: onEdgeContextMenu, onMouseEnter: onEdgeMouseEnter, onMouseMove: onEdgeMouseMove, onMouseLeave: onEdgeMouseLeave, onClick: onEdgeClick, onEdgeDoubleClick, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, rfId, ariaLabel: edge.ariaLabel, isFocusable, isReconnectable, pathOptions: "pathOptions" in edge ? edge.pathOptions : void 0, interactionWidth: edge.interactionWidth, disableKeyboardA11y });
      }))
    )),
    children
  );
};
EdgeRenderer.displayName = "EdgeRenderer";
var EdgeRenderer$1 = memo$o(EdgeRenderer);
const selector$3 = (s) => `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;
function Viewport({ children }) {
  const transform = useStore(selector$3);
  return React$A.createElement("div", { className: "react-flow__viewport react-flow__container", style: { transform } }, children);
}
function useOnInitHandler(onInit) {
  const rfInstance = useReactFlow();
  const isInitialized = useRef$m(false);
  useEffect$q(() => {
    if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {
      setTimeout(() => onInit(rfInstance), 1);
      isInitialized.current = true;
    }
  }, [onInit, rfInstance.viewportInitialized]);
}
const oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
const ConnectionLine = ({ nodeId, handleType, style: style2, type = ConnectionLineType.Bezier, CustomComponent, connectionStatus }) => {
  const { fromNode, handleId, toX, toY, connectionMode } = useStore(useCallback$n((s) => ({
    fromNode: s.nodeInternals.get(nodeId),
    handleId: s.connectionHandleId,
    toX: (s.connectionPosition.x - s.transform[0]) / s.transform[2],
    toY: (s.connectionPosition.y - s.transform[1]) / s.transform[2],
    connectionMode: s.connectionMode
  }), [nodeId]), shallow$1);
  const fromHandleBounds = fromNode?.[internalsSymbol]?.handleBounds;
  let handleBounds = fromHandleBounds?.[handleType];
  if (connectionMode === ConnectionMode.Loose) {
    handleBounds = handleBounds ? handleBounds : fromHandleBounds?.[handleType === "source" ? "target" : "source"];
  }
  if (!fromNode || !handleBounds) {
    return null;
  }
  const fromHandle = handleId ? handleBounds.find((d) => d.id === handleId) : handleBounds[0];
  const fromHandleX = fromHandle ? fromHandle.x + fromHandle.width / 2 : (fromNode.width ?? 0) / 2;
  const fromHandleY = fromHandle ? fromHandle.y + fromHandle.height / 2 : fromNode.height ?? 0;
  const fromX = (fromNode.positionAbsolute?.x ?? 0) + fromHandleX;
  const fromY = (fromNode.positionAbsolute?.y ?? 0) + fromHandleY;
  const fromPosition = fromHandle?.position;
  const toPosition = fromPosition ? oppositePosition[fromPosition] : null;
  if (!fromPosition || !toPosition) {
    return null;
  }
  if (CustomComponent) {
    return React$A.createElement(CustomComponent, { connectionLineType: type, connectionLineStyle: style2, fromNode, fromHandle, fromX, fromY, toX, toY, fromPosition, toPosition, connectionStatus });
  }
  let dAttr = "";
  const pathParams = {
    sourceX: fromX,
    sourceY: fromY,
    sourcePosition: fromPosition,
    targetX: toX,
    targetY: toY,
    targetPosition: toPosition
  };
  if (type === ConnectionLineType.Bezier) {
    [dAttr] = getBezierPath(pathParams);
  } else if (type === ConnectionLineType.Step) {
    [dAttr] = getSmoothStepPath({
      ...pathParams,
      borderRadius: 0
    });
  } else if (type === ConnectionLineType.SmoothStep) {
    [dAttr] = getSmoothStepPath(pathParams);
  } else if (type === ConnectionLineType.SimpleBezier) {
    [dAttr] = getSimpleBezierPath(pathParams);
  } else {
    dAttr = `M${fromX},${fromY} ${toX},${toY}`;
  }
  return React$A.createElement("path", { d: dAttr, fill: "none", className: "react-flow__connection-path", style: style2 });
};
ConnectionLine.displayName = "ConnectionLine";
const selector$2$1 = (s) => ({
  nodeId: s.connectionNodeId,
  handleType: s.connectionHandleType,
  nodesConnectable: s.nodesConnectable,
  connectionStatus: s.connectionStatus,
  width: s.width,
  height: s.height
});
function ConnectionLineWrapper({ containerStyle: containerStyle2, style: style2, type, component }) {
  const { nodeId, handleType, nodesConnectable, width, height, connectionStatus } = useStore(selector$2$1, shallow$1);
  const isValid = !!(nodeId && handleType && width && nodesConnectable);
  if (!isValid) {
    return null;
  }
  return React$A.createElement(
    "svg",
    { style: containerStyle2, width, height, className: "react-flow__edges react-flow__connectionline react-flow__container" },
    React$A.createElement(
      "g",
      { className: cc(["react-flow__connection", connectionStatus]) },
      React$A.createElement(ConnectionLine, { nodeId, handleType, style: style2, type, CustomComponent: component, connectionStatus })
    )
  );
}
function useNodeOrEdgeTypes(nodeOrEdgeTypes, createTypes) {
  useRef$m(null);
  useStoreApi();
  const typesParsed = useMemo$2(() => {
    return createTypes(nodeOrEdgeTypes);
  }, [nodeOrEdgeTypes]);
  return typesParsed;
}
const GraphView = ({ nodeTypes, edgeTypes, onMove, onMoveStart, onMoveEnd, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, selectNodesOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, noDragClassName, noWheelClassName, noPanClassName, elevateEdgesOnSelect, disableKeyboardA11y, nodeOrigin, nodeExtent, rfId }) => {
  const nodeTypesWrapped = useNodeOrEdgeTypes(nodeTypes, createNodeTypes);
  const edgeTypesWrapped = useNodeOrEdgeTypes(edgeTypes, createEdgeTypes);
  useOnInitHandler(onInit);
  return React$A.createElement(
    FlowRenderer$1,
    { onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, onMove, onMoveStart, onMoveEnd, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, onSelectionContextMenu, preventScrolling, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y },
    React$A.createElement(
      Viewport,
      null,
      React$A.createElement(
        EdgeRenderer$1,
        { edgeTypes: edgeTypesWrapped, onEdgeClick, onEdgeDoubleClick, onlyRenderVisibleElements, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius, defaultMarkerColor, noPanClassName, elevateEdgesOnSelect: !!elevateEdgesOnSelect, disableKeyboardA11y, rfId },
        React$A.createElement(ConnectionLineWrapper, { style: connectionLineStyle, type: connectionLineType, component: connectionLineComponent, containerStyle: connectionLineContainerStyle })
      ),
      React$A.createElement("div", { className: "react-flow__edgelabel-renderer" }),
      React$A.createElement(NodeRenderer$1, { nodeTypes: nodeTypesWrapped, onNodeClick, onNodeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, selectNodesOnDrag, onlyRenderVisibleElements, noPanClassName, noDragClassName, disableKeyboardA11y, nodeOrigin, nodeExtent, rfId })
    )
  );
};
GraphView.displayName = "GraphView";
var GraphView$1 = memo$o(GraphView);
const infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
];
const initialState = {
  rfId: "1",
  width: 0,
  height: 0,
  transform: [0, 0, 1],
  nodeInternals: /* @__PURE__ */ new Map(),
  edges: [],
  onNodesChange: null,
  onEdgesChange: null,
  hasDefaultNodes: false,
  hasDefaultEdges: false,
  d3Zoom: null,
  d3Selection: null,
  d3ZoomHandler: void 0,
  minZoom: 0.5,
  maxZoom: 2,
  translateExtent: infiniteExtent,
  nodeExtent: infiniteExtent,
  nodesSelectionActive: false,
  userSelectionActive: false,
  userSelectionRect: null,
  connectionNodeId: null,
  connectionHandleId: null,
  connectionHandleType: "source",
  connectionPosition: { x: 0, y: 0 },
  connectionStatus: null,
  connectionMode: ConnectionMode.Strict,
  domNode: null,
  paneDragging: false,
  noPanClassName: "nopan",
  nodeOrigin: [0, 0],
  nodeDragThreshold: 0,
  snapGrid: [15, 15],
  snapToGrid: false,
  nodesDraggable: true,
  nodesConnectable: true,
  nodesFocusable: true,
  edgesFocusable: true,
  edgesUpdatable: true,
  elementsSelectable: true,
  elevateNodesOnSelect: true,
  fitViewOnInit: false,
  fitViewOnInitDone: false,
  fitViewOnInitOptions: void 0,
  onSelectionChange: [],
  multiSelectionActive: false,
  connectionStartHandle: null,
  connectionEndHandle: null,
  connectionClickStartHandle: null,
  connectOnClick: true,
  ariaLiveMessage: "",
  autoPanOnConnect: true,
  autoPanOnNodeDrag: true,
  connectionRadius: 20,
  onError: devWarn,
  isValidConnection: void 0
};
const createRFStore = () => createWithEqualityFn((set, get) => ({
  ...initialState,
  setNodes: (nodes) => {
    const { nodeInternals, nodeOrigin, elevateNodesOnSelect } = get();
    set({ nodeInternals: createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect) });
  },
  getNodes: () => {
    return Array.from(get().nodeInternals.values());
  },
  setEdges: (edges) => {
    const { defaultEdgeOptions = {} } = get();
    set({ edges: edges.map((e) => ({ ...defaultEdgeOptions, ...e })) });
  },
  setDefaultNodesAndEdges: (nodes, edges) => {
    const hasDefaultNodes = typeof nodes !== "undefined";
    const hasDefaultEdges = typeof edges !== "undefined";
    const nodeInternals = hasDefaultNodes ? createNodeInternals(nodes, /* @__PURE__ */ new Map(), get().nodeOrigin, get().elevateNodesOnSelect) : /* @__PURE__ */ new Map();
    const nextEdges = hasDefaultEdges ? edges : [];
    set({ nodeInternals, edges: nextEdges, hasDefaultNodes, hasDefaultEdges });
  },
  updateNodeDimensions: (updates) => {
    const { onNodesChange, nodeInternals, fitViewOnInit, fitViewOnInitDone, fitViewOnInitOptions, domNode, nodeOrigin } = get();
    const viewportNode = domNode?.querySelector(".react-flow__viewport");
    if (!viewportNode) {
      return;
    }
    const style2 = window.getComputedStyle(viewportNode);
    const { m22: zoom2 } = new window.DOMMatrixReadOnly(style2.transform);
    const changes = updates.reduce((res, update) => {
      const node = nodeInternals.get(update.id);
      if (node?.hidden) {
        nodeInternals.set(node.id, {
          ...node,
          [internalsSymbol]: {
            ...node[internalsSymbol],
            // we need to reset the handle bounds when the node is hidden
            // in order to force a new observation when the node is shown again
            handleBounds: void 0
          }
        });
      } else if (node) {
        const dimensions = getDimensions(update.nodeElement);
        const doUpdate = !!(dimensions.width && dimensions.height && (node.width !== dimensions.width || node.height !== dimensions.height || update.forceUpdate));
        if (doUpdate) {
          nodeInternals.set(node.id, {
            ...node,
            [internalsSymbol]: {
              ...node[internalsSymbol],
              handleBounds: {
                source: getHandleBounds(".source", update.nodeElement, zoom2, nodeOrigin),
                target: getHandleBounds(".target", update.nodeElement, zoom2, nodeOrigin)
              }
            },
            ...dimensions
          });
          res.push({
            id: node.id,
            type: "dimensions",
            dimensions
          });
        }
      }
      return res;
    }, []);
    updateAbsoluteNodePositions(nodeInternals, nodeOrigin);
    const nextFitViewOnInitDone = fitViewOnInitDone || fitViewOnInit && !fitViewOnInitDone && fitView(get, { initial: true, ...fitViewOnInitOptions });
    set({ nodeInternals: new Map(nodeInternals), fitViewOnInitDone: nextFitViewOnInitDone });
    if (changes?.length > 0) {
      onNodesChange?.(changes);
    }
  },
  updateNodePositions: (nodeDragItems, positionChanged = true, dragging = false) => {
    const { triggerNodeChanges } = get();
    const changes = nodeDragItems.map((node) => {
      const change = {
        id: node.id,
        type: "position",
        dragging
      };
      if (positionChanged) {
        change.positionAbsolute = node.positionAbsolute;
        change.position = node.position;
      }
      return change;
    });
    triggerNodeChanges(changes);
  },
  triggerNodeChanges: (changes) => {
    const { onNodesChange, nodeInternals, hasDefaultNodes, nodeOrigin, getNodes, elevateNodesOnSelect } = get();
    if (changes?.length) {
      if (hasDefaultNodes) {
        const nodes = applyNodeChanges(changes, getNodes());
        const nextNodeInternals = createNodeInternals(nodes, nodeInternals, nodeOrigin, elevateNodesOnSelect);
        set({ nodeInternals: nextNodeInternals });
      }
      onNodesChange?.(changes);
    }
  },
  addSelectedNodes: (selectedNodeIds) => {
    const { multiSelectionActive, edges, getNodes } = get();
    let changedNodes;
    let changedEdges = null;
    if (multiSelectionActive) {
      changedNodes = selectedNodeIds.map((nodeId) => createSelectionChange(nodeId, true));
    } else {
      changedNodes = getSelectionChanges(getNodes(), selectedNodeIds);
      changedEdges = getSelectionChanges(edges, []);
    }
    updateNodesAndEdgesSelections({
      changedNodes,
      changedEdges,
      get,
      set
    });
  },
  addSelectedEdges: (selectedEdgeIds) => {
    const { multiSelectionActive, edges, getNodes } = get();
    let changedEdges;
    let changedNodes = null;
    if (multiSelectionActive) {
      changedEdges = selectedEdgeIds.map((edgeId) => createSelectionChange(edgeId, true));
    } else {
      changedEdges = getSelectionChanges(edges, selectedEdgeIds);
      changedNodes = getSelectionChanges(getNodes(), []);
    }
    updateNodesAndEdgesSelections({
      changedNodes,
      changedEdges,
      get,
      set
    });
  },
  unselectNodesAndEdges: ({ nodes, edges } = {}) => {
    const { edges: storeEdges, getNodes } = get();
    const nodesToUnselect = nodes ? nodes : getNodes();
    const edgesToUnselect = edges ? edges : storeEdges;
    const changedNodes = nodesToUnselect.map((n) => {
      n.selected = false;
      return createSelectionChange(n.id, false);
    });
    const changedEdges = edgesToUnselect.map((edge) => createSelectionChange(edge.id, false));
    updateNodesAndEdgesSelections({
      changedNodes,
      changedEdges,
      get,
      set
    });
  },
  setMinZoom: (minZoom) => {
    const { d3Zoom, maxZoom } = get();
    d3Zoom?.scaleExtent([minZoom, maxZoom]);
    set({ minZoom });
  },
  setMaxZoom: (maxZoom) => {
    const { d3Zoom, minZoom } = get();
    d3Zoom?.scaleExtent([minZoom, maxZoom]);
    set({ maxZoom });
  },
  setTranslateExtent: (translateExtent) => {
    get().d3Zoom?.translateExtent(translateExtent);
    set({ translateExtent });
  },
  resetSelectedElements: () => {
    const { edges, getNodes } = get();
    const nodes = getNodes();
    const nodesToUnselect = nodes.filter((e) => e.selected).map((n) => createSelectionChange(n.id, false));
    const edgesToUnselect = edges.filter((e) => e.selected).map((e) => createSelectionChange(e.id, false));
    updateNodesAndEdgesSelections({
      changedNodes: nodesToUnselect,
      changedEdges: edgesToUnselect,
      get,
      set
    });
  },
  setNodeExtent: (nodeExtent) => {
    const { nodeInternals } = get();
    nodeInternals.forEach((node) => {
      node.positionAbsolute = clampPosition(node.position, nodeExtent);
    });
    set({
      nodeExtent,
      nodeInternals: new Map(nodeInternals)
    });
  },
  panBy: (delta) => {
    const { transform, width, height, d3Zoom, d3Selection, translateExtent } = get();
    if (!d3Zoom || !d3Selection || !delta.x && !delta.y) {
      return false;
    }
    const nextTransform = identity.translate(transform[0] + delta.x, transform[1] + delta.y).scale(transform[2]);
    const extent = [
      [0, 0],
      [width, height]
    ];
    const constrainedTransform = d3Zoom?.constrain()(nextTransform, extent, translateExtent);
    d3Zoom.transform(d3Selection, constrainedTransform);
    const transformChanged = transform[0] !== constrainedTransform.x || transform[1] !== constrainedTransform.y || transform[2] !== constrainedTransform.k;
    return transformChanged;
  },
  cancelConnection: () => set({
    connectionNodeId: initialState.connectionNodeId,
    connectionHandleId: initialState.connectionHandleId,
    connectionHandleType: initialState.connectionHandleType,
    connectionStatus: initialState.connectionStatus,
    connectionStartHandle: initialState.connectionStartHandle,
    connectionEndHandle: initialState.connectionEndHandle
  }),
  reset: () => set({ ...initialState })
}), Object.is);
const ReactFlowProvider = ({ children }) => {
  const storeRef = useRef$m(null);
  if (!storeRef.current) {
    storeRef.current = createRFStore();
  }
  return React$A.createElement(Provider$1, { value: storeRef.current }, children);
};
ReactFlowProvider.displayName = "ReactFlowProvider";
const Wrapper = ({ children }) => {
  const isWrapped = useContext(StoreContext);
  if (isWrapped) {
    return React$A.createElement(React$A.Fragment, null, children);
  }
  return React$A.createElement(ReactFlowProvider, null, children);
};
Wrapper.displayName = "ReactFlowWrapper";
const defaultNodeTypes = {
  input: InputNode$1,
  default: DefaultNode$1,
  output: OutputNode$1,
  group: GroupNode
};
const defaultEdgeTypes = {
  default: BezierEdge,
  straight: StraightEdge,
  step: StepEdge,
  smoothstep: SmoothStepEdge,
  simplebezier: SimpleBezierEdge
};
const initNodeOrigin = [0, 0];
const initSnapGrid = [15, 15];
const initDefaultViewport = { x: 0, y: 0, zoom: 1 };
const wrapperStyle = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
const ReactFlow = forwardRef$2(({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes = defaultNodeTypes, edgeTypes = defaultEdgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionMode = ConnectionMode.Strict, connectionLineType = ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = "Backspace", selectionKeyCode = "Shift", selectionOnDrag = false, selectionMode = SelectionMode.Full, panActivationKeyCode = "Space", multiSelectionKeyCode = isMacOs() ? "Meta" : "Control", zoomActivationKeyCode = isMacOs() ? "Meta" : "Control", snapToGrid = false, snapGrid = initSnapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag = true, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = initNodeOrigin, edgesFocusable, edgesUpdatable, elementsSelectable, defaultViewport = initDefaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = "#b1b1b7", zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, children, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeUpdate, onEdgeUpdateStart, onEdgeUpdateEnd, onReconnect, onReconnectStart, onReconnectEnd, reconnectRadius = 10, edgeUpdaterRadius = 10, onNodesChange, onEdgesChange, noDragClassName = "nodrag", noWheelClassName = "nowheel", noPanClassName = "nopan", fitView: fitView2 = false, fitViewOptions, connectOnClick = true, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect = true, elevateEdgesOnSelect = false, disableKeyboardA11y = false, autoPanOnConnect = true, autoPanOnNodeDrag = true, connectionRadius = 20, isValidConnection, onError, style: style2, id, nodeDragThreshold, ...rest }, ref) => {
  const rfId = id || "1";
  return React$A.createElement(
    "div",
    { ...rest, style: { ...style2, ...wrapperStyle }, ref, className: cc(["react-flow", className]), "data-testid": "rf__wrapper", id },
    React$A.createElement(
      Wrapper,
      null,
      React$A.createElement(GraphView$1, { onInit, onMove, onMoveStart, onMoveEnd, onNodeClick, onEdgeClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, nodeTypes, edgeTypes, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, deleteKeyCode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, onlyRenderVisibleElements, selectNodesOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, zoomOnScroll, zoomOnPinch, zoomOnDoubleClick, panOnScroll, panOnScrollSpeed, panOnScrollMode, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onReconnect: onReconnect ?? onEdgeUpdate, onReconnectStart: onReconnectStart ?? onEdgeUpdateStart, onReconnectEnd: onReconnectEnd ?? onEdgeUpdateEnd, reconnectRadius: reconnectRadius ?? edgeUpdaterRadius, defaultMarkerColor, noDragClassName, noWheelClassName, noPanClassName, elevateEdgesOnSelect, rfId, disableKeyboardA11y, nodeOrigin, nodeExtent }),
      React$A.createElement(StoreUpdater, { nodes, edges, defaultNodes, defaultEdges, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, nodesDraggable, nodesConnectable, nodesFocusable, edgesFocusable, edgesUpdatable, elementsSelectable, elevateNodesOnSelect, minZoom, maxZoom, nodeExtent, onNodesChange, onEdgesChange, snapToGrid, snapGrid, connectionMode, translateExtent, connectOnClick, defaultEdgeOptions, fitView: fitView2, fitViewOptions, onNodesDelete, onEdgesDelete, onNodeDragStart, onNodeDrag, onNodeDragStop, onSelectionDrag, onSelectionDragStart, onSelectionDragStop, noPanClassName, nodeOrigin, rfId, autoPanOnConnect, autoPanOnNodeDrag, onError, connectionRadius, isValidConnection, nodeDragThreshold }),
      React$A.createElement(Wrapper$1, { onSelectionChange }),
      children,
      React$A.createElement(Attribution, { proOptions, position: attributionPosition }),
      React$A.createElement(A11yDescriptions, { rfId, disableKeyboardA11y })
    )
  );
});
ReactFlow.displayName = "ReactFlow";
const selector$1$2 = (s) => s.domNode?.querySelector(".react-flow__edgelabel-renderer");
function EdgeLabelRenderer({ children }) {
  const edgeLabelRenderer = useStore(selector$1$2);
  if (!edgeLabelRenderer) {
    return null;
  }
  return createPortal(children, edgeLabelRenderer);
}
function useUpdateNodeInternals() {
  const store = useStoreApi();
  return useCallback$n((id) => {
    const { domNode, updateNodeDimensions } = store.getState();
    const updateIds = Array.isArray(id) ? id : [id];
    const updates = updateIds.reduce((res, updateId) => {
      const nodeElement = domNode?.querySelector(`.react-flow__node[data-id="${updateId}"]`);
      if (nodeElement) {
        res.push({ id: updateId, nodeElement, forceUpdate: true });
      }
      return res;
    }, []);
    requestAnimationFrame(() => updateNodeDimensions(updates));
  }, []);
}
const nodesSelector = (state) => state.getNodes();
function useNodes() {
  const nodes = useStore(nodesSelector, shallow$1);
  return nodes;
}
const edgesSelector = (state) => state.edges;
function useEdges() {
  const edges = useStore(edgesSelector, shallow$1);
  return edges;
}
function createUseItemsState(applyChanges2) {
  return (initialItems) => {
    const [items, setItems] = useState$w(initialItems);
    const onItemsChange = useCallback$n((changes) => setItems((items2) => applyChanges2(changes, items2)), []);
    return [items, setItems, onItemsChange];
  };
}
const useNodesState = createUseItemsState(applyNodeChanges);
const useEdgesState = createUseItemsState(applyEdgeChanges);

const React$z = await importShared('react');
const {memo: memo$n,useRef: useRef$l,useEffect: useEffect$p} = React$z;

const MiniMapNode = ({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, onClick, selected, }) => {
    const { background, backgroundColor } = style || {};
    const fill = (color || background || backgroundColor);
    return (React$z.createElement("rect", { className: cc(['react-flow__minimap-node', { selected }, className]), x: x, y: y, rx: borderRadius, ry: borderRadius, width: width, height: height, fill: fill, stroke: strokeColor, strokeWidth: strokeWidth, shapeRendering: shapeRendering, onClick: onClick ? (event) => onClick(event, id) : undefined }));
};
MiniMapNode.displayName = 'MiniMapNode';
var MiniMapNode$1 = memo$n(MiniMapNode);

/* eslint-disable @typescript-eslint/ban-ts-comment */
const selector$1$1 = (s) => s.nodeOrigin;
const selectorNodes = (s) => s.getNodes().filter((node) => !node.hidden && node.width && node.height);
const getAttrFunction = (func) => (func instanceof Function ? func : () => func);
function MiniMapNodes({ nodeStrokeColor = 'transparent', nodeColor = '#e2e2e2', nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth = 2, 
// We need to rename the prop to be `CapitalCase` so that JSX will render it as
// a component properly.
nodeComponent: NodeComponent = MiniMapNode$1, onClick, }) {
    const nodes = useStore(selectorNodes, shallow$1);
    const nodeOrigin = useStore(selector$1$1);
    const nodeColorFunc = getAttrFunction(nodeColor);
    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);
    const nodeClassNameFunc = getAttrFunction(nodeClassName);
    const shapeRendering = typeof window === 'undefined' || !!window.chrome ? 'crispEdges' : 'geometricPrecision';
    return (React$z.createElement(React$z.Fragment, null, nodes.map((node) => {
        const { x, y } = getNodePositionWithOrigin(node, nodeOrigin).positionAbsolute;
        return (React$z.createElement(NodeComponent, { key: node.id, x: x, y: y, width: node.width, height: node.height, style: node.style, selected: node.selected, className: nodeClassNameFunc(node), color: nodeColorFunc(node), borderRadius: nodeBorderRadius, strokeColor: nodeStrokeColorFunc(node), strokeWidth: nodeStrokeWidth, shapeRendering: shapeRendering, onClick: onClick, id: node.id }));
    })));
}
var MiniMapNodes$1 = memo$n(MiniMapNodes);

/* eslint-disable @typescript-eslint/ban-ts-comment */
const defaultWidth = 200;
const defaultHeight = 150;
const selector$2 = (s) => {
    const nodes = s.getNodes();
    const viewBB = {
        x: -s.transform[0] / s.transform[2],
        y: -s.transform[1] / s.transform[2],
        width: s.width / s.transform[2],
        height: s.height / s.transform[2],
    };
    return {
        viewBB,
        boundingRect: nodes.length > 0 ? getBoundsOfRects(getNodesBounds(nodes, s.nodeOrigin), viewBB) : viewBB,
        rfId: s.rfId,
    };
};
const ARIA_LABEL_KEY = 'react-flow__minimap-desc';
function MiniMap({ style, className, nodeStrokeColor = 'transparent', nodeColor = '#e2e2e2', nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth = 2, 
// We need to rename the prop to be `CapitalCase` so that JSX will render it as
// a component properly.
nodeComponent, maskColor = 'rgb(240, 240, 240, 0.6)', maskStrokeColor = 'none', maskStrokeWidth = 1, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel = 'React Flow mini map', inversePan = false, zoomStep = 10, offsetScale = 5, }) {
    const store = useStoreApi();
    const svg = useRef$l(null);
    const { boundingRect, viewBB, rfId } = useStore(selector$2, shallow$1);
    const elementWidth = style?.width ?? defaultWidth;
    const elementHeight = style?.height ?? defaultHeight;
    const scaledWidth = boundingRect.width / elementWidth;
    const scaledHeight = boundingRect.height / elementHeight;
    const viewScale = Math.max(scaledWidth, scaledHeight);
    const viewWidth = viewScale * elementWidth;
    const viewHeight = viewScale * elementHeight;
    const offset = offsetScale * viewScale;
    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;
    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;
    const width = viewWidth + offset * 2;
    const height = viewHeight + offset * 2;
    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;
    const viewScaleRef = useRef$l(0);
    viewScaleRef.current = viewScale;
    useEffect$p(() => {
        if (svg.current) {
            const selection = select(svg.current);
            const zoomHandler = (event) => {
                const { transform, d3Selection, d3Zoom } = store.getState();
                if (event.sourceEvent.type !== 'wheel' || !d3Selection || !d3Zoom) {
                    return;
                }
                const pinchDelta = -event.sourceEvent.deltaY *
                    (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *
                    zoomStep;
                const zoom = transform[2] * Math.pow(2, pinchDelta);
                d3Zoom.scaleTo(d3Selection, zoom);
            };
            const panHandler = (event) => {
                const { transform, d3Selection, d3Zoom, translateExtent, width, height } = store.getState();
                if (event.sourceEvent.type !== 'mousemove' || !d3Selection || !d3Zoom) {
                    return;
                }
                // @TODO: how to calculate the correct next position? Math.max(1, transform[2]) is a workaround.
                const moveScale = viewScaleRef.current * Math.max(1, transform[2]) * (inversePan ? -1 : 1);
                const position = {
                    x: transform[0] - event.sourceEvent.movementX * moveScale,
                    y: transform[1] - event.sourceEvent.movementY * moveScale,
                };
                const extent = [
                    [0, 0],
                    [width, height],
                ];
                const nextTransform = identity.translate(position.x, position.y).scale(transform[2]);
                const constrainedTransform = d3Zoom.constrain()(nextTransform, extent, translateExtent);
                d3Zoom.transform(d3Selection, constrainedTransform);
            };
            const zoomAndPanHandler = zoom()
                // @ts-ignore
                .on('zoom', pannable ? panHandler : null)
                // @ts-ignore
                .on('zoom.wheel', zoomable ? zoomHandler : null);
            selection.call(zoomAndPanHandler);
            return () => {
                selection.on('zoom', null);
            };
        }
    }, [pannable, zoomable, inversePan, zoomStep]);
    const onSvgClick = onClick
        ? (event) => {
            const rfCoord = pointer(event);
            onClick(event, { x: rfCoord[0], y: rfCoord[1] });
        }
        : undefined;
    const onSvgNodeClick = onNodeClick
        ? (event, nodeId) => {
            const node = store.getState().nodeInternals.get(nodeId);
            onNodeClick(event, node);
        }
        : undefined;
    return (React$z.createElement(Panel, { position: position, style: style, className: cc(['react-flow__minimap', className]), "data-testid": "rf__minimap" },
        React$z.createElement("svg", { width: elementWidth, height: elementHeight, viewBox: `${x} ${y} ${width} ${height}`, role: "img", "aria-labelledby": labelledBy, ref: svg, onClick: onSvgClick },
            ariaLabel && React$z.createElement("title", { id: labelledBy }, ariaLabel),
            React$z.createElement(MiniMapNodes$1, { onClick: onSvgNodeClick, nodeColor: nodeColor, nodeStrokeColor: nodeStrokeColor, nodeBorderRadius: nodeBorderRadius, nodeClassName: nodeClassName, nodeStrokeWidth: nodeStrokeWidth, nodeComponent: nodeComponent }),
            React$z.createElement("path", { className: "react-flow__minimap-mask", d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z
        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`, fill: maskColor, fillRule: "evenodd", stroke: maskStrokeColor, strokeWidth: maskStrokeWidth, pointerEvents: "none" }))));
}
MiniMap.displayName = 'MiniMap';
var MiniMap$1 = memo$n(MiniMap);

const React$y = await importShared('react');
const {memo: memo$m,useState: useState$v,useEffect: useEffect$o} = React$y;

function PlusIcon() {
    return (React$y.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32" },
        React$y.createElement("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" })));
}

function MinusIcon() {
    return (React$y.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5" },
        React$y.createElement("path", { d: "M0 0h32v4.2H0z" })));
}

function FitViewIcon() {
    return (React$y.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30" },
        React$y.createElement("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" })));
}

function LockIcon() {
    return (React$y.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
        React$y.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" })));
}

function UnlockIcon() {
    return (React$y.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
        React$y.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" })));
}

const ControlButton = ({ children, className, ...rest }) => (React$y.createElement("button", { type: "button", className: cc(['react-flow__controls-button', className]), ...rest }, children));
ControlButton.displayName = 'ControlButton';

const selector$1 = (s) => ({
    isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,
    minZoomReached: s.transform[2] <= s.minZoom,
    maxZoomReached: s.transform[2] >= s.maxZoom,
});
const Controls = ({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = 'bottom-left', }) => {
    const store = useStoreApi();
    const [isVisible, setIsVisible] = useState$v(false);
    const { isInteractive, minZoomReached, maxZoomReached } = useStore(selector$1, shallow$1);
    const { zoomIn, zoomOut, fitView } = useReactFlow();
    useEffect$o(() => {
        setIsVisible(true);
    }, []);
    if (!isVisible) {
        return null;
    }
    const onZoomInHandler = () => {
        zoomIn();
        onZoomIn?.();
    };
    const onZoomOutHandler = () => {
        zoomOut();
        onZoomOut?.();
    };
    const onFitViewHandler = () => {
        fitView(fitViewOptions);
        onFitView?.();
    };
    const onToggleInteractivity = () => {
        store.setState({
            nodesDraggable: !isInteractive,
            nodesConnectable: !isInteractive,
            elementsSelectable: !isInteractive,
        });
        onInteractiveChange?.(!isInteractive);
    };
    return (React$y.createElement(Panel, { className: cc(['react-flow__controls', className]), position: position, style: style, "data-testid": "rf__controls" },
        showZoom && (React$y.createElement(React$y.Fragment, null,
            React$y.createElement(ControlButton, { onClick: onZoomInHandler, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: maxZoomReached },
                React$y.createElement(PlusIcon, null)),
            React$y.createElement(ControlButton, { onClick: onZoomOutHandler, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: minZoomReached },
                React$y.createElement(MinusIcon, null)))),
        showFitView && (React$y.createElement(ControlButton, { className: "react-flow__controls-fitview", onClick: onFitViewHandler, title: "fit view", "aria-label": "fit view" },
            React$y.createElement(FitViewIcon, null))),
        showInteractive && (React$y.createElement(ControlButton, { className: "react-flow__controls-interactive", onClick: onToggleInteractivity, title: "toggle interactivity", "aria-label": "toggle interactivity" }, isInteractive ? React$y.createElement(UnlockIcon, null) : React$y.createElement(LockIcon, null))),
        children));
};
Controls.displayName = 'Controls';
var Controls$1 = memo$m(Controls);

const React$x = await importShared('react');
const {memo: memo$l,useRef: useRef$k} = React$x;

var BackgroundVariant;
(function (BackgroundVariant) {
    BackgroundVariant["Lines"] = "lines";
    BackgroundVariant["Dots"] = "dots";
    BackgroundVariant["Cross"] = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));

function LinePattern({ color, dimensions, lineWidth }) {
    return (React$x.createElement("path", { stroke: color, strokeWidth: lineWidth, d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}` }));
}
function DotPattern({ color, radius }) {
    return React$x.createElement("circle", { cx: radius, cy: radius, r: radius, fill: color });
}

const defaultColor = {
    [BackgroundVariant.Dots]: '#91919a',
    [BackgroundVariant.Lines]: '#eee',
    [BackgroundVariant.Cross]: '#e2e2e2',
};
const defaultSize = {
    [BackgroundVariant.Dots]: 1,
    [BackgroundVariant.Lines]: 1,
    [BackgroundVariant.Cross]: 6,
};
const selector = (s) => ({ transform: s.transform, patternId: `pattern-${s.rfId}` });
function Background({ id, variant = BackgroundVariant.Dots, 
// only used for dots and cross
gap = 20, 
// only used for lines and cross
size, lineWidth = 1, offset = 2, color, style, className, }) {
    const ref = useRef$k(null);
    const { transform, patternId } = useStore(selector, shallow$1);
    const patternColor = color || defaultColor[variant];
    const patternSize = size || defaultSize[variant];
    const isDots = variant === BackgroundVariant.Dots;
    const isCross = variant === BackgroundVariant.Cross;
    const gapXY = Array.isArray(gap) ? gap : [gap, gap];
    const scaledGap = [gapXY[0] * transform[2] || 1, gapXY[1] * transform[2] || 1];
    const scaledSize = patternSize * transform[2];
    const patternDimensions = isCross ? [scaledSize, scaledSize] : scaledGap;
    const patternOffset = isDots
        ? [scaledSize / offset, scaledSize / offset]
        : [patternDimensions[0] / offset, patternDimensions[1] / offset];
    return (React$x.createElement("svg", { className: cc(['react-flow__background', className]), style: {
            ...style,
            position: 'absolute',
            width: '100%',
            height: '100%',
            top: 0,
            left: 0,
        }, ref: ref, "data-testid": "rf__background" },
        React$x.createElement("pattern", { id: patternId + id, x: transform[0] % scaledGap[0], y: transform[1] % scaledGap[1], width: scaledGap[0], height: scaledGap[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${patternOffset[0]},-${patternOffset[1]})` }, isDots ? (React$x.createElement(DotPattern, { color: patternColor, radius: scaledSize / offset })) : (React$x.createElement(LinePattern, { dimensions: patternDimensions, color: patternColor, lineWidth: lineWidth }))),
        React$x.createElement("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${patternId + id})` })));
}
Background.displayName = 'Background';
var Background$1 = memo$l(Background);

function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

var _listCacheClear;
var hasRequired_listCacheClear;

function require_listCacheClear () {
	if (hasRequired_listCacheClear) return _listCacheClear;
	hasRequired_listCacheClear = 1;
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	_listCacheClear = listCacheClear;
	return _listCacheClear;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	eq_1 = eq;
	return eq_1;
}

var _assocIndexOf;
var hasRequired_assocIndexOf;

function require_assocIndexOf () {
	if (hasRequired_assocIndexOf) return _assocIndexOf;
	hasRequired_assocIndexOf = 1;
	var eq = requireEq();

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	_assocIndexOf = assocIndexOf;
	return _assocIndexOf;
}

var _listCacheDelete;
var hasRequired_listCacheDelete;

function require_listCacheDelete () {
	if (hasRequired_listCacheDelete) return _listCacheDelete;
	hasRequired_listCacheDelete = 1;
	var assocIndexOf = require_assocIndexOf();

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	_listCacheDelete = listCacheDelete;
	return _listCacheDelete;
}

var _listCacheGet;
var hasRequired_listCacheGet;

function require_listCacheGet () {
	if (hasRequired_listCacheGet) return _listCacheGet;
	hasRequired_listCacheGet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	_listCacheGet = listCacheGet;
	return _listCacheGet;
}

var _listCacheHas;
var hasRequired_listCacheHas;

function require_listCacheHas () {
	if (hasRequired_listCacheHas) return _listCacheHas;
	hasRequired_listCacheHas = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	_listCacheHas = listCacheHas;
	return _listCacheHas;
}

var _listCacheSet;
var hasRequired_listCacheSet;

function require_listCacheSet () {
	if (hasRequired_listCacheSet) return _listCacheSet;
	hasRequired_listCacheSet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	_listCacheSet = listCacheSet;
	return _listCacheSet;
}

var _ListCache;
var hasRequired_ListCache;

function require_ListCache () {
	if (hasRequired_ListCache) return _ListCache;
	hasRequired_ListCache = 1;
	var listCacheClear = require_listCacheClear(),
	    listCacheDelete = require_listCacheDelete(),
	    listCacheGet = require_listCacheGet(),
	    listCacheHas = require_listCacheHas(),
	    listCacheSet = require_listCacheSet();

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	_ListCache = ListCache;
	return _ListCache;
}

var _stackClear;
var hasRequired_stackClear;

function require_stackClear () {
	if (hasRequired_stackClear) return _stackClear;
	hasRequired_stackClear = 1;
	var ListCache = require_ListCache();

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	_stackClear = stackClear;
	return _stackClear;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _stackDelete;
var hasRequired_stackDelete;

function require_stackDelete () {
	if (hasRequired_stackDelete) return _stackDelete;
	hasRequired_stackDelete = 1;
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	_stackDelete = stackDelete;
	return _stackDelete;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

var _stackGet;
var hasRequired_stackGet;

function require_stackGet () {
	if (hasRequired_stackGet) return _stackGet;
	hasRequired_stackGet = 1;
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	_stackGet = stackGet;
	return _stackGet;
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

var _stackHas;
var hasRequired_stackHas;

function require_stackHas () {
	if (hasRequired_stackHas) return _stackHas;
	hasRequired_stackHas = 1;
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	_stackHas = stackHas;
	return _stackHas;
}

/** Detect free variable `global` from Node.js. */

var _freeGlobal;
var hasRequired_freeGlobal;

function require_freeGlobal () {
	if (hasRequired_freeGlobal) return _freeGlobal;
	hasRequired_freeGlobal = 1;
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	_freeGlobal = freeGlobal;
	return _freeGlobal;
}

var _root;
var hasRequired_root;

function require_root () {
	if (hasRequired_root) return _root;
	hasRequired_root = 1;
	var freeGlobal = require_freeGlobal();

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	_root = root;
	return _root;
}

var _Symbol;
var hasRequired_Symbol;

function require_Symbol () {
	if (hasRequired_Symbol) return _Symbol;
	hasRequired_Symbol = 1;
	var root = require_root();

	/** Built-in value references. */
	var Symbol = root.Symbol;

	_Symbol = Symbol;
	return _Symbol;
}

var _getRawTag;
var hasRequired_getRawTag;

function require_getRawTag () {
	if (hasRequired_getRawTag) return _getRawTag;
	hasRequired_getRawTag = 1;
	var Symbol = require_Symbol();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	_getRawTag = getRawTag;
	return _getRawTag;
}

/** Used for built-in method references. */

var _objectToString;
var hasRequired_objectToString;

function require_objectToString () {
	if (hasRequired_objectToString) return _objectToString;
	hasRequired_objectToString = 1;
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	_objectToString = objectToString;
	return _objectToString;
}

var _baseGetTag;
var hasRequired_baseGetTag;

function require_baseGetTag () {
	if (hasRequired_baseGetTag) return _baseGetTag;
	hasRequired_baseGetTag = 1;
	var Symbol = require_Symbol(),
	    getRawTag = require_getRawTag(),
	    objectToString = require_objectToString();

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	_baseGetTag = baseGetTag;
	return _baseGetTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */

var isObject_1;
var hasRequiredIsObject;

function requireIsObject () {
	if (hasRequiredIsObject) return isObject_1;
	hasRequiredIsObject = 1;
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	isObject_1 = isObject;
	return isObject_1;
}

var isFunction_1;
var hasRequiredIsFunction;

function requireIsFunction () {
	if (hasRequiredIsFunction) return isFunction_1;
	hasRequiredIsFunction = 1;
	var baseGetTag = require_baseGetTag(),
	    isObject = requireIsObject();

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	isFunction_1 = isFunction;
	return isFunction_1;
}

var _coreJsData;
var hasRequired_coreJsData;

function require_coreJsData () {
	if (hasRequired_coreJsData) return _coreJsData;
	hasRequired_coreJsData = 1;
	var root = require_root();

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	_coreJsData = coreJsData;
	return _coreJsData;
}

var _isMasked;
var hasRequired_isMasked;

function require_isMasked () {
	if (hasRequired_isMasked) return _isMasked;
	hasRequired_isMasked = 1;
	var coreJsData = require_coreJsData();

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	_isMasked = isMasked;
	return _isMasked;
}

/** Used for built-in method references. */

var _toSource;
var hasRequired_toSource;

function require_toSource () {
	if (hasRequired_toSource) return _toSource;
	hasRequired_toSource = 1;
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	_toSource = toSource;
	return _toSource;
}

var _baseIsNative;
var hasRequired_baseIsNative;

function require_baseIsNative () {
	if (hasRequired_baseIsNative) return _baseIsNative;
	hasRequired_baseIsNative = 1;
	var isFunction = requireIsFunction(),
	    isMasked = require_isMasked(),
	    isObject = requireIsObject(),
	    toSource = require_toSource();

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	_baseIsNative = baseIsNative;
	return _baseIsNative;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

var _getValue;
var hasRequired_getValue;

function require_getValue () {
	if (hasRequired_getValue) return _getValue;
	hasRequired_getValue = 1;
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	_getValue = getValue;
	return _getValue;
}

var _getNative;
var hasRequired_getNative;

function require_getNative () {
	if (hasRequired_getNative) return _getNative;
	hasRequired_getNative = 1;
	var baseIsNative = require_baseIsNative(),
	    getValue = require_getValue();

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	_getNative = getNative;
	return _getNative;
}

var _Map;
var hasRequired_Map;

function require_Map () {
	if (hasRequired_Map) return _Map;
	hasRequired_Map = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	_Map = Map;
	return _Map;
}

var _nativeCreate;
var hasRequired_nativeCreate;

function require_nativeCreate () {
	if (hasRequired_nativeCreate) return _nativeCreate;
	hasRequired_nativeCreate = 1;
	var getNative = require_getNative();

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	_nativeCreate = nativeCreate;
	return _nativeCreate;
}

var _hashClear;
var hasRequired_hashClear;

function require_hashClear () {
	if (hasRequired_hashClear) return _hashClear;
	hasRequired_hashClear = 1;
	var nativeCreate = require_nativeCreate();

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	_hashClear = hashClear;
	return _hashClear;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _hashDelete;
var hasRequired_hashDelete;

function require_hashDelete () {
	if (hasRequired_hashDelete) return _hashDelete;
	hasRequired_hashDelete = 1;
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_hashDelete = hashDelete;
	return _hashDelete;
}

var _hashGet;
var hasRequired_hashGet;

function require_hashGet () {
	if (hasRequired_hashGet) return _hashGet;
	hasRequired_hashGet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	_hashGet = hashGet;
	return _hashGet;
}

var _hashHas;
var hasRequired_hashHas;

function require_hashHas () {
	if (hasRequired_hashHas) return _hashHas;
	hasRequired_hashHas = 1;
	var nativeCreate = require_nativeCreate();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	_hashHas = hashHas;
	return _hashHas;
}

var _hashSet;
var hasRequired_hashSet;

function require_hashSet () {
	if (hasRequired_hashSet) return _hashSet;
	hasRequired_hashSet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	_hashSet = hashSet;
	return _hashSet;
}

var _Hash;
var hasRequired_Hash;

function require_Hash () {
	if (hasRequired_Hash) return _Hash;
	hasRequired_Hash = 1;
	var hashClear = require_hashClear(),
	    hashDelete = require_hashDelete(),
	    hashGet = require_hashGet(),
	    hashHas = require_hashHas(),
	    hashSet = require_hashSet();

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	_Hash = Hash;
	return _Hash;
}

var _mapCacheClear;
var hasRequired_mapCacheClear;

function require_mapCacheClear () {
	if (hasRequired_mapCacheClear) return _mapCacheClear;
	hasRequired_mapCacheClear = 1;
	var Hash = require_Hash(),
	    ListCache = require_ListCache(),
	    Map = require_Map();

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	_mapCacheClear = mapCacheClear;
	return _mapCacheClear;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */

var _isKeyable;
var hasRequired_isKeyable;

function require_isKeyable () {
	if (hasRequired_isKeyable) return _isKeyable;
	hasRequired_isKeyable = 1;
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	_isKeyable = isKeyable;
	return _isKeyable;
}

var _getMapData;
var hasRequired_getMapData;

function require_getMapData () {
	if (hasRequired_getMapData) return _getMapData;
	hasRequired_getMapData = 1;
	var isKeyable = require_isKeyable();

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	_getMapData = getMapData;
	return _getMapData;
}

var _mapCacheDelete;
var hasRequired_mapCacheDelete;

function require_mapCacheDelete () {
	if (hasRequired_mapCacheDelete) return _mapCacheDelete;
	hasRequired_mapCacheDelete = 1;
	var getMapData = require_getMapData();

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_mapCacheDelete = mapCacheDelete;
	return _mapCacheDelete;
}

var _mapCacheGet;
var hasRequired_mapCacheGet;

function require_mapCacheGet () {
	if (hasRequired_mapCacheGet) return _mapCacheGet;
	hasRequired_mapCacheGet = 1;
	var getMapData = require_getMapData();

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	_mapCacheGet = mapCacheGet;
	return _mapCacheGet;
}

var _mapCacheHas;
var hasRequired_mapCacheHas;

function require_mapCacheHas () {
	if (hasRequired_mapCacheHas) return _mapCacheHas;
	hasRequired_mapCacheHas = 1;
	var getMapData = require_getMapData();

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	_mapCacheHas = mapCacheHas;
	return _mapCacheHas;
}

var _mapCacheSet;
var hasRequired_mapCacheSet;

function require_mapCacheSet () {
	if (hasRequired_mapCacheSet) return _mapCacheSet;
	hasRequired_mapCacheSet = 1;
	var getMapData = require_getMapData();

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	_mapCacheSet = mapCacheSet;
	return _mapCacheSet;
}

var _MapCache;
var hasRequired_MapCache;

function require_MapCache () {
	if (hasRequired_MapCache) return _MapCache;
	hasRequired_MapCache = 1;
	var mapCacheClear = require_mapCacheClear(),
	    mapCacheDelete = require_mapCacheDelete(),
	    mapCacheGet = require_mapCacheGet(),
	    mapCacheHas = require_mapCacheHas(),
	    mapCacheSet = require_mapCacheSet();

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	_MapCache = MapCache;
	return _MapCache;
}

var _stackSet;
var hasRequired_stackSet;

function require_stackSet () {
	if (hasRequired_stackSet) return _stackSet;
	hasRequired_stackSet = 1;
	var ListCache = require_ListCache(),
	    Map = require_Map(),
	    MapCache = require_MapCache();

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	_stackSet = stackSet;
	return _stackSet;
}

var _Stack;
var hasRequired_Stack;

function require_Stack () {
	if (hasRequired_Stack) return _Stack;
	hasRequired_Stack = 1;
	var ListCache = require_ListCache(),
	    stackClear = require_stackClear(),
	    stackDelete = require_stackDelete(),
	    stackGet = require_stackGet(),
	    stackHas = require_stackHas(),
	    stackSet = require_stackSet();

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	_Stack = Stack;
	return _Stack;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */

var _arrayEach;
var hasRequired_arrayEach;

function require_arrayEach () {
	if (hasRequired_arrayEach) return _arrayEach;
	hasRequired_arrayEach = 1;
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	_arrayEach = arrayEach;
	return _arrayEach;
}

var _defineProperty;
var hasRequired_defineProperty;

function require_defineProperty () {
	if (hasRequired_defineProperty) return _defineProperty;
	hasRequired_defineProperty = 1;
	var getNative = require_getNative();

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	_defineProperty = defineProperty;
	return _defineProperty;
}

var _baseAssignValue;
var hasRequired_baseAssignValue;

function require_baseAssignValue () {
	if (hasRequired_baseAssignValue) return _baseAssignValue;
	hasRequired_baseAssignValue = 1;
	var defineProperty = require_defineProperty();

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	_baseAssignValue = baseAssignValue;
	return _baseAssignValue;
}

var _assignValue;
var hasRequired_assignValue;

function require_assignValue () {
	if (hasRequired_assignValue) return _assignValue;
	hasRequired_assignValue = 1;
	var baseAssignValue = require_baseAssignValue(),
	    eq = requireEq();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	_assignValue = assignValue;
	return _assignValue;
}

var _copyObject;
var hasRequired_copyObject;

function require_copyObject () {
	if (hasRequired_copyObject) return _copyObject;
	hasRequired_copyObject = 1;
	var assignValue = require_assignValue(),
	    baseAssignValue = require_baseAssignValue();

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	_copyObject = copyObject;
	return _copyObject;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */

var _baseTimes;
var hasRequired_baseTimes;

function require_baseTimes () {
	if (hasRequired_baseTimes) return _baseTimes;
	hasRequired_baseTimes = 1;
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	_baseTimes = baseTimes;
	return _baseTimes;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

var isObjectLike_1;
var hasRequiredIsObjectLike;

function requireIsObjectLike () {
	if (hasRequiredIsObjectLike) return isObjectLike_1;
	hasRequiredIsObjectLike = 1;
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	isObjectLike_1 = isObjectLike;
	return isObjectLike_1;
}

var _baseIsArguments;
var hasRequired_baseIsArguments;

function require_baseIsArguments () {
	if (hasRequired_baseIsArguments) return _baseIsArguments;
	hasRequired_baseIsArguments = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	_baseIsArguments = baseIsArguments;
	return _baseIsArguments;
}

var isArguments_1;
var hasRequiredIsArguments;

function requireIsArguments () {
	if (hasRequiredIsArguments) return isArguments_1;
	hasRequiredIsArguments = 1;
	var baseIsArguments = require_baseIsArguments(),
	    isObjectLike = requireIsObjectLike();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	isArguments_1 = isArguments;
	return isArguments_1;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */

var isArray_1;
var hasRequiredIsArray;

function requireIsArray () {
	if (hasRequiredIsArray) return isArray_1;
	hasRequiredIsArray = 1;
	var isArray = Array.isArray;

	isArray_1 = isArray;
	return isArray_1;
}

var isBuffer = {exports: {}};

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */

var stubFalse_1;
var hasRequiredStubFalse;

function requireStubFalse () {
	if (hasRequiredStubFalse) return stubFalse_1;
	hasRequiredStubFalse = 1;
	function stubFalse() {
	  return false;
	}

	stubFalse_1 = stubFalse;
	return stubFalse_1;
}

isBuffer.exports;

var hasRequiredIsBuffer;

function requireIsBuffer () {
	if (hasRequiredIsBuffer) return isBuffer.exports;
	hasRequiredIsBuffer = 1;
	(function (module, exports) {
		var root = require_root(),
		    stubFalse = requireStubFalse();

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined;

		/* Built-in method references for those with the same name as other `lodash` methods. */
		var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

		/**
		 * Checks if `value` is a buffer.
		 *
		 * @static
		 * @memberOf _
		 * @since 4.3.0
		 * @category Lang
		 * @param {*} value The value to check.
		 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
		 * @example
		 *
		 * _.isBuffer(new Buffer(2));
		 * // => true
		 *
		 * _.isBuffer(new Uint8Array(2));
		 * // => false
		 */
		var isBuffer = nativeIsBuffer || stubFalse;

		module.exports = isBuffer; 
	} (isBuffer, isBuffer.exports));
	return isBuffer.exports;
}

/** Used as references for various `Number` constants. */

var _isIndex;
var hasRequired_isIndex;

function require_isIndex () {
	if (hasRequired_isIndex) return _isIndex;
	hasRequired_isIndex = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	_isIndex = isIndex;
	return _isIndex;
}

/** Used as references for various `Number` constants. */

var isLength_1;
var hasRequiredIsLength;

function requireIsLength () {
	if (hasRequiredIsLength) return isLength_1;
	hasRequiredIsLength = 1;
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	isLength_1 = isLength;
	return isLength_1;
}

var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;

function require_baseIsTypedArray () {
	if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
	hasRequired_baseIsTypedArray = 1;
	var baseGetTag = require_baseGetTag(),
	    isLength = requireIsLength(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	_baseIsTypedArray = baseIsTypedArray;
	return _baseIsTypedArray;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */

var _baseUnary;
var hasRequired_baseUnary;

function require_baseUnary () {
	if (hasRequired_baseUnary) return _baseUnary;
	hasRequired_baseUnary = 1;
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	_baseUnary = baseUnary;
	return _baseUnary;
}

var _nodeUtil = {exports: {}};

_nodeUtil.exports;

var hasRequired_nodeUtil;

function require_nodeUtil () {
	if (hasRequired_nodeUtil) return _nodeUtil.exports;
	hasRequired_nodeUtil = 1;
	(function (module, exports) {
		var freeGlobal = require_freeGlobal();

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Detect free variable `process` from Node.js. */
		var freeProcess = moduleExports && freeGlobal.process;

		/** Used to access faster Node.js helpers. */
		var nodeUtil = (function() {
		  try {
		    // Use `util.types` for Node.js 10+.
		    var types = freeModule && freeModule.require && freeModule.require('util').types;

		    if (types) {
		      return types;
		    }

		    // Legacy `process.binding('util')` for Node.js < 10.
		    return freeProcess && freeProcess.binding && freeProcess.binding('util');
		  } catch (e) {}
		}());

		module.exports = nodeUtil; 
	} (_nodeUtil, _nodeUtil.exports));
	return _nodeUtil.exports;
}

var isTypedArray_1;
var hasRequiredIsTypedArray;

function requireIsTypedArray () {
	if (hasRequiredIsTypedArray) return isTypedArray_1;
	hasRequiredIsTypedArray = 1;
	var baseIsTypedArray = require_baseIsTypedArray(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	isTypedArray_1 = isTypedArray;
	return isTypedArray_1;
}

var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;

function require_arrayLikeKeys () {
	if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
	hasRequired_arrayLikeKeys = 1;
	var baseTimes = require_baseTimes(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isIndex = require_isIndex(),
	    isTypedArray = requireIsTypedArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_arrayLikeKeys = arrayLikeKeys;
	return _arrayLikeKeys;
}

/** Used for built-in method references. */

var _isPrototype;
var hasRequired_isPrototype;

function require_isPrototype () {
	if (hasRequired_isPrototype) return _isPrototype;
	hasRequired_isPrototype = 1;
	var objectProto = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	_isPrototype = isPrototype;
	return _isPrototype;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */

var _overArg;
var hasRequired_overArg;

function require_overArg () {
	if (hasRequired_overArg) return _overArg;
	hasRequired_overArg = 1;
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	_overArg = overArg;
	return _overArg;
}

var _nativeKeys;
var hasRequired_nativeKeys;

function require_nativeKeys () {
	if (hasRequired_nativeKeys) return _nativeKeys;
	hasRequired_nativeKeys = 1;
	var overArg = require_overArg();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	_nativeKeys = nativeKeys;
	return _nativeKeys;
}

var _baseKeys;
var hasRequired_baseKeys;

function require_baseKeys () {
	if (hasRequired_baseKeys) return _baseKeys;
	hasRequired_baseKeys = 1;
	var isPrototype = require_isPrototype(),
	    nativeKeys = require_nativeKeys();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_baseKeys = baseKeys;
	return _baseKeys;
}

var isArrayLike_1;
var hasRequiredIsArrayLike;

function requireIsArrayLike () {
	if (hasRequiredIsArrayLike) return isArrayLike_1;
	hasRequiredIsArrayLike = 1;
	var isFunction = requireIsFunction(),
	    isLength = requireIsLength();

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	isArrayLike_1 = isArrayLike;
	return isArrayLike_1;
}

var keys_1;
var hasRequiredKeys;

function requireKeys () {
	if (hasRequiredKeys) return keys_1;
	hasRequiredKeys = 1;
	var arrayLikeKeys = require_arrayLikeKeys(),
	    baseKeys = require_baseKeys(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	keys_1 = keys;
	return keys_1;
}

var _baseAssign;
var hasRequired_baseAssign;

function require_baseAssign () {
	if (hasRequired_baseAssign) return _baseAssign;
	hasRequired_baseAssign = 1;
	var copyObject = require_copyObject(),
	    keys = requireKeys();

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	_baseAssign = baseAssign;
	return _baseAssign;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

var _nativeKeysIn;
var hasRequired_nativeKeysIn;

function require_nativeKeysIn () {
	if (hasRequired_nativeKeysIn) return _nativeKeysIn;
	hasRequired_nativeKeysIn = 1;
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_nativeKeysIn = nativeKeysIn;
	return _nativeKeysIn;
}

var _baseKeysIn;
var hasRequired_baseKeysIn;

function require_baseKeysIn () {
	if (hasRequired_baseKeysIn) return _baseKeysIn;
	hasRequired_baseKeysIn = 1;
	var isObject = requireIsObject(),
	    isPrototype = require_isPrototype(),
	    nativeKeysIn = require_nativeKeysIn();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	_baseKeysIn = baseKeysIn;
	return _baseKeysIn;
}

var keysIn_1;
var hasRequiredKeysIn;

function requireKeysIn () {
	if (hasRequiredKeysIn) return keysIn_1;
	hasRequiredKeysIn = 1;
	var arrayLikeKeys = require_arrayLikeKeys(),
	    baseKeysIn = require_baseKeysIn(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	keysIn_1 = keysIn;
	return keysIn_1;
}

var _baseAssignIn;
var hasRequired_baseAssignIn;

function require_baseAssignIn () {
	if (hasRequired_baseAssignIn) return _baseAssignIn;
	hasRequired_baseAssignIn = 1;
	var copyObject = require_copyObject(),
	    keysIn = requireKeysIn();

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && copyObject(source, keysIn(source), object);
	}

	_baseAssignIn = baseAssignIn;
	return _baseAssignIn;
}

var _cloneBuffer = {exports: {}};

_cloneBuffer.exports;

var hasRequired_cloneBuffer;

function require_cloneBuffer () {
	if (hasRequired_cloneBuffer) return _cloneBuffer.exports;
	hasRequired_cloneBuffer = 1;
	(function (module, exports) {
		var root = require_root();

		/** Detect free variable `exports`. */
		var freeExports = exports && !exports.nodeType && exports;

		/** Detect free variable `module`. */
		var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

		/** Detect the popular CommonJS extension `module.exports`. */
		var moduleExports = freeModule && freeModule.exports === freeExports;

		/** Built-in value references. */
		var Buffer = moduleExports ? root.Buffer : undefined,
		    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

		/**
		 * Creates a clone of  `buffer`.
		 *
		 * @private
		 * @param {Buffer} buffer The buffer to clone.
		 * @param {boolean} [isDeep] Specify a deep clone.
		 * @returns {Buffer} Returns the cloned buffer.
		 */
		function cloneBuffer(buffer, isDeep) {
		  if (isDeep) {
		    return buffer.slice();
		  }
		  var length = buffer.length,
		      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

		  buffer.copy(result);
		  return result;
		}

		module.exports = cloneBuffer; 
	} (_cloneBuffer, _cloneBuffer.exports));
	return _cloneBuffer.exports;
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */

var _copyArray;
var hasRequired_copyArray;

function require_copyArray () {
	if (hasRequired_copyArray) return _copyArray;
	hasRequired_copyArray = 1;
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	_copyArray = copyArray;
	return _copyArray;
}

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */

var _arrayFilter;
var hasRequired_arrayFilter;

function require_arrayFilter () {
	if (hasRequired_arrayFilter) return _arrayFilter;
	hasRequired_arrayFilter = 1;
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	_arrayFilter = arrayFilter;
	return _arrayFilter;
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */

var stubArray_1;
var hasRequiredStubArray;

function requireStubArray () {
	if (hasRequiredStubArray) return stubArray_1;
	hasRequiredStubArray = 1;
	function stubArray() {
	  return [];
	}

	stubArray_1 = stubArray;
	return stubArray_1;
}

var _getSymbols;
var hasRequired_getSymbols;

function require_getSymbols () {
	if (hasRequired_getSymbols) return _getSymbols;
	hasRequired_getSymbols = 1;
	var arrayFilter = require_arrayFilter(),
	    stubArray = requireStubArray();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	_getSymbols = getSymbols;
	return _getSymbols;
}

var _copySymbols;
var hasRequired_copySymbols;

function require_copySymbols () {
	if (hasRequired_copySymbols) return _copySymbols;
	hasRequired_copySymbols = 1;
	var copyObject = require_copyObject(),
	    getSymbols = require_getSymbols();

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols(source), object);
	}

	_copySymbols = copySymbols;
	return _copySymbols;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */

var _arrayPush;
var hasRequired_arrayPush;

function require_arrayPush () {
	if (hasRequired_arrayPush) return _arrayPush;
	hasRequired_arrayPush = 1;
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	_arrayPush = arrayPush;
	return _arrayPush;
}

var _getPrototype;
var hasRequired_getPrototype;

function require_getPrototype () {
	if (hasRequired_getPrototype) return _getPrototype;
	hasRequired_getPrototype = 1;
	var overArg = require_overArg();

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	_getPrototype = getPrototype;
	return _getPrototype;
}

var _getSymbolsIn;
var hasRequired_getSymbolsIn;

function require_getSymbolsIn () {
	if (hasRequired_getSymbolsIn) return _getSymbolsIn;
	hasRequired_getSymbolsIn = 1;
	var arrayPush = require_arrayPush(),
	    getPrototype = require_getPrototype(),
	    getSymbols = require_getSymbols(),
	    stubArray = requireStubArray();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush(result, getSymbols(object));
	    object = getPrototype(object);
	  }
	  return result;
	};

	_getSymbolsIn = getSymbolsIn;
	return _getSymbolsIn;
}

var _copySymbolsIn;
var hasRequired_copySymbolsIn;

function require_copySymbolsIn () {
	if (hasRequired_copySymbolsIn) return _copySymbolsIn;
	hasRequired_copySymbolsIn = 1;
	var copyObject = require_copyObject(),
	    getSymbolsIn = require_getSymbolsIn();

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return copyObject(source, getSymbolsIn(source), object);
	}

	_copySymbolsIn = copySymbolsIn;
	return _copySymbolsIn;
}

var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;

function require_baseGetAllKeys () {
	if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
	hasRequired_baseGetAllKeys = 1;
	var arrayPush = require_arrayPush(),
	    isArray = requireIsArray();

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	_baseGetAllKeys = baseGetAllKeys;
	return _baseGetAllKeys;
}

var _getAllKeys;
var hasRequired_getAllKeys;

function require_getAllKeys () {
	if (hasRequired_getAllKeys) return _getAllKeys;
	hasRequired_getAllKeys = 1;
	var baseGetAllKeys = require_baseGetAllKeys(),
	    getSymbols = require_getSymbols(),
	    keys = requireKeys();

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	_getAllKeys = getAllKeys;
	return _getAllKeys;
}

var _getAllKeysIn;
var hasRequired_getAllKeysIn;

function require_getAllKeysIn () {
	if (hasRequired_getAllKeysIn) return _getAllKeysIn;
	hasRequired_getAllKeysIn = 1;
	var baseGetAllKeys = require_baseGetAllKeys(),
	    getSymbolsIn = require_getSymbolsIn(),
	    keysIn = requireKeysIn();

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return baseGetAllKeys(object, keysIn, getSymbolsIn);
	}

	_getAllKeysIn = getAllKeysIn;
	return _getAllKeysIn;
}

var _DataView;
var hasRequired_DataView;

function require_DataView () {
	if (hasRequired_DataView) return _DataView;
	hasRequired_DataView = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView');

	_DataView = DataView;
	return _DataView;
}

var _Promise;
var hasRequired_Promise;

function require_Promise () {
	if (hasRequired_Promise) return _Promise;
	hasRequired_Promise = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	_Promise = Promise;
	return _Promise;
}

var _Set;
var hasRequired_Set;

function require_Set () {
	if (hasRequired_Set) return _Set;
	hasRequired_Set = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	_Set = Set;
	return _Set;
}

var _WeakMap;
var hasRequired_WeakMap;

function require_WeakMap () {
	if (hasRequired_WeakMap) return _WeakMap;
	hasRequired_WeakMap = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var WeakMap = getNative(root, 'WeakMap');

	_WeakMap = WeakMap;
	return _WeakMap;
}

var _getTag;
var hasRequired_getTag;

function require_getTag () {
	if (hasRequired_getTag) return _getTag;
	hasRequired_getTag = 1;
	var DataView = require_DataView(),
	    Map = require_Map(),
	    Promise = require_Promise(),
	    Set = require_Set(),
	    WeakMap = require_WeakMap(),
	    baseGetTag = require_baseGetTag(),
	    toSource = require_toSource();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	_getTag = getTag;
	return _getTag;
}

/** Used for built-in method references. */

var _initCloneArray;
var hasRequired_initCloneArray;

function require_initCloneArray () {
	if (hasRequired_initCloneArray) return _initCloneArray;
	hasRequired_initCloneArray = 1;
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	_initCloneArray = initCloneArray;
	return _initCloneArray;
}

var _Uint8Array;
var hasRequired_Uint8Array;

function require_Uint8Array () {
	if (hasRequired_Uint8Array) return _Uint8Array;
	hasRequired_Uint8Array = 1;
	var root = require_root();

	/** Built-in value references. */
	var Uint8Array = root.Uint8Array;

	_Uint8Array = Uint8Array;
	return _Uint8Array;
}

var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;

function require_cloneArrayBuffer () {
	if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
	hasRequired_cloneArrayBuffer = 1;
	var Uint8Array = require_Uint8Array();

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	_cloneArrayBuffer = cloneArrayBuffer;
	return _cloneArrayBuffer;
}

var _cloneDataView;
var hasRequired_cloneDataView;

function require_cloneDataView () {
	if (hasRequired_cloneDataView) return _cloneDataView;
	hasRequired_cloneDataView = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer();

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	_cloneDataView = cloneDataView;
	return _cloneDataView;
}

/** Used to match `RegExp` flags from their coerced string values. */

var _cloneRegExp;
var hasRequired_cloneRegExp;

function require_cloneRegExp () {
	if (hasRequired_cloneRegExp) return _cloneRegExp;
	hasRequired_cloneRegExp = 1;
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	_cloneRegExp = cloneRegExp;
	return _cloneRegExp;
}

var _cloneSymbol;
var hasRequired_cloneSymbol;

function require_cloneSymbol () {
	if (hasRequired_cloneSymbol) return _cloneSymbol;
	hasRequired_cloneSymbol = 1;
	var Symbol = require_Symbol();

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	_cloneSymbol = cloneSymbol;
	return _cloneSymbol;
}

var _cloneTypedArray;
var hasRequired_cloneTypedArray;

function require_cloneTypedArray () {
	if (hasRequired_cloneTypedArray) return _cloneTypedArray;
	hasRequired_cloneTypedArray = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer();

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	_cloneTypedArray = cloneTypedArray;
	return _cloneTypedArray;
}

var _initCloneByTag;
var hasRequired_initCloneByTag;

function require_initCloneByTag () {
	if (hasRequired_initCloneByTag) return _initCloneByTag;
	hasRequired_initCloneByTag = 1;
	var cloneArrayBuffer = require_cloneArrayBuffer(),
	    cloneDataView = require_cloneDataView(),
	    cloneRegExp = require_cloneRegExp(),
	    cloneSymbol = require_cloneSymbol(),
	    cloneTypedArray = require_cloneTypedArray();

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag:
	      return cloneArrayBuffer(object);

	    case boolTag:
	    case dateTag:
	      return new Ctor(+object);

	    case dataViewTag:
	      return cloneDataView(object, isDeep);

	    case float32Tag: case float64Tag:
	    case int8Tag: case int16Tag: case int32Tag:
	    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	      return cloneTypedArray(object, isDeep);

	    case mapTag:
	      return new Ctor;

	    case numberTag:
	    case stringTag:
	      return new Ctor(object);

	    case regexpTag:
	      return cloneRegExp(object);

	    case setTag:
	      return new Ctor;

	    case symbolTag:
	      return cloneSymbol(object);
	  }
	}

	_initCloneByTag = initCloneByTag;
	return _initCloneByTag;
}

var _baseCreate;
var hasRequired_baseCreate;

function require_baseCreate () {
	if (hasRequired_baseCreate) return _baseCreate;
	hasRequired_baseCreate = 1;
	var isObject = requireIsObject();

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	_baseCreate = baseCreate;
	return _baseCreate;
}

var _initCloneObject;
var hasRequired_initCloneObject;

function require_initCloneObject () {
	if (hasRequired_initCloneObject) return _initCloneObject;
	hasRequired_initCloneObject = 1;
	var baseCreate = require_baseCreate(),
	    getPrototype = require_getPrototype(),
	    isPrototype = require_isPrototype();

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	_initCloneObject = initCloneObject;
	return _initCloneObject;
}

var _baseIsMap;
var hasRequired_baseIsMap;

function require_baseIsMap () {
	if (hasRequired_baseIsMap) return _baseIsMap;
	hasRequired_baseIsMap = 1;
	var getTag = require_getTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike(value) && getTag(value) == mapTag;
	}

	_baseIsMap = baseIsMap;
	return _baseIsMap;
}

var isMap_1;
var hasRequiredIsMap;

function requireIsMap () {
	if (hasRequiredIsMap) return isMap_1;
	hasRequiredIsMap = 1;
	var baseIsMap = require_baseIsMap(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil && nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	isMap_1 = isMap;
	return isMap_1;
}

var _baseIsSet;
var hasRequired_baseIsSet;

function require_baseIsSet () {
	if (hasRequired_baseIsSet) return _baseIsSet;
	hasRequired_baseIsSet = 1;
	var getTag = require_getTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var setTag = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike(value) && getTag(value) == setTag;
	}

	_baseIsSet = baseIsSet;
	return _baseIsSet;
}

var isSet_1;
var hasRequiredIsSet;

function requireIsSet () {
	if (hasRequiredIsSet) return isSet_1;
	hasRequiredIsSet = 1;
	var baseIsSet = require_baseIsSet(),
	    baseUnary = require_baseUnary(),
	    nodeUtil = require_nodeUtil();

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	isSet_1 = isSet;
	return isSet_1;
}

var _baseClone;
var hasRequired_baseClone;

function require_baseClone () {
	if (hasRequired_baseClone) return _baseClone;
	hasRequired_baseClone = 1;
	var Stack = require_Stack(),
	    arrayEach = require_arrayEach(),
	    assignValue = require_assignValue(),
	    baseAssign = require_baseAssign(),
	    baseAssignIn = require_baseAssignIn(),
	    cloneBuffer = require_cloneBuffer(),
	    copyArray = require_copyArray(),
	    copySymbols = require_copySymbols(),
	    copySymbolsIn = require_copySymbolsIn(),
	    getAllKeys = require_getAllKeys(),
	    getAllKeysIn = require_getAllKeysIn(),
	    getTag = require_getTag(),
	    initCloneArray = require_initCloneArray(),
	    initCloneByTag = require_initCloneByTag(),
	    initCloneObject = require_initCloneObject(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isMap = requireIsMap(),
	    isObject = requireIsObject(),
	    isSet = requireIsSet(),
	    keys = requireKeys(),
	    keysIn = requireKeysIn();

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	cloneableTags[boolTag] = cloneableTags[dateTag] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[setTag] =
	cloneableTags[stringTag] = cloneableTags[symbolTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys)
	    : (isFlat ? keysIn : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	_baseClone = baseClone;
	return _baseClone;
}

var clone_1;
var hasRequiredClone;

function requireClone () {
	if (hasRequiredClone) return clone_1;
	hasRequiredClone = 1;
	var baseClone = require_baseClone();

	/** Used to compose bitmasks for cloning. */
	var CLONE_SYMBOLS_FLAG = 4;

	/**
	 * Creates a shallow clone of `value`.
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	 * and supports cloning arrays, array buffers, booleans, date objects, maps,
	 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	 * arrays. The own enumerable properties of `arguments` objects are cloned
	 * as plain objects. An empty object is returned for uncloneable values such
	 * as error objects, functions, DOM nodes, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @returns {*} Returns the cloned value.
	 * @see _.cloneDeep
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var shallow = _.clone(objects);
	 * console.log(shallow[0] === objects[0]);
	 * // => true
	 */
	function clone(value) {
	  return baseClone(value, CLONE_SYMBOLS_FLAG);
	}

	clone_1 = clone;
	return clone_1;
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */

var constant_1;
var hasRequiredConstant;

function requireConstant () {
	if (hasRequiredConstant) return constant_1;
	hasRequiredConstant = 1;
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	constant_1 = constant;
	return constant_1;
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */

var _createBaseFor;
var hasRequired_createBaseFor;

function require_createBaseFor () {
	if (hasRequired_createBaseFor) return _createBaseFor;
	hasRequired_createBaseFor = 1;
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	_createBaseFor = createBaseFor;
	return _createBaseFor;
}

var _baseFor;
var hasRequired_baseFor;

function require_baseFor () {
	if (hasRequired_baseFor) return _baseFor;
	hasRequired_baseFor = 1;
	var createBaseFor = require_createBaseFor();

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	_baseFor = baseFor;
	return _baseFor;
}

var _baseForOwn;
var hasRequired_baseForOwn;

function require_baseForOwn () {
	if (hasRequired_baseForOwn) return _baseForOwn;
	hasRequired_baseForOwn = 1;
	var baseFor = require_baseFor(),
	    keys = requireKeys();

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	_baseForOwn = baseForOwn;
	return _baseForOwn;
}

var _createBaseEach;
var hasRequired_createBaseEach;

function require_createBaseEach () {
	if (hasRequired_createBaseEach) return _createBaseEach;
	hasRequired_createBaseEach = 1;
	var isArrayLike = requireIsArrayLike();

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	_createBaseEach = createBaseEach;
	return _createBaseEach;
}

var _baseEach;
var hasRequired_baseEach;

function require_baseEach () {
	if (hasRequired_baseEach) return _baseEach;
	hasRequired_baseEach = 1;
	var baseForOwn = require_baseForOwn(),
	    createBaseEach = require_createBaseEach();

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	_baseEach = baseEach;
	return _baseEach;
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */

var identity_1;
var hasRequiredIdentity;

function requireIdentity () {
	if (hasRequiredIdentity) return identity_1;
	hasRequiredIdentity = 1;
	function identity(value) {
	  return value;
	}

	identity_1 = identity;
	return identity_1;
}

var _castFunction;
var hasRequired_castFunction;

function require_castFunction () {
	if (hasRequired_castFunction) return _castFunction;
	hasRequired_castFunction = 1;
	var identity = requireIdentity();

	/**
	 * Casts `value` to `identity` if it's not a function.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Function} Returns cast function.
	 */
	function castFunction(value) {
	  return typeof value == 'function' ? value : identity;
	}

	_castFunction = castFunction;
	return _castFunction;
}

var forEach_1;
var hasRequiredForEach;

function requireForEach () {
	if (hasRequiredForEach) return forEach_1;
	hasRequiredForEach = 1;
	var arrayEach = require_arrayEach(),
	    baseEach = require_baseEach(),
	    castFunction = require_castFunction(),
	    isArray = requireIsArray();

	/**
	 * Iterates over elements of `collection` and invokes `iteratee` for each element.
	 * The iteratee is invoked with three arguments: (value, index|key, collection).
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * **Note:** As with other "Collections" methods, objects with a "length"
	 * property are iterated like arrays. To avoid this behavior use `_.forIn`
	 * or `_.forOwn` for object iteration.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @alias each
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 * @see _.forEachRight
	 * @example
	 *
	 * _.forEach([1, 2], function(value) {
	 *   console.log(value);
	 * });
	 * // => Logs `1` then `2`.
	 *
	 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	 */
	function forEach(collection, iteratee) {
	  var func = isArray(collection) ? arrayEach : baseEach;
	  return func(collection, castFunction(iteratee));
	}

	forEach_1 = forEach;
	return forEach_1;
}

var each;
var hasRequiredEach;

function requireEach () {
	if (hasRequiredEach) return each;
	hasRequiredEach = 1;
	each = requireForEach();
	return each;
}

var _baseFilter;
var hasRequired_baseFilter;

function require_baseFilter () {
	if (hasRequired_baseFilter) return _baseFilter;
	hasRequired_baseFilter = 1;
	var baseEach = require_baseEach();

	/**
	 * The base implementation of `_.filter` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter(collection, predicate) {
	  var result = [];
	  baseEach(collection, function(value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}

	_baseFilter = baseFilter;
	return _baseFilter;
}

/** Used to stand-in for `undefined` hash values. */

var _setCacheAdd;
var hasRequired_setCacheAdd;

function require_setCacheAdd () {
	if (hasRequired_setCacheAdd) return _setCacheAdd;
	hasRequired_setCacheAdd = 1;
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	_setCacheAdd = setCacheAdd;
	return _setCacheAdd;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */

var _setCacheHas;
var hasRequired_setCacheHas;

function require_setCacheHas () {
	if (hasRequired_setCacheHas) return _setCacheHas;
	hasRequired_setCacheHas = 1;
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	_setCacheHas = setCacheHas;
	return _setCacheHas;
}

var _SetCache;
var hasRequired_SetCache;

function require_SetCache () {
	if (hasRequired_SetCache) return _SetCache;
	hasRequired_SetCache = 1;
	var MapCache = require_MapCache(),
	    setCacheAdd = require_setCacheAdd(),
	    setCacheHas = require_setCacheHas();

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	_SetCache = SetCache;
	return _SetCache;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */

var _arraySome;
var hasRequired_arraySome;

function require_arraySome () {
	if (hasRequired_arraySome) return _arraySome;
	hasRequired_arraySome = 1;
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	_arraySome = arraySome;
	return _arraySome;
}

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

var _cacheHas;
var hasRequired_cacheHas;

function require_cacheHas () {
	if (hasRequired_cacheHas) return _cacheHas;
	hasRequired_cacheHas = 1;
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	_cacheHas = cacheHas;
	return _cacheHas;
}

var _equalArrays;
var hasRequired_equalArrays;

function require_equalArrays () {
	if (hasRequired_equalArrays) return _equalArrays;
	hasRequired_equalArrays = 1;
	var SetCache = require_SetCache(),
	    arraySome = require_arraySome(),
	    cacheHas = require_cacheHas();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Check that cyclic values are equal.
	  var arrStacked = stack.get(array);
	  var othStacked = stack.get(other);
	  if (arrStacked && othStacked) {
	    return arrStacked == other && othStacked == array;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	_equalArrays = equalArrays;
	return _equalArrays;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */

var _mapToArray;
var hasRequired_mapToArray;

function require_mapToArray () {
	if (hasRequired_mapToArray) return _mapToArray;
	hasRequired_mapToArray = 1;
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	_mapToArray = mapToArray;
	return _mapToArray;
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */

var _setToArray;
var hasRequired_setToArray;

function require_setToArray () {
	if (hasRequired_setToArray) return _setToArray;
	hasRequired_setToArray = 1;
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	_setToArray = setToArray;
	return _setToArray;
}

var _equalByTag;
var hasRequired_equalByTag;

function require_equalByTag () {
	if (hasRequired_equalByTag) return _equalByTag;
	hasRequired_equalByTag = 1;
	var Symbol = require_Symbol(),
	    Uint8Array = require_Uint8Array(),
	    eq = requireEq(),
	    equalArrays = require_equalArrays(),
	    mapToArray = require_mapToArray(),
	    setToArray = require_setToArray();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	_equalByTag = equalByTag;
	return _equalByTag;
}

var _equalObjects;
var hasRequired_equalObjects;

function require_equalObjects () {
	if (hasRequired_equalObjects) return _equalObjects;
	hasRequired_equalObjects = 1;
	var getAllKeys = require_getAllKeys();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Check that cyclic values are equal.
	  var objStacked = stack.get(object);
	  var othStacked = stack.get(other);
	  if (objStacked && othStacked) {
	    return objStacked == other && othStacked == object;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	_equalObjects = equalObjects;
	return _equalObjects;
}

var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;

function require_baseIsEqualDeep () {
	if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
	hasRequired_baseIsEqualDeep = 1;
	var Stack = require_Stack(),
	    equalArrays = require_equalArrays(),
	    equalByTag = require_equalByTag(),
	    equalObjects = require_equalObjects(),
	    getTag = require_getTag(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isTypedArray = requireIsTypedArray();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    objectTag = '[object Object]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	_baseIsEqualDeep = baseIsEqualDeep;
	return _baseIsEqualDeep;
}

var _baseIsEqual;
var hasRequired_baseIsEqual;

function require_baseIsEqual () {
	if (hasRequired_baseIsEqual) return _baseIsEqual;
	hasRequired_baseIsEqual = 1;
	var baseIsEqualDeep = require_baseIsEqualDeep(),
	    isObjectLike = requireIsObjectLike();

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	_baseIsEqual = baseIsEqual;
	return _baseIsEqual;
}

var _baseIsMatch;
var hasRequired_baseIsMatch;

function require_baseIsMatch () {
	if (hasRequired_baseIsMatch) return _baseIsMatch;
	hasRequired_baseIsMatch = 1;
	var Stack = require_Stack(),
	    baseIsEqual = require_baseIsEqual();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	_baseIsMatch = baseIsMatch;
	return _baseIsMatch;
}

var _isStrictComparable;
var hasRequired_isStrictComparable;

function require_isStrictComparable () {
	if (hasRequired_isStrictComparable) return _isStrictComparable;
	hasRequired_isStrictComparable = 1;
	var isObject = requireIsObject();

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	_isStrictComparable = isStrictComparable;
	return _isStrictComparable;
}

var _getMatchData;
var hasRequired_getMatchData;

function require_getMatchData () {
	if (hasRequired_getMatchData) return _getMatchData;
	hasRequired_getMatchData = 1;
	var isStrictComparable = require_isStrictComparable(),
	    keys = requireKeys();

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	_getMatchData = getMatchData;
	return _getMatchData;
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;

function require_matchesStrictComparable () {
	if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
	hasRequired_matchesStrictComparable = 1;
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	_matchesStrictComparable = matchesStrictComparable;
	return _matchesStrictComparable;
}

var _baseMatches;
var hasRequired_baseMatches;

function require_baseMatches () {
	if (hasRequired_baseMatches) return _baseMatches;
	hasRequired_baseMatches = 1;
	var baseIsMatch = require_baseIsMatch(),
	    getMatchData = require_getMatchData(),
	    matchesStrictComparable = require_matchesStrictComparable();

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	_baseMatches = baseMatches;
	return _baseMatches;
}

var isSymbol_1;
var hasRequiredIsSymbol;

function requireIsSymbol () {
	if (hasRequiredIsSymbol) return isSymbol_1;
	hasRequiredIsSymbol = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	isSymbol_1 = isSymbol;
	return isSymbol_1;
}

var _isKey;
var hasRequired_isKey;

function require_isKey () {
	if (hasRequired_isKey) return _isKey;
	hasRequired_isKey = 1;
	var isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	_isKey = isKey;
	return _isKey;
}

var memoize_1;
var hasRequiredMemoize;

function requireMemoize () {
	if (hasRequiredMemoize) return memoize_1;
	hasRequiredMemoize = 1;
	var MapCache = require_MapCache();

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	memoize_1 = memoize;
	return memoize_1;
}

var _memoizeCapped;
var hasRequired_memoizeCapped;

function require_memoizeCapped () {
	if (hasRequired_memoizeCapped) return _memoizeCapped;
	hasRequired_memoizeCapped = 1;
	var memoize = requireMemoize();

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	_memoizeCapped = memoizeCapped;
	return _memoizeCapped;
}

var _stringToPath;
var hasRequired_stringToPath;

function require_stringToPath () {
	if (hasRequired_stringToPath) return _stringToPath;
	hasRequired_stringToPath = 1;
	var memoizeCapped = require_memoizeCapped();

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	_stringToPath = stringToPath;
	return _stringToPath;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

var _arrayMap;
var hasRequired_arrayMap;

function require_arrayMap () {
	if (hasRequired_arrayMap) return _arrayMap;
	hasRequired_arrayMap = 1;
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	_arrayMap = arrayMap;
	return _arrayMap;
}

var _baseToString;
var hasRequired_baseToString;

function require_baseToString () {
	if (hasRequired_baseToString) return _baseToString;
	hasRequired_baseToString = 1;
	var Symbol = require_Symbol(),
	    arrayMap = require_arrayMap(),
	    isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	_baseToString = baseToString;
	return _baseToString;
}

var toString_1;
var hasRequiredToString;

function requireToString () {
	if (hasRequiredToString) return toString_1;
	hasRequiredToString = 1;
	var baseToString = require_baseToString();

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	toString_1 = toString;
	return toString_1;
}

var _castPath;
var hasRequired_castPath;

function require_castPath () {
	if (hasRequired_castPath) return _castPath;
	hasRequired_castPath = 1;
	var isArray = requireIsArray(),
	    isKey = require_isKey(),
	    stringToPath = require_stringToPath(),
	    toString = requireToString();

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	_castPath = castPath;
	return _castPath;
}

var _toKey;
var hasRequired_toKey;

function require_toKey () {
	if (hasRequired_toKey) return _toKey;
	hasRequired_toKey = 1;
	var isSymbol = requireIsSymbol();

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	_toKey = toKey;
	return _toKey;
}

var _baseGet;
var hasRequired_baseGet;

function require_baseGet () {
	if (hasRequired_baseGet) return _baseGet;
	hasRequired_baseGet = 1;
	var castPath = require_castPath(),
	    toKey = require_toKey();

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	_baseGet = baseGet;
	return _baseGet;
}

var get_1;
var hasRequiredGet;

function requireGet () {
	if (hasRequiredGet) return get_1;
	hasRequiredGet = 1;
	var baseGet = require_baseGet();

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	get_1 = get;
	return get_1;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

var _baseHasIn;
var hasRequired_baseHasIn;

function require_baseHasIn () {
	if (hasRequired_baseHasIn) return _baseHasIn;
	hasRequired_baseHasIn = 1;
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	_baseHasIn = baseHasIn;
	return _baseHasIn;
}

var _hasPath;
var hasRequired_hasPath;

function require_hasPath () {
	if (hasRequired_hasPath) return _hasPath;
	hasRequired_hasPath = 1;
	var castPath = require_castPath(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isIndex = require_isIndex(),
	    isLength = requireIsLength(),
	    toKey = require_toKey();

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	_hasPath = hasPath;
	return _hasPath;
}

var hasIn_1;
var hasRequiredHasIn;

function requireHasIn () {
	if (hasRequiredHasIn) return hasIn_1;
	hasRequiredHasIn = 1;
	var baseHasIn = require_baseHasIn(),
	    hasPath = require_hasPath();

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	hasIn_1 = hasIn;
	return hasIn_1;
}

var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;

function require_baseMatchesProperty () {
	if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
	hasRequired_baseMatchesProperty = 1;
	var baseIsEqual = require_baseIsEqual(),
	    get = requireGet(),
	    hasIn = requireHasIn(),
	    isKey = require_isKey(),
	    isStrictComparable = require_isStrictComparable(),
	    matchesStrictComparable = require_matchesStrictComparable(),
	    toKey = require_toKey();

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	  };
	}

	_baseMatchesProperty = baseMatchesProperty;
	return _baseMatchesProperty;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */

var _baseProperty;
var hasRequired_baseProperty;

function require_baseProperty () {
	if (hasRequired_baseProperty) return _baseProperty;
	hasRequired_baseProperty = 1;
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	_baseProperty = baseProperty;
	return _baseProperty;
}

var _basePropertyDeep;
var hasRequired_basePropertyDeep;

function require_basePropertyDeep () {
	if (hasRequired_basePropertyDeep) return _basePropertyDeep;
	hasRequired_basePropertyDeep = 1;
	var baseGet = require_baseGet();

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	_basePropertyDeep = basePropertyDeep;
	return _basePropertyDeep;
}

var property_1;
var hasRequiredProperty;

function requireProperty () {
	if (hasRequiredProperty) return property_1;
	hasRequiredProperty = 1;
	var baseProperty = require_baseProperty(),
	    basePropertyDeep = require_basePropertyDeep(),
	    isKey = require_isKey(),
	    toKey = require_toKey();

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	property_1 = property;
	return property_1;
}

var _baseIteratee;
var hasRequired_baseIteratee;

function require_baseIteratee () {
	if (hasRequired_baseIteratee) return _baseIteratee;
	hasRequired_baseIteratee = 1;
	var baseMatches = require_baseMatches(),
	    baseMatchesProperty = require_baseMatchesProperty(),
	    identity = requireIdentity(),
	    isArray = requireIsArray(),
	    property = requireProperty();

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	_baseIteratee = baseIteratee;
	return _baseIteratee;
}

var filter_1;
var hasRequiredFilter;

function requireFilter () {
	if (hasRequiredFilter) return filter_1;
	hasRequiredFilter = 1;
	var arrayFilter = require_arrayFilter(),
	    baseFilter = require_baseFilter(),
	    baseIteratee = require_baseIteratee(),
	    isArray = requireIsArray();

	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * **Note:** Unlike `_.remove`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 * @see _.reject
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * _.filter(users, function(o) { return !o.active; });
	 * // => objects for ['fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, { 'age': 36, 'active': true });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, ['active', false]);
	 * // => objects for ['fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.filter(users, 'active');
	 * // => objects for ['barney']
	 *
	 * // Combining several predicates using `_.overEvery` or `_.overSome`.
	 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
	 * // => objects for ['fred', 'barney']
	 */
	function filter(collection, predicate) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  return func(collection, baseIteratee(predicate, 3));
	}

	filter_1 = filter;
	return filter_1;
}

/** Used for built-in method references. */

var _baseHas;
var hasRequired_baseHas;

function require_baseHas () {
	if (hasRequired_baseHas) return _baseHas;
	hasRequired_baseHas = 1;
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * The base implementation of `_.has` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHas(object, key) {
	  return object != null && hasOwnProperty.call(object, key);
	}

	_baseHas = baseHas;
	return _baseHas;
}

var has_1;
var hasRequiredHas;

function requireHas () {
	if (hasRequiredHas) return has_1;
	hasRequiredHas = 1;
	var baseHas = require_baseHas(),
	    hasPath = require_hasPath();

	/**
	 * Checks if `path` is a direct property of `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = { 'a': { 'b': 2 } };
	 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.has(object, 'a');
	 * // => true
	 *
	 * _.has(object, 'a.b');
	 * // => true
	 *
	 * _.has(object, ['a', 'b']);
	 * // => true
	 *
	 * _.has(other, 'a');
	 * // => false
	 */
	function has(object, path) {
	  return object != null && hasPath(object, path, baseHas);
	}

	has_1 = has;
	return has_1;
}

var isEmpty_1;
var hasRequiredIsEmpty;

function requireIsEmpty () {
	if (hasRequiredIsEmpty) return isEmpty_1;
	hasRequiredIsEmpty = 1;
	var baseKeys = require_baseKeys(),
	    getTag = require_getTag(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isArrayLike = requireIsArrayLike(),
	    isBuffer = requireIsBuffer(),
	    isPrototype = require_isPrototype(),
	    isTypedArray = requireIsTypedArray();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if `value` is an empty object, collection, map, or set.
	 *
	 * Objects are considered empty if they have no own enumerable string keyed
	 * properties.
	 *
	 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	 * jQuery-like collections are considered empty if they have a `length` of `0`.
	 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (value == null) {
	    return true;
	  }
	  if (isArrayLike(value) &&
	      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	    return !value.length;
	  }
	  var tag = getTag(value);
	  if (tag == mapTag || tag == setTag) {
	    return !value.size;
	  }
	  if (isPrototype(value)) {
	    return !baseKeys(value).length;
	  }
	  for (var key in value) {
	    if (hasOwnProperty.call(value, key)) {
	      return false;
	    }
	  }
	  return true;
	}

	isEmpty_1 = isEmpty;
	return isEmpty_1;
}

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */

var isUndefined_1;
var hasRequiredIsUndefined;

function requireIsUndefined () {
	if (hasRequiredIsUndefined) return isUndefined_1;
	hasRequiredIsUndefined = 1;
	function isUndefined(value) {
	  return value === undefined;
	}

	isUndefined_1 = isUndefined;
	return isUndefined_1;
}

var _baseMap;
var hasRequired_baseMap;

function require_baseMap () {
	if (hasRequired_baseMap) return _baseMap;
	hasRequired_baseMap = 1;
	var baseEach = require_baseEach(),
	    isArrayLike = requireIsArrayLike();

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	_baseMap = baseMap;
	return _baseMap;
}

var map_1;
var hasRequiredMap;

function requireMap () {
	if (hasRequiredMap) return map_1;
	hasRequiredMap = 1;
	var arrayMap = require_arrayMap(),
	    baseIteratee = require_baseIteratee(),
	    baseMap = require_baseMap(),
	    isArray = requireIsArray();

	/**
	 * Creates an array of values by running each element in `collection` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * _.map([4, 8], square);
	 * // => [16, 64]
	 *
	 * _.map({ 'a': 4, 'b': 8 }, square);
	 * // => [16, 64] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  return func(collection, baseIteratee(iteratee, 3));
	}

	map_1 = map;
	return map_1;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */

var _arrayReduce;
var hasRequired_arrayReduce;

function require_arrayReduce () {
	if (hasRequired_arrayReduce) return _arrayReduce;
	hasRequired_arrayReduce = 1;
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  if (initAccum && length) {
	    accumulator = array[++index];
	  }
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}

	_arrayReduce = arrayReduce;
	return _arrayReduce;
}

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */

var _baseReduce;
var hasRequired_baseReduce;

function require_baseReduce () {
	if (hasRequired_baseReduce) return _baseReduce;
	hasRequired_baseReduce = 1;
	function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	  eachFunc(collection, function(value, index, collection) {
	    accumulator = initAccum
	      ? (initAccum = false, value)
	      : iteratee(accumulator, value, index, collection);
	  });
	  return accumulator;
	}

	_baseReduce = baseReduce;
	return _baseReduce;
}

var reduce_1;
var hasRequiredReduce;

function requireReduce () {
	if (hasRequiredReduce) return reduce_1;
	hasRequiredReduce = 1;
	var arrayReduce = require_arrayReduce(),
	    baseEach = require_baseEach(),
	    baseIteratee = require_baseIteratee(),
	    baseReduce = require_baseReduce(),
	    isArray = requireIsArray();

	/**
	 * Reduces `collection` to a value which is the accumulated result of running
	 * each element in `collection` thru `iteratee`, where each successive
	 * invocation is supplied the return value of the previous. If `accumulator`
	 * is not given, the first element of `collection` is used as the initial
	 * value. The iteratee is invoked with four arguments:
	 * (accumulator, value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.reduce`, `_.reduceRight`, and `_.transform`.
	 *
	 * The guarded methods are:
	 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	 * and `sortBy`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @returns {*} Returns the accumulated value.
	 * @see _.reduceRight
	 * @example
	 *
	 * _.reduce([1, 2], function(sum, n) {
	 *   return sum + n;
	 * }, 0);
	 * // => 3
	 *
	 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	 *   (result[value] || (result[value] = [])).push(key);
	 *   return result;
	 * }, {});
	 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	 */
	function reduce(collection, iteratee, accumulator) {
	  var func = isArray(collection) ? arrayReduce : baseReduce,
	      initAccum = arguments.length < 3;

	  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	}

	reduce_1 = reduce;
	return reduce_1;
}

var isString_1;
var hasRequiredIsString;

function requireIsString () {
	if (hasRequiredIsString) return isString_1;
	hasRequiredIsString = 1;
	var baseGetTag = require_baseGetTag(),
	    isArray = requireIsArray(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var stringTag = '[object String]';

	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	}

	isString_1 = isString;
	return isString_1;
}

var _asciiSize;
var hasRequired_asciiSize;

function require_asciiSize () {
	if (hasRequired_asciiSize) return _asciiSize;
	hasRequired_asciiSize = 1;
	var baseProperty = require_baseProperty();

	/**
	 * Gets the size of an ASCII `string`.
	 *
	 * @private
	 * @param {string} string The string inspect.
	 * @returns {number} Returns the string size.
	 */
	var asciiSize = baseProperty('length');

	_asciiSize = asciiSize;
	return _asciiSize;
}

/** Used to compose unicode character classes. */

var _hasUnicode;
var hasRequired_hasUnicode;

function require_hasUnicode () {
	if (hasRequired_hasUnicode) return _hasUnicode;
	hasRequired_hasUnicode = 1;
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f',
	    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange = '\\u20d0-\\u20ff',
	    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	    rsVarRange = '\\ufe0e\\ufe0f';

	/** Used to compose unicode capture groups. */
	var rsZWJ = '\\u200d';

	/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

	/**
	 * Checks if `string` contains Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	 */
	function hasUnicode(string) {
	  return reHasUnicode.test(string);
	}

	_hasUnicode = hasUnicode;
	return _hasUnicode;
}

/** Used to compose unicode character classes. */

var _unicodeSize;
var hasRequired_unicodeSize;

function require_unicodeSize () {
	if (hasRequired_unicodeSize) return _unicodeSize;
	hasRequired_unicodeSize = 1;
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f',
	    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange = '\\u20d0-\\u20ff',
	    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	    rsVarRange = '\\ufe0e\\ufe0f';

	/** Used to compose unicode capture groups. */
	var rsAstral = '[' + rsAstralRange + ']',
	    rsCombo = '[' + rsComboRange + ']',
	    rsFitz = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	    rsNonAstral = '[^' + rsAstralRange + ']',
	    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsZWJ = '\\u200d';

	/** Used to compose unicode regexes. */
	var reOptMod = rsModifier + '?',
	    rsOptVar = '[' + rsVarRange + ']?',
	    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	    rsSeq = rsOptVar + reOptMod + rsOptJoin,
	    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	/**
	 * Gets the size of a Unicode `string`.
	 *
	 * @private
	 * @param {string} string The string inspect.
	 * @returns {number} Returns the string size.
	 */
	function unicodeSize(string) {
	  var result = reUnicode.lastIndex = 0;
	  while (reUnicode.test(string)) {
	    ++result;
	  }
	  return result;
	}

	_unicodeSize = unicodeSize;
	return _unicodeSize;
}

var _stringSize;
var hasRequired_stringSize;

function require_stringSize () {
	if (hasRequired_stringSize) return _stringSize;
	hasRequired_stringSize = 1;
	var asciiSize = require_asciiSize(),
	    hasUnicode = require_hasUnicode(),
	    unicodeSize = require_unicodeSize();

	/**
	 * Gets the number of symbols in `string`.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {number} Returns the string size.
	 */
	function stringSize(string) {
	  return hasUnicode(string)
	    ? unicodeSize(string)
	    : asciiSize(string);
	}

	_stringSize = stringSize;
	return _stringSize;
}

var size_1;
var hasRequiredSize;

function requireSize () {
	if (hasRequiredSize) return size_1;
	hasRequiredSize = 1;
	var baseKeys = require_baseKeys(),
	    getTag = require_getTag(),
	    isArrayLike = requireIsArrayLike(),
	    isString = requireIsString(),
	    stringSize = require_stringSize();

	/** `Object#toString` result references. */
	var mapTag = '[object Map]',
	    setTag = '[object Set]';

	/**
	 * Gets the size of `collection` by returning its length for array-like
	 * values or the number of own enumerable string keyed properties for objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to inspect.
	 * @returns {number} Returns the collection size.
	 * @example
	 *
	 * _.size([1, 2, 3]);
	 * // => 3
	 *
	 * _.size({ 'a': 1, 'b': 2 });
	 * // => 2
	 *
	 * _.size('pebbles');
	 * // => 7
	 */
	function size(collection) {
	  if (collection == null) {
	    return 0;
	  }
	  if (isArrayLike(collection)) {
	    return isString(collection) ? stringSize(collection) : collection.length;
	  }
	  var tag = getTag(collection);
	  if (tag == mapTag || tag == setTag) {
	    return collection.size;
	  }
	  return baseKeys(collection).length;
	}

	size_1 = size;
	return size_1;
}

var transform_1;
var hasRequiredTransform;

function requireTransform () {
	if (hasRequiredTransform) return transform_1;
	hasRequiredTransform = 1;
	var arrayEach = require_arrayEach(),
	    baseCreate = require_baseCreate(),
	    baseForOwn = require_baseForOwn(),
	    baseIteratee = require_baseIteratee(),
	    getPrototype = require_getPrototype(),
	    isArray = requireIsArray(),
	    isBuffer = requireIsBuffer(),
	    isFunction = requireIsFunction(),
	    isObject = requireIsObject(),
	    isTypedArray = requireIsTypedArray();

	/**
	 * An alternative to `_.reduce`; this method transforms `object` to a new
	 * `accumulator` object which is the result of running each of its own
	 * enumerable string keyed properties thru `iteratee`, with each invocation
	 * potentially mutating the `accumulator` object. If `accumulator` is not
	 * provided, a new object with the same `[[Prototype]]` will be used. The
	 * iteratee is invoked with four arguments: (accumulator, value, key, object).
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.3.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The custom accumulator value.
	 * @returns {*} Returns the accumulated value.
	 * @example
	 *
	 * _.transform([2, 3, 4], function(result, n) {
	 *   result.push(n *= n);
	 *   return n % 2 == 0;
	 * }, []);
	 * // => [4, 9]
	 *
	 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	 *   (result[value] || (result[value] = [])).push(key);
	 * }, {});
	 * // => { '1': ['a', 'c'], '2': ['b'] }
	 */
	function transform(object, iteratee, accumulator) {
	  var isArr = isArray(object),
	      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

	  iteratee = baseIteratee(iteratee, 4);
	  if (accumulator == null) {
	    var Ctor = object && object.constructor;
	    if (isArrLike) {
	      accumulator = isArr ? new Ctor : [];
	    }
	    else if (isObject(object)) {
	      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	    }
	    else {
	      accumulator = {};
	    }
	  }
	  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	    return iteratee(accumulator, value, index, object);
	  });
	  return accumulator;
	}

	transform_1 = transform;
	return transform_1;
}

var _isFlattenable;
var hasRequired_isFlattenable;

function require_isFlattenable () {
	if (hasRequired_isFlattenable) return _isFlattenable;
	hasRequired_isFlattenable = 1;
	var Symbol = require_Symbol(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray();

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	_isFlattenable = isFlattenable;
	return _isFlattenable;
}

var _baseFlatten;
var hasRequired_baseFlatten;

function require_baseFlatten () {
	if (hasRequired_baseFlatten) return _baseFlatten;
	hasRequired_baseFlatten = 1;
	var arrayPush = require_arrayPush(),
	    isFlattenable = require_isFlattenable();

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	_baseFlatten = baseFlatten;
	return _baseFlatten;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */

var _apply;
var hasRequired_apply;

function require_apply () {
	if (hasRequired_apply) return _apply;
	hasRequired_apply = 1;
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	_apply = apply;
	return _apply;
}

var _overRest;
var hasRequired_overRest;

function require_overRest () {
	if (hasRequired_overRest) return _overRest;
	hasRequired_overRest = 1;
	var apply = require_apply();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	_overRest = overRest;
	return _overRest;
}

var _baseSetToString;
var hasRequired_baseSetToString;

function require_baseSetToString () {
	if (hasRequired_baseSetToString) return _baseSetToString;
	hasRequired_baseSetToString = 1;
	var constant = requireConstant(),
	    defineProperty = require_defineProperty(),
	    identity = requireIdentity();

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	_baseSetToString = baseSetToString;
	return _baseSetToString;
}

/** Used to detect hot functions by number of calls within a span of milliseconds. */

var _shortOut;
var hasRequired_shortOut;

function require_shortOut () {
	if (hasRequired_shortOut) return _shortOut;
	hasRequired_shortOut = 1;
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	_shortOut = shortOut;
	return _shortOut;
}

var _setToString;
var hasRequired_setToString;

function require_setToString () {
	if (hasRequired_setToString) return _setToString;
	hasRequired_setToString = 1;
	var baseSetToString = require_baseSetToString(),
	    shortOut = require_shortOut();

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	_setToString = setToString;
	return _setToString;
}

var _baseRest;
var hasRequired_baseRest;

function require_baseRest () {
	if (hasRequired_baseRest) return _baseRest;
	hasRequired_baseRest = 1;
	var identity = requireIdentity(),
	    overRest = require_overRest(),
	    setToString = require_setToString();

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	_baseRest = baseRest;
	return _baseRest;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

var _baseFindIndex;
var hasRequired_baseFindIndex;

function require_baseFindIndex () {
	if (hasRequired_baseFindIndex) return _baseFindIndex;
	hasRequired_baseFindIndex = 1;
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	_baseFindIndex = baseFindIndex;
	return _baseFindIndex;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */

var _baseIsNaN;
var hasRequired_baseIsNaN;

function require_baseIsNaN () {
	if (hasRequired_baseIsNaN) return _baseIsNaN;
	hasRequired_baseIsNaN = 1;
	function baseIsNaN(value) {
	  return value !== value;
	}

	_baseIsNaN = baseIsNaN;
	return _baseIsNaN;
}

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */

var _strictIndexOf;
var hasRequired_strictIndexOf;

function require_strictIndexOf () {
	if (hasRequired_strictIndexOf) return _strictIndexOf;
	hasRequired_strictIndexOf = 1;
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	_strictIndexOf = strictIndexOf;
	return _strictIndexOf;
}

var _baseIndexOf;
var hasRequired_baseIndexOf;

function require_baseIndexOf () {
	if (hasRequired_baseIndexOf) return _baseIndexOf;
	hasRequired_baseIndexOf = 1;
	var baseFindIndex = require_baseFindIndex(),
	    baseIsNaN = require_baseIsNaN(),
	    strictIndexOf = require_strictIndexOf();

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	_baseIndexOf = baseIndexOf;
	return _baseIndexOf;
}

var _arrayIncludes;
var hasRequired_arrayIncludes;

function require_arrayIncludes () {
	if (hasRequired_arrayIncludes) return _arrayIncludes;
	hasRequired_arrayIncludes = 1;
	var baseIndexOf = require_baseIndexOf();

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	_arrayIncludes = arrayIncludes;
	return _arrayIncludes;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */

var _arrayIncludesWith;
var hasRequired_arrayIncludesWith;

function require_arrayIncludesWith () {
	if (hasRequired_arrayIncludesWith) return _arrayIncludesWith;
	hasRequired_arrayIncludesWith = 1;
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	_arrayIncludesWith = arrayIncludesWith;
	return _arrayIncludesWith;
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */

var noop_1;
var hasRequiredNoop;

function requireNoop () {
	if (hasRequiredNoop) return noop_1;
	hasRequiredNoop = 1;
	function noop() {
	  // No operation performed.
	}

	noop_1 = noop;
	return noop_1;
}

var _createSet;
var hasRequired_createSet;

function require_createSet () {
	if (hasRequired_createSet) return _createSet;
	hasRequired_createSet = 1;
	var Set = require_Set(),
	    noop = requireNoop(),
	    setToArray = require_setToArray();

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	  return new Set(values);
	};

	_createSet = createSet;
	return _createSet;
}

var _baseUniq;
var hasRequired_baseUniq;

function require_baseUniq () {
	if (hasRequired_baseUniq) return _baseUniq;
	hasRequired_baseUniq = 1;
	var SetCache = require_SetCache(),
	    arrayIncludes = require_arrayIncludes(),
	    arrayIncludesWith = require_arrayIncludesWith(),
	    cacheHas = require_cacheHas(),
	    createSet = require_createSet(),
	    setToArray = require_setToArray();

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE) {
	    var set = iteratee ? null : createSet(array);
	    if (set) {
	      return setToArray(set);
	    }
	    isCommon = false;
	    includes = cacheHas;
	    seen = new SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	_baseUniq = baseUniq;
	return _baseUniq;
}

var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;

function requireIsArrayLikeObject () {
	if (hasRequiredIsArrayLikeObject) return isArrayLikeObject_1;
	hasRequiredIsArrayLikeObject = 1;
	var isArrayLike = requireIsArrayLike(),
	    isObjectLike = requireIsObjectLike();

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	isArrayLikeObject_1 = isArrayLikeObject;
	return isArrayLikeObject_1;
}

var union_1;
var hasRequiredUnion;

function requireUnion () {
	if (hasRequiredUnion) return union_1;
	hasRequiredUnion = 1;
	var baseFlatten = require_baseFlatten(),
	    baseRest = require_baseRest(),
	    baseUniq = require_baseUniq(),
	    isArrayLikeObject = requireIsArrayLikeObject();

	/**
	 * Creates an array of unique values, in order, from all given arrays using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @returns {Array} Returns the new array of combined values.
	 * @example
	 *
	 * _.union([2], [1, 2]);
	 * // => [2, 1]
	 */
	var union = baseRest(function(arrays) {
	  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	});

	union_1 = union;
	return union_1;
}

var _baseValues;
var hasRequired_baseValues;

function require_baseValues () {
	if (hasRequired_baseValues) return _baseValues;
	hasRequired_baseValues = 1;
	var arrayMap = require_arrayMap();

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  return arrayMap(props, function(key) {
	    return object[key];
	  });
	}

	_baseValues = baseValues;
	return _baseValues;
}

var values_1;
var hasRequiredValues;

function requireValues () {
	if (hasRequiredValues) return values_1;
	hasRequiredValues = 1;
	var baseValues = require_baseValues(),
	    keys = requireKeys();

	/**
	 * Creates an array of the own enumerable string keyed property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return object == null ? [] : baseValues(object, keys(object));
	}

	values_1 = values;
	return values_1;
}

/* global window */

var lodash_1$1;
var hasRequiredLodash$1;

function requireLodash$1 () {
	if (hasRequiredLodash$1) return lodash_1$1;
	hasRequiredLodash$1 = 1;
	var lodash;

	if (typeof commonjsRequire === "function") {
	  try {
	    lodash = {
	      clone: requireClone(),
	      constant: requireConstant(),
	      each: requireEach(),
	      filter: requireFilter(),
	      has:  requireHas(),
	      isArray: requireIsArray(),
	      isEmpty: requireIsEmpty(),
	      isFunction: requireIsFunction(),
	      isUndefined: requireIsUndefined(),
	      keys: requireKeys(),
	      map: requireMap(),
	      reduce: requireReduce(),
	      size: requireSize(),
	      transform: requireTransform(),
	      union: requireUnion(),
	      values: requireValues()
	    };
	  } catch (e) {
	    // continue regardless of error
	  }
	}

	if (!lodash) {
	  lodash = window._;
	}

	lodash_1$1 = lodash;
	return lodash_1$1;
}

var graph;
var hasRequiredGraph;

function requireGraph () {
	if (hasRequiredGraph) return graph;
	hasRequiredGraph = 1;

	var _ = requireLodash$1();

	graph = Graph;

	var DEFAULT_EDGE_NAME = "\x00";
	var GRAPH_NODE = "\x00";
	var EDGE_KEY_DELIM = "\x01";

	// Implementation notes:
	//
	//  * Node id query functions should return string ids for the nodes
	//  * Edge id query functions should return an "edgeObj", edge object, that is
	//    composed of enough information to uniquely identify an edge: {v, w, name}.
	//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
	//    reference edges. This is because we need a performant way to look these
	//    edges up and, object properties, which have string keys, are the closest
	//    we're going to get to a performant hashtable in JavaScript.

	function Graph(opts) {
	  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
	  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
	  this._isCompound = _.has(opts, "compound") ? opts.compound : false;

	  // Label for the graph itself
	  this._label = undefined;

	  // Defaults to be set when creating a new node
	  this._defaultNodeLabelFn = _.constant(undefined);

	  // Defaults to be set when creating a new edge
	  this._defaultEdgeLabelFn = _.constant(undefined);

	  // v -> label
	  this._nodes = {};

	  if (this._isCompound) {
	    // v -> parent
	    this._parent = {};

	    // v -> children
	    this._children = {};
	    this._children[GRAPH_NODE] = {};
	  }

	  // v -> edgeObj
	  this._in = {};

	  // u -> v -> Number
	  this._preds = {};

	  // v -> edgeObj
	  this._out = {};

	  // v -> w -> Number
	  this._sucs = {};

	  // e -> edgeObj
	  this._edgeObjs = {};

	  // e -> label
	  this._edgeLabels = {};
	}

	/* Number of nodes in the graph. Should only be changed by the implementation. */
	Graph.prototype._nodeCount = 0;

	/* Number of edges in the graph. Should only be changed by the implementation. */
	Graph.prototype._edgeCount = 0;


	/* === Graph functions ========= */

	Graph.prototype.isDirected = function() {
	  return this._isDirected;
	};

	Graph.prototype.isMultigraph = function() {
	  return this._isMultigraph;
	};

	Graph.prototype.isCompound = function() {
	  return this._isCompound;
	};

	Graph.prototype.setGraph = function(label) {
	  this._label = label;
	  return this;
	};

	Graph.prototype.graph = function() {
	  return this._label;
	};


	/* === Node functions ========== */

	Graph.prototype.setDefaultNodeLabel = function(newDefault) {
	  if (!_.isFunction(newDefault)) {
	    newDefault = _.constant(newDefault);
	  }
	  this._defaultNodeLabelFn = newDefault;
	  return this;
	};

	Graph.prototype.nodeCount = function() {
	  return this._nodeCount;
	};

	Graph.prototype.nodes = function() {
	  return _.keys(this._nodes);
	};

	Graph.prototype.sources = function() {
	  var self = this;
	  return _.filter(this.nodes(), function(v) {
	    return _.isEmpty(self._in[v]);
	  });
	};

	Graph.prototype.sinks = function() {
	  var self = this;
	  return _.filter(this.nodes(), function(v) {
	    return _.isEmpty(self._out[v]);
	  });
	};

	Graph.prototype.setNodes = function(vs, value) {
	  var args = arguments;
	  var self = this;
	  _.each(vs, function(v) {
	    if (args.length > 1) {
	      self.setNode(v, value);
	    } else {
	      self.setNode(v);
	    }
	  });
	  return this;
	};

	Graph.prototype.setNode = function(v, value) {
	  if (_.has(this._nodes, v)) {
	    if (arguments.length > 1) {
	      this._nodes[v] = value;
	    }
	    return this;
	  }

	  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
	  if (this._isCompound) {
	    this._parent[v] = GRAPH_NODE;
	    this._children[v] = {};
	    this._children[GRAPH_NODE][v] = true;
	  }
	  this._in[v] = {};
	  this._preds[v] = {};
	  this._out[v] = {};
	  this._sucs[v] = {};
	  ++this._nodeCount;
	  return this;
	};

	Graph.prototype.node = function(v) {
	  return this._nodes[v];
	};

	Graph.prototype.hasNode = function(v) {
	  return _.has(this._nodes, v);
	};

	Graph.prototype.removeNode =  function(v) {
	  var self = this;
	  if (_.has(this._nodes, v)) {
	    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };
	    delete this._nodes[v];
	    if (this._isCompound) {
	      this._removeFromParentsChildList(v);
	      delete this._parent[v];
	      _.each(this.children(v), function(child) {
	        self.setParent(child);
	      });
	      delete this._children[v];
	    }
	    _.each(_.keys(this._in[v]), removeEdge);
	    delete this._in[v];
	    delete this._preds[v];
	    _.each(_.keys(this._out[v]), removeEdge);
	    delete this._out[v];
	    delete this._sucs[v];
	    --this._nodeCount;
	  }
	  return this;
	};

	Graph.prototype.setParent = function(v, parent) {
	  if (!this._isCompound) {
	    throw new Error("Cannot set parent in a non-compound graph");
	  }

	  if (_.isUndefined(parent)) {
	    parent = GRAPH_NODE;
	  } else {
	    // Coerce parent to string
	    parent += "";
	    for (var ancestor = parent;
	      !_.isUndefined(ancestor);
	      ancestor = this.parent(ancestor)) {
	      if (ancestor === v) {
	        throw new Error("Setting " + parent+ " as parent of " + v +
	                        " would create a cycle");
	      }
	    }

	    this.setNode(parent);
	  }

	  this.setNode(v);
	  this._removeFromParentsChildList(v);
	  this._parent[v] = parent;
	  this._children[parent][v] = true;
	  return this;
	};

	Graph.prototype._removeFromParentsChildList = function(v) {
	  delete this._children[this._parent[v]][v];
	};

	Graph.prototype.parent = function(v) {
	  if (this._isCompound) {
	    var parent = this._parent[v];
	    if (parent !== GRAPH_NODE) {
	      return parent;
	    }
	  }
	};

	Graph.prototype.children = function(v) {
	  if (_.isUndefined(v)) {
	    v = GRAPH_NODE;
	  }

	  if (this._isCompound) {
	    var children = this._children[v];
	    if (children) {
	      return _.keys(children);
	    }
	  } else if (v === GRAPH_NODE) {
	    return this.nodes();
	  } else if (this.hasNode(v)) {
	    return [];
	  }
	};

	Graph.prototype.predecessors = function(v) {
	  var predsV = this._preds[v];
	  if (predsV) {
	    return _.keys(predsV);
	  }
	};

	Graph.prototype.successors = function(v) {
	  var sucsV = this._sucs[v];
	  if (sucsV) {
	    return _.keys(sucsV);
	  }
	};

	Graph.prototype.neighbors = function(v) {
	  var preds = this.predecessors(v);
	  if (preds) {
	    return _.union(preds, this.successors(v));
	  }
	};

	Graph.prototype.isLeaf = function (v) {
	  var neighbors;
	  if (this.isDirected()) {
	    neighbors = this.successors(v);
	  } else {
	    neighbors = this.neighbors(v);
	  }
	  return neighbors.length === 0;
	};

	Graph.prototype.filterNodes = function(filter) {
	  var copy = new this.constructor({
	    directed: this._isDirected,
	    multigraph: this._isMultigraph,
	    compound: this._isCompound
	  });

	  copy.setGraph(this.graph());

	  var self = this;
	  _.each(this._nodes, function(value, v) {
	    if (filter(v)) {
	      copy.setNode(v, value);
	    }
	  });

	  _.each(this._edgeObjs, function(e) {
	    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
	      copy.setEdge(e, self.edge(e));
	    }
	  });

	  var parents = {};
	  function findParent(v) {
	    var parent = self.parent(v);
	    if (parent === undefined || copy.hasNode(parent)) {
	      parents[v] = parent;
	      return parent;
	    } else if (parent in parents) {
	      return parents[parent];
	    } else {
	      return findParent(parent);
	    }
	  }

	  if (this._isCompound) {
	    _.each(copy.nodes(), function(v) {
	      copy.setParent(v, findParent(v));
	    });
	  }

	  return copy;
	};

	/* === Edge functions ========== */

	Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
	  if (!_.isFunction(newDefault)) {
	    newDefault = _.constant(newDefault);
	  }
	  this._defaultEdgeLabelFn = newDefault;
	  return this;
	};

	Graph.prototype.edgeCount = function() {
	  return this._edgeCount;
	};

	Graph.prototype.edges = function() {
	  return _.values(this._edgeObjs);
	};

	Graph.prototype.setPath = function(vs, value) {
	  var self = this;
	  var args = arguments;
	  _.reduce(vs, function(v, w) {
	    if (args.length > 1) {
	      self.setEdge(v, w, value);
	    } else {
	      self.setEdge(v, w);
	    }
	    return w;
	  });
	  return this;
	};

	/*
	 * setEdge(v, w, [value, [name]])
	 * setEdge({ v, w, [name] }, [value])
	 */
	Graph.prototype.setEdge = function() {
	  var v, w, name, value;
	  var valueSpecified = false;
	  var arg0 = arguments[0];

	  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
	    v = arg0.v;
	    w = arg0.w;
	    name = arg0.name;
	    if (arguments.length === 2) {
	      value = arguments[1];
	      valueSpecified = true;
	    }
	  } else {
	    v = arg0;
	    w = arguments[1];
	    name = arguments[3];
	    if (arguments.length > 2) {
	      value = arguments[2];
	      valueSpecified = true;
	    }
	  }

	  v = "" + v;
	  w = "" + w;
	  if (!_.isUndefined(name)) {
	    name = "" + name;
	  }

	  var e = edgeArgsToId(this._isDirected, v, w, name);
	  if (_.has(this._edgeLabels, e)) {
	    if (valueSpecified) {
	      this._edgeLabels[e] = value;
	    }
	    return this;
	  }

	  if (!_.isUndefined(name) && !this._isMultigraph) {
	    throw new Error("Cannot set a named edge when isMultigraph = false");
	  }

	  // It didn't exist, so we need to create it.
	  // First ensure the nodes exist.
	  this.setNode(v);
	  this.setNode(w);

	  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);

	  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
	  // Ensure we add undirected edges in a consistent way.
	  v = edgeObj.v;
	  w = edgeObj.w;

	  Object.freeze(edgeObj);
	  this._edgeObjs[e] = edgeObj;
	  incrementOrInitEntry(this._preds[w], v);
	  incrementOrInitEntry(this._sucs[v], w);
	  this._in[w][e] = edgeObj;
	  this._out[v][e] = edgeObj;
	  this._edgeCount++;
	  return this;
	};

	Graph.prototype.edge = function(v, w, name) {
	  var e = (arguments.length === 1
	    ? edgeObjToId(this._isDirected, arguments[0])
	    : edgeArgsToId(this._isDirected, v, w, name));
	  return this._edgeLabels[e];
	};

	Graph.prototype.hasEdge = function(v, w, name) {
	  var e = (arguments.length === 1
	    ? edgeObjToId(this._isDirected, arguments[0])
	    : edgeArgsToId(this._isDirected, v, w, name));
	  return _.has(this._edgeLabels, e);
	};

	Graph.prototype.removeEdge = function(v, w, name) {
	  var e = (arguments.length === 1
	    ? edgeObjToId(this._isDirected, arguments[0])
	    : edgeArgsToId(this._isDirected, v, w, name));
	  var edge = this._edgeObjs[e];
	  if (edge) {
	    v = edge.v;
	    w = edge.w;
	    delete this._edgeLabels[e];
	    delete this._edgeObjs[e];
	    decrementOrRemoveEntry(this._preds[w], v);
	    decrementOrRemoveEntry(this._sucs[v], w);
	    delete this._in[w][e];
	    delete this._out[v][e];
	    this._edgeCount--;
	  }
	  return this;
	};

	Graph.prototype.inEdges = function(v, u) {
	  var inV = this._in[v];
	  if (inV) {
	    var edges = _.values(inV);
	    if (!u) {
	      return edges;
	    }
	    return _.filter(edges, function(edge) { return edge.v === u; });
	  }
	};

	Graph.prototype.outEdges = function(v, w) {
	  var outV = this._out[v];
	  if (outV) {
	    var edges = _.values(outV);
	    if (!w) {
	      return edges;
	    }
	    return _.filter(edges, function(edge) { return edge.w === w; });
	  }
	};

	Graph.prototype.nodeEdges = function(v, w) {
	  var inEdges = this.inEdges(v, w);
	  if (inEdges) {
	    return inEdges.concat(this.outEdges(v, w));
	  }
	};

	function incrementOrInitEntry(map, k) {
	  if (map[k]) {
	    map[k]++;
	  } else {
	    map[k] = 1;
	  }
	}

	function decrementOrRemoveEntry(map, k) {
	  if (!--map[k]) { delete map[k]; }
	}

	function edgeArgsToId(isDirected, v_, w_, name) {
	  var v = "" + v_;
	  var w = "" + w_;
	  if (!isDirected && v > w) {
	    var tmp = v;
	    v = w;
	    w = tmp;
	  }
	  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
	             (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
	}

	function edgeArgsToObj(isDirected, v_, w_, name) {
	  var v = "" + v_;
	  var w = "" + w_;
	  if (!isDirected && v > w) {
	    var tmp = v;
	    v = w;
	    w = tmp;
	  }
	  var edgeObj =  { v: v, w: w };
	  if (name) {
	    edgeObj.name = name;
	  }
	  return edgeObj;
	}

	function edgeObjToId(isDirected, edgeObj) {
	  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
	}
	return graph;
}

var version$1;
var hasRequiredVersion$1;

function requireVersion$1 () {
	if (hasRequiredVersion$1) return version$1;
	hasRequiredVersion$1 = 1;
	version$1 = '2.1.8';
	return version$1;
}

var lib;
var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	// Includes only the "core" of graphlib
	lib = {
	  Graph: requireGraph(),
	  version: requireVersion$1()
	};
	return lib;
}

var json;
var hasRequiredJson;

function requireJson () {
	if (hasRequiredJson) return json;
	hasRequiredJson = 1;
	var _ = requireLodash$1();
	var Graph = requireGraph();

	json = {
	  write: write,
	  read: read
	};

	function write(g) {
	  var json = {
	    options: {
	      directed: g.isDirected(),
	      multigraph: g.isMultigraph(),
	      compound: g.isCompound()
	    },
	    nodes: writeNodes(g),
	    edges: writeEdges(g)
	  };
	  if (!_.isUndefined(g.graph())) {
	    json.value = _.clone(g.graph());
	  }
	  return json;
	}

	function writeNodes(g) {
	  return _.map(g.nodes(), function(v) {
	    var nodeValue = g.node(v);
	    var parent = g.parent(v);
	    var node = { v: v };
	    if (!_.isUndefined(nodeValue)) {
	      node.value = nodeValue;
	    }
	    if (!_.isUndefined(parent)) {
	      node.parent = parent;
	    }
	    return node;
	  });
	}

	function writeEdges(g) {
	  return _.map(g.edges(), function(e) {
	    var edgeValue = g.edge(e);
	    var edge = { v: e.v, w: e.w };
	    if (!_.isUndefined(e.name)) {
	      edge.name = e.name;
	    }
	    if (!_.isUndefined(edgeValue)) {
	      edge.value = edgeValue;
	    }
	    return edge;
	  });
	}

	function read(json) {
	  var g = new Graph(json.options).setGraph(json.value);
	  _.each(json.nodes, function(entry) {
	    g.setNode(entry.v, entry.value);
	    if (entry.parent) {
	      g.setParent(entry.v, entry.parent);
	    }
	  });
	  _.each(json.edges, function(entry) {
	    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
	  });
	  return g;
	}
	return json;
}

var components_1;
var hasRequiredComponents;

function requireComponents () {
	if (hasRequiredComponents) return components_1;
	hasRequiredComponents = 1;
	var _ = requireLodash$1();

	components_1 = components;

	function components(g) {
	  var visited = {};
	  var cmpts = [];
	  var cmpt;

	  function dfs(v) {
	    if (_.has(visited, v)) return;
	    visited[v] = true;
	    cmpt.push(v);
	    _.each(g.successors(v), dfs);
	    _.each(g.predecessors(v), dfs);
	  }

	  _.each(g.nodes(), function(v) {
	    cmpt = [];
	    dfs(v);
	    if (cmpt.length) {
	      cmpts.push(cmpt);
	    }
	  });

	  return cmpts;
	}
	return components_1;
}

var priorityQueue;
var hasRequiredPriorityQueue;

function requirePriorityQueue () {
	if (hasRequiredPriorityQueue) return priorityQueue;
	hasRequiredPriorityQueue = 1;
	var _ = requireLodash$1();

	priorityQueue = PriorityQueue;

	/**
	 * A min-priority queue data structure. This algorithm is derived from Cormen,
	 * et al., "Introduction to Algorithms". The basic idea of a min-priority
	 * queue is that you can efficiently (in O(1) time) get the smallest key in
	 * the queue. Adding and removing elements takes O(log n) time. A key can
	 * have its priority decreased in O(log n) time.
	 */
	function PriorityQueue() {
	  this._arr = [];
	  this._keyIndices = {};
	}

	/**
	 * Returns the number of elements in the queue. Takes `O(1)` time.
	 */
	PriorityQueue.prototype.size = function() {
	  return this._arr.length;
	};

	/**
	 * Returns the keys that are in the queue. Takes `O(n)` time.
	 */
	PriorityQueue.prototype.keys = function() {
	  return this._arr.map(function(x) { return x.key; });
	};

	/**
	 * Returns `true` if **key** is in the queue and `false` if not.
	 */
	PriorityQueue.prototype.has = function(key) {
	  return _.has(this._keyIndices, key);
	};

	/**
	 * Returns the priority for **key**. If **key** is not present in the queue
	 * then this function returns `undefined`. Takes `O(1)` time.
	 *
	 * @param {Object} key
	 */
	PriorityQueue.prototype.priority = function(key) {
	  var index = this._keyIndices[key];
	  if (index !== undefined) {
	    return this._arr[index].priority;
	  }
	};

	/**
	 * Returns the key for the minimum element in this queue. If the queue is
	 * empty this function throws an Error. Takes `O(1)` time.
	 */
	PriorityQueue.prototype.min = function() {
	  if (this.size() === 0) {
	    throw new Error("Queue underflow");
	  }
	  return this._arr[0].key;
	};

	/**
	 * Inserts a new key into the priority queue. If the key already exists in
	 * the queue this function returns `false`; otherwise it will return `true`.
	 * Takes `O(n)` time.
	 *
	 * @param {Object} key the key to add
	 * @param {Number} priority the initial priority for the key
	 */
	PriorityQueue.prototype.add = function(key, priority) {
	  var keyIndices = this._keyIndices;
	  key = String(key);
	  if (!_.has(keyIndices, key)) {
	    var arr = this._arr;
	    var index = arr.length;
	    keyIndices[key] = index;
	    arr.push({key: key, priority: priority});
	    this._decrease(index);
	    return true;
	  }
	  return false;
	};

	/**
	 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
	 */
	PriorityQueue.prototype.removeMin = function() {
	  this._swap(0, this._arr.length - 1);
	  var min = this._arr.pop();
	  delete this._keyIndices[min.key];
	  this._heapify(0);
	  return min.key;
	};

	/**
	 * Decreases the priority for **key** to **priority**. If the new priority is
	 * greater than the previous priority, this function will throw an Error.
	 *
	 * @param {Object} key the key for which to raise priority
	 * @param {Number} priority the new priority for the key
	 */
	PriorityQueue.prototype.decrease = function(key, priority) {
	  var index = this._keyIndices[key];
	  if (priority > this._arr[index].priority) {
	    throw new Error("New priority is greater than current priority. " +
	        "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
	  }
	  this._arr[index].priority = priority;
	  this._decrease(index);
	};

	PriorityQueue.prototype._heapify = function(i) {
	  var arr = this._arr;
	  var l = 2 * i;
	  var r = l + 1;
	  var largest = i;
	  if (l < arr.length) {
	    largest = arr[l].priority < arr[largest].priority ? l : largest;
	    if (r < arr.length) {
	      largest = arr[r].priority < arr[largest].priority ? r : largest;
	    }
	    if (largest !== i) {
	      this._swap(i, largest);
	      this._heapify(largest);
	    }
	  }
	};

	PriorityQueue.prototype._decrease = function(index) {
	  var arr = this._arr;
	  var priority = arr[index].priority;
	  var parent;
	  while (index !== 0) {
	    parent = index >> 1;
	    if (arr[parent].priority < priority) {
	      break;
	    }
	    this._swap(index, parent);
	    index = parent;
	  }
	};

	PriorityQueue.prototype._swap = function(i, j) {
	  var arr = this._arr;
	  var keyIndices = this._keyIndices;
	  var origArrI = arr[i];
	  var origArrJ = arr[j];
	  arr[i] = origArrJ;
	  arr[j] = origArrI;
	  keyIndices[origArrJ.key] = i;
	  keyIndices[origArrI.key] = j;
	};
	return priorityQueue;
}

var dijkstra_1;
var hasRequiredDijkstra;

function requireDijkstra () {
	if (hasRequiredDijkstra) return dijkstra_1;
	hasRequiredDijkstra = 1;
	var _ = requireLodash$1();
	var PriorityQueue = requirePriorityQueue();

	dijkstra_1 = dijkstra;

	var DEFAULT_WEIGHT_FUNC = _.constant(1);

	function dijkstra(g, source, weightFn, edgeFn) {
	  return runDijkstra(g, String(source),
	    weightFn || DEFAULT_WEIGHT_FUNC,
	    edgeFn || function(v) { return g.outEdges(v); });
	}

	function runDijkstra(g, source, weightFn, edgeFn) {
	  var results = {};
	  var pq = new PriorityQueue();
	  var v, vEntry;

	  var updateNeighbors = function(edge) {
	    var w = edge.v !== v ? edge.v : edge.w;
	    var wEntry = results[w];
	    var weight = weightFn(edge);
	    var distance = vEntry.distance + weight;

	    if (weight < 0) {
	      throw new Error("dijkstra does not allow negative edge weights. " +
	                      "Bad edge: " + edge + " Weight: " + weight);
	    }

	    if (distance < wEntry.distance) {
	      wEntry.distance = distance;
	      wEntry.predecessor = v;
	      pq.decrease(w, distance);
	    }
	  };

	  g.nodes().forEach(function(v) {
	    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
	    results[v] = { distance: distance };
	    pq.add(v, distance);
	  });

	  while (pq.size() > 0) {
	    v = pq.removeMin();
	    vEntry = results[v];
	    if (vEntry.distance === Number.POSITIVE_INFINITY) {
	      break;
	    }

	    edgeFn(v).forEach(updateNeighbors);
	  }

	  return results;
	}
	return dijkstra_1;
}

var dijkstraAll_1;
var hasRequiredDijkstraAll;

function requireDijkstraAll () {
	if (hasRequiredDijkstraAll) return dijkstraAll_1;
	hasRequiredDijkstraAll = 1;
	var dijkstra = requireDijkstra();
	var _ = requireLodash$1();

	dijkstraAll_1 = dijkstraAll;

	function dijkstraAll(g, weightFunc, edgeFunc) {
	  return _.transform(g.nodes(), function(acc, v) {
	    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
	  }, {});
	}
	return dijkstraAll_1;
}

var tarjan_1;
var hasRequiredTarjan;

function requireTarjan () {
	if (hasRequiredTarjan) return tarjan_1;
	hasRequiredTarjan = 1;
	var _ = requireLodash$1();

	tarjan_1 = tarjan;

	function tarjan(g) {
	  var index = 0;
	  var stack = [];
	  var visited = {}; // node id -> { onStack, lowlink, index }
	  var results = [];

	  function dfs(v) {
	    var entry = visited[v] = {
	      onStack: true,
	      lowlink: index,
	      index: index++
	    };
	    stack.push(v);

	    g.successors(v).forEach(function(w) {
	      if (!_.has(visited, w)) {
	        dfs(w);
	        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
	      } else if (visited[w].onStack) {
	        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
	      }
	    });

	    if (entry.lowlink === entry.index) {
	      var cmpt = [];
	      var w;
	      do {
	        w = stack.pop();
	        visited[w].onStack = false;
	        cmpt.push(w);
	      } while (v !== w);
	      results.push(cmpt);
	    }
	  }

	  g.nodes().forEach(function(v) {
	    if (!_.has(visited, v)) {
	      dfs(v);
	    }
	  });

	  return results;
	}
	return tarjan_1;
}

var findCycles_1;
var hasRequiredFindCycles;

function requireFindCycles () {
	if (hasRequiredFindCycles) return findCycles_1;
	hasRequiredFindCycles = 1;
	var _ = requireLodash$1();
	var tarjan = requireTarjan();

	findCycles_1 = findCycles;

	function findCycles(g) {
	  return _.filter(tarjan(g), function(cmpt) {
	    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
	  });
	}
	return findCycles_1;
}

var floydWarshall_1;
var hasRequiredFloydWarshall;

function requireFloydWarshall () {
	if (hasRequiredFloydWarshall) return floydWarshall_1;
	hasRequiredFloydWarshall = 1;
	var _ = requireLodash$1();

	floydWarshall_1 = floydWarshall;

	var DEFAULT_WEIGHT_FUNC = _.constant(1);

	function floydWarshall(g, weightFn, edgeFn) {
	  return runFloydWarshall(g,
	    weightFn || DEFAULT_WEIGHT_FUNC,
	    edgeFn || function(v) { return g.outEdges(v); });
	}

	function runFloydWarshall(g, weightFn, edgeFn) {
	  var results = {};
	  var nodes = g.nodes();

	  nodes.forEach(function(v) {
	    results[v] = {};
	    results[v][v] = { distance: 0 };
	    nodes.forEach(function(w) {
	      if (v !== w) {
	        results[v][w] = { distance: Number.POSITIVE_INFINITY };
	      }
	    });
	    edgeFn(v).forEach(function(edge) {
	      var w = edge.v === v ? edge.w : edge.v;
	      var d = weightFn(edge);
	      results[v][w] = { distance: d, predecessor: v };
	    });
	  });

	  nodes.forEach(function(k) {
	    var rowK = results[k];
	    nodes.forEach(function(i) {
	      var rowI = results[i];
	      nodes.forEach(function(j) {
	        var ik = rowI[k];
	        var kj = rowK[j];
	        var ij = rowI[j];
	        var altDistance = ik.distance + kj.distance;
	        if (altDistance < ij.distance) {
	          ij.distance = altDistance;
	          ij.predecessor = kj.predecessor;
	        }
	      });
	    });
	  });

	  return results;
	}
	return floydWarshall_1;
}

var topsort_1;
var hasRequiredTopsort;

function requireTopsort () {
	if (hasRequiredTopsort) return topsort_1;
	hasRequiredTopsort = 1;
	var _ = requireLodash$1();

	topsort_1 = topsort;
	topsort.CycleException = CycleException;

	function topsort(g) {
	  var visited = {};
	  var stack = {};
	  var results = [];

	  function visit(node) {
	    if (_.has(stack, node)) {
	      throw new CycleException();
	    }

	    if (!_.has(visited, node)) {
	      stack[node] = true;
	      visited[node] = true;
	      _.each(g.predecessors(node), visit);
	      delete stack[node];
	      results.push(node);
	    }
	  }

	  _.each(g.sinks(), visit);

	  if (_.size(visited) !== g.nodeCount()) {
	    throw new CycleException();
	  }

	  return results;
	}

	function CycleException() {}
	CycleException.prototype = new Error(); // must be an instance of Error to pass testing
	return topsort_1;
}

var isAcyclic_1;
var hasRequiredIsAcyclic;

function requireIsAcyclic () {
	if (hasRequiredIsAcyclic) return isAcyclic_1;
	hasRequiredIsAcyclic = 1;
	var topsort = requireTopsort();

	isAcyclic_1 = isAcyclic;

	function isAcyclic(g) {
	  try {
	    topsort(g);
	  } catch (e) {
	    if (e instanceof topsort.CycleException) {
	      return false;
	    }
	    throw e;
	  }
	  return true;
	}
	return isAcyclic_1;
}

var dfs_1;
var hasRequiredDfs;

function requireDfs () {
	if (hasRequiredDfs) return dfs_1;
	hasRequiredDfs = 1;
	var _ = requireLodash$1();

	dfs_1 = dfs;

	/*
	 * A helper that preforms a pre- or post-order traversal on the input graph
	 * and returns the nodes in the order they were visited. If the graph is
	 * undirected then this algorithm will navigate using neighbors. If the graph
	 * is directed then this algorithm will navigate using successors.
	 *
	 * Order must be one of "pre" or "post".
	 */
	function dfs(g, vs, order) {
	  if (!_.isArray(vs)) {
	    vs = [vs];
	  }

	  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);

	  var acc = [];
	  var visited = {};
	  _.each(vs, function(v) {
	    if (!g.hasNode(v)) {
	      throw new Error("Graph does not have node: " + v);
	    }

	    doDfs(g, v, order === "post", visited, navigation, acc);
	  });
	  return acc;
	}

	function doDfs(g, v, postorder, visited, navigation, acc) {
	  if (!_.has(visited, v)) {
	    visited[v] = true;

	    if (!postorder) { acc.push(v); }
	    _.each(navigation(v), function(w) {
	      doDfs(g, w, postorder, visited, navigation, acc);
	    });
	    if (postorder) { acc.push(v); }
	  }
	}
	return dfs_1;
}

var postorder_1;
var hasRequiredPostorder;

function requirePostorder () {
	if (hasRequiredPostorder) return postorder_1;
	hasRequiredPostorder = 1;
	var dfs = requireDfs();

	postorder_1 = postorder;

	function postorder(g, vs) {
	  return dfs(g, vs, "post");
	}
	return postorder_1;
}

var preorder_1;
var hasRequiredPreorder;

function requirePreorder () {
	if (hasRequiredPreorder) return preorder_1;
	hasRequiredPreorder = 1;
	var dfs = requireDfs();

	preorder_1 = preorder;

	function preorder(g, vs) {
	  return dfs(g, vs, "pre");
	}
	return preorder_1;
}

var prim_1;
var hasRequiredPrim;

function requirePrim () {
	if (hasRequiredPrim) return prim_1;
	hasRequiredPrim = 1;
	var _ = requireLodash$1();
	var Graph = requireGraph();
	var PriorityQueue = requirePriorityQueue();

	prim_1 = prim;

	function prim(g, weightFunc) {
	  var result = new Graph();
	  var parents = {};
	  var pq = new PriorityQueue();
	  var v;

	  function updateNeighbors(edge) {
	    var w = edge.v === v ? edge.w : edge.v;
	    var pri = pq.priority(w);
	    if (pri !== undefined) {
	      var edgeWeight = weightFunc(edge);
	      if (edgeWeight < pri) {
	        parents[w] = v;
	        pq.decrease(w, edgeWeight);
	      }
	    }
	  }

	  if (g.nodeCount() === 0) {
	    return result;
	  }

	  _.each(g.nodes(), function(v) {
	    pq.add(v, Number.POSITIVE_INFINITY);
	    result.setNode(v);
	  });

	  // Start from an arbitrary node
	  pq.decrease(g.nodes()[0], 0);

	  var init = false;
	  while (pq.size() > 0) {
	    v = pq.removeMin();
	    if (_.has(parents, v)) {
	      result.setEdge(v, parents[v]);
	    } else if (init) {
	      throw new Error("Input graph is not connected: " + g);
	    } else {
	      init = true;
	    }

	    g.nodeEdges(v).forEach(updateNeighbors);
	  }

	  return result;
	}
	return prim_1;
}

var alg;
var hasRequiredAlg;

function requireAlg () {
	if (hasRequiredAlg) return alg;
	hasRequiredAlg = 1;
	alg = {
	  components: requireComponents(),
	  dijkstra: requireDijkstra(),
	  dijkstraAll: requireDijkstraAll(),
	  findCycles: requireFindCycles(),
	  floydWarshall: requireFloydWarshall(),
	  isAcyclic: requireIsAcyclic(),
	  postorder: requirePostorder(),
	  preorder: requirePreorder(),
	  prim: requirePrim(),
	  tarjan: requireTarjan(),
	  topsort: requireTopsort()
	};
	return alg;
}

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var graphlib;
var hasRequiredGraphlib$1;

function requireGraphlib$1 () {
	if (hasRequiredGraphlib$1) return graphlib;
	hasRequiredGraphlib$1 = 1;
	var lib = requireLib();

	graphlib = {
	  Graph: lib.Graph,
	  json: requireJson(),
	  alg: requireAlg(),
	  version: lib.version
	};
	return graphlib;
}

/* global window */

var graphlib_1;
var hasRequiredGraphlib;

function requireGraphlib () {
	if (hasRequiredGraphlib) return graphlib_1;
	hasRequiredGraphlib = 1;
	var graphlib;

	if (typeof commonjsRequire === "function") {
	  try {
	    graphlib = requireGraphlib$1();
	  } catch (e) {
	    // continue regardless of error
	  }
	}

	if (!graphlib) {
	  graphlib = window.graphlib;
	}

	graphlib_1 = graphlib;
	return graphlib_1;
}

var cloneDeep_1;
var hasRequiredCloneDeep;

function requireCloneDeep () {
	if (hasRequiredCloneDeep) return cloneDeep_1;
	hasRequiredCloneDeep = 1;
	var baseClone = require_baseClone();

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_SYMBOLS_FLAG = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}

	cloneDeep_1 = cloneDeep;
	return cloneDeep_1;
}

var _isIterateeCall;
var hasRequired_isIterateeCall;

function require_isIterateeCall () {
	if (hasRequired_isIterateeCall) return _isIterateeCall;
	hasRequired_isIterateeCall = 1;
	var eq = requireEq(),
	    isArrayLike = requireIsArrayLike(),
	    isIndex = require_isIndex(),
	    isObject = requireIsObject();

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	_isIterateeCall = isIterateeCall;
	return _isIterateeCall;
}

var defaults_1;
var hasRequiredDefaults;

function requireDefaults () {
	if (hasRequiredDefaults) return defaults_1;
	hasRequiredDefaults = 1;
	var baseRest = require_baseRest(),
	    eq = requireEq(),
	    isIterateeCall = require_isIterateeCall(),
	    keysIn = requireKeysIn();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest(function(object, sources) {
	  object = Object(object);

	  var index = -1;
	  var length = sources.length;
	  var guard = length > 2 ? sources[2] : undefined;

	  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	    length = 1;
	  }

	  while (++index < length) {
	    var source = sources[index];
	    var props = keysIn(source);
	    var propsIndex = -1;
	    var propsLength = props.length;

	    while (++propsIndex < propsLength) {
	      var key = props[propsIndex];
	      var value = object[key];

	      if (value === undefined ||
	          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        object[key] = source[key];
	      }
	    }
	  }

	  return object;
	});

	defaults_1 = defaults;
	return defaults_1;
}

var _createFind;
var hasRequired_createFind;

function require_createFind () {
	if (hasRequired_createFind) return _createFind;
	hasRequired_createFind = 1;
	var baseIteratee = require_baseIteratee(),
	    isArrayLike = requireIsArrayLike(),
	    keys = requireKeys();

	/**
	 * Creates a `_.find` or `_.findLast` function.
	 *
	 * @private
	 * @param {Function} findIndexFunc The function to find the collection index.
	 * @returns {Function} Returns the new find function.
	 */
	function createFind(findIndexFunc) {
	  return function(collection, predicate, fromIndex) {
	    var iterable = Object(collection);
	    if (!isArrayLike(collection)) {
	      var iteratee = baseIteratee(predicate, 3);
	      collection = keys(collection);
	      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	    }
	    var index = findIndexFunc(collection, predicate, fromIndex);
	    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	  };
	}

	_createFind = createFind;
	return _createFind;
}

/** Used to match a single whitespace character. */

var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;

function require_trimmedEndIndex () {
	if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
	hasRequired_trimmedEndIndex = 1;
	var reWhitespace = /\s/;

	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
	 * character of `string`.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {number} Returns the index of the last non-whitespace character.
	 */
	function trimmedEndIndex(string) {
	  var index = string.length;

	  while (index-- && reWhitespace.test(string.charAt(index))) {}
	  return index;
	}

	_trimmedEndIndex = trimmedEndIndex;
	return _trimmedEndIndex;
}

var _baseTrim;
var hasRequired_baseTrim;

function require_baseTrim () {
	if (hasRequired_baseTrim) return _baseTrim;
	hasRequired_baseTrim = 1;
	var trimmedEndIndex = require_trimmedEndIndex();

	/** Used to match leading whitespace. */
	var reTrimStart = /^\s+/;

	/**
	 * The base implementation of `_.trim`.
	 *
	 * @private
	 * @param {string} string The string to trim.
	 * @returns {string} Returns the trimmed string.
	 */
	function baseTrim(string) {
	  return string
	    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
	    : string;
	}

	_baseTrim = baseTrim;
	return _baseTrim;
}

var toNumber_1;
var hasRequiredToNumber;

function requireToNumber () {
	if (hasRequiredToNumber) return toNumber_1;
	hasRequiredToNumber = 1;
	var baseTrim = require_baseTrim(),
	    isObject = requireIsObject(),
	    isSymbol = requireIsSymbol();

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = baseTrim(value);
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	toNumber_1 = toNumber;
	return toNumber_1;
}

var toFinite_1;
var hasRequiredToFinite;

function requireToFinite () {
	if (hasRequiredToFinite) return toFinite_1;
	hasRequiredToFinite = 1;
	var toNumber = requireToNumber();

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -Infinity) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	toFinite_1 = toFinite;
	return toFinite_1;
}

var toInteger_1;
var hasRequiredToInteger;

function requireToInteger () {
	if (hasRequiredToInteger) return toInteger_1;
	hasRequiredToInteger = 1;
	var toFinite = requireToFinite();

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	toInteger_1 = toInteger;
	return toInteger_1;
}

var findIndex_1;
var hasRequiredFindIndex;

function requireFindIndex () {
	if (hasRequiredFindIndex) return findIndex_1;
	hasRequiredFindIndex = 1;
	var baseFindIndex = require_baseFindIndex(),
	    baseIteratee = require_baseIteratee(),
	    toInteger = requireToInteger();

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax(length + index, 0);
	  }
	  return baseFindIndex(array, baseIteratee(predicate, 3), index);
	}

	findIndex_1 = findIndex;
	return findIndex_1;
}

var find_1;
var hasRequiredFind;

function requireFind () {
	if (hasRequiredFind) return find_1;
	hasRequiredFind = 1;
	var createFind = require_createFind(),
	    findIndex = requireFindIndex();

	/**
	 * Iterates over elements of `collection`, returning the first element
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {*} Returns the matched element, else `undefined`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'age': 36, 'active': true },
	 *   { 'user': 'fred',    'age': 40, 'active': false },
	 *   { 'user': 'pebbles', 'age': 1,  'active': true }
	 * ];
	 *
	 * _.find(users, function(o) { return o.age < 40; });
	 * // => object for 'barney'
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.find(users, { 'age': 1, 'active': true });
	 * // => object for 'pebbles'
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.find(users, ['active', false]);
	 * // => object for 'fred'
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.find(users, 'active');
	 * // => object for 'barney'
	 */
	var find = createFind(findIndex);

	find_1 = find;
	return find_1;
}

var flatten_1;
var hasRequiredFlatten;

function requireFlatten () {
	if (hasRequiredFlatten) return flatten_1;
	hasRequiredFlatten = 1;
	var baseFlatten = require_baseFlatten();

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, 1) : [];
	}

	flatten_1 = flatten;
	return flatten_1;
}

var forIn_1;
var hasRequiredForIn;

function requireForIn () {
	if (hasRequiredForIn) return forIn_1;
	hasRequiredForIn = 1;
	var baseFor = require_baseFor(),
	    castFunction = require_castFunction(),
	    keysIn = requireKeysIn();

	/**
	 * Iterates over own and inherited enumerable string keyed properties of an
	 * object and invokes `iteratee` for each property. The iteratee is invoked
	 * with three arguments: (value, key, object). Iteratee functions may exit
	 * iteration early by explicitly returning `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.3.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 * @see _.forInRight
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.forIn(new Foo, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	 */
	function forIn(object, iteratee) {
	  return object == null
	    ? object
	    : baseFor(object, castFunction(iteratee), keysIn);
	}

	forIn_1 = forIn;
	return forIn_1;
}

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */

var last_1;
var hasRequiredLast;

function requireLast () {
	if (hasRequiredLast) return last_1;
	hasRequiredLast = 1;
	function last(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? array[length - 1] : undefined;
	}

	last_1 = last;
	return last_1;
}

var mapValues_1;
var hasRequiredMapValues;

function requireMapValues () {
	if (hasRequiredMapValues) return mapValues_1;
	hasRequiredMapValues = 1;
	var baseAssignValue = require_baseAssignValue(),
	    baseForOwn = require_baseForOwn(),
	    baseIteratee = require_baseIteratee();

	/**
	 * Creates an object with the same keys as `object` and values generated
	 * by running each own enumerable string keyed property of `object` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, key, object).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns the new mapped object.
	 * @see _.mapKeys
	 * @example
	 *
	 * var users = {
	 *   'fred':    { 'user': 'fred',    'age': 40 },
	 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	 * };
	 *
	 * _.mapValues(users, function(o) { return o.age; });
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.mapValues(users, 'age');
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 */
	function mapValues(object, iteratee) {
	  var result = {};
	  iteratee = baseIteratee(iteratee, 3);

	  baseForOwn(object, function(value, key, object) {
	    baseAssignValue(result, key, iteratee(value, key, object));
	  });
	  return result;
	}

	mapValues_1 = mapValues;
	return mapValues_1;
}

var _baseExtremum;
var hasRequired_baseExtremum;

function require_baseExtremum () {
	if (hasRequired_baseExtremum) return _baseExtremum;
	hasRequired_baseExtremum = 1;
	var isSymbol = requireIsSymbol();

	/**
	 * The base implementation of methods like `_.max` and `_.min` which accepts a
	 * `comparator` to determine the extremum value.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The iteratee invoked per iteration.
	 * @param {Function} comparator The comparator used to compare values.
	 * @returns {*} Returns the extremum value.
	 */
	function baseExtremum(array, iteratee, comparator) {
	  var index = -1,
	      length = array.length;

	  while (++index < length) {
	    var value = array[index],
	        current = iteratee(value);

	    if (current != null && (computed === undefined
	          ? (current === current && !isSymbol(current))
	          : comparator(current, computed)
	        )) {
	      var computed = current,
	          result = value;
	    }
	  }
	  return result;
	}

	_baseExtremum = baseExtremum;
	return _baseExtremum;
}

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */

var _baseGt;
var hasRequired_baseGt;

function require_baseGt () {
	if (hasRequired_baseGt) return _baseGt;
	hasRequired_baseGt = 1;
	function baseGt(value, other) {
	  return value > other;
	}

	_baseGt = baseGt;
	return _baseGt;
}

var max_1;
var hasRequiredMax;

function requireMax () {
	if (hasRequiredMax) return max_1;
	hasRequiredMax = 1;
	var baseExtremum = require_baseExtremum(),
	    baseGt = require_baseGt(),
	    identity = requireIdentity();

	/**
	 * Computes the maximum value of `array`. If `array` is empty or falsey,
	 * `undefined` is returned.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @returns {*} Returns the maximum value.
	 * @example
	 *
	 * _.max([4, 2, 8, 6]);
	 * // => 8
	 *
	 * _.max([]);
	 * // => undefined
	 */
	function max(array) {
	  return (array && array.length)
	    ? baseExtremum(array, identity, baseGt)
	    : undefined;
	}

	max_1 = max;
	return max_1;
}

var _assignMergeValue;
var hasRequired_assignMergeValue;

function require_assignMergeValue () {
	if (hasRequired_assignMergeValue) return _assignMergeValue;
	hasRequired_assignMergeValue = 1;
	var baseAssignValue = require_baseAssignValue(),
	    eq = requireEq();

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	_assignMergeValue = assignMergeValue;
	return _assignMergeValue;
}

var isPlainObject_1;
var hasRequiredIsPlainObject;

function requireIsPlainObject () {
	if (hasRequiredIsPlainObject) return isPlainObject_1;
	hasRequiredIsPlainObject = 1;
	var baseGetTag = require_baseGetTag(),
	    getPrototype = require_getPrototype(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	isPlainObject_1 = isPlainObject;
	return isPlainObject_1;
}

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

var _safeGet;
var hasRequired_safeGet;

function require_safeGet () {
	if (hasRequired_safeGet) return _safeGet;
	hasRequired_safeGet = 1;
	function safeGet(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	_safeGet = safeGet;
	return _safeGet;
}

var toPlainObject_1;
var hasRequiredToPlainObject;

function requireToPlainObject () {
	if (hasRequiredToPlainObject) return toPlainObject_1;
	hasRequiredToPlainObject = 1;
	var copyObject = require_copyObject(),
	    keysIn = requireKeysIn();

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn(value));
	}

	toPlainObject_1 = toPlainObject;
	return toPlainObject_1;
}

var _baseMergeDeep;
var hasRequired_baseMergeDeep;

function require_baseMergeDeep () {
	if (hasRequired_baseMergeDeep) return _baseMergeDeep;
	hasRequired_baseMergeDeep = 1;
	var assignMergeValue = require_assignMergeValue(),
	    cloneBuffer = require_cloneBuffer(),
	    cloneTypedArray = require_cloneTypedArray(),
	    copyArray = require_copyArray(),
	    initCloneObject = require_initCloneObject(),
	    isArguments = requireIsArguments(),
	    isArray = requireIsArray(),
	    isArrayLikeObject = requireIsArrayLikeObject(),
	    isBuffer = requireIsBuffer(),
	    isFunction = requireIsFunction(),
	    isObject = requireIsObject(),
	    isPlainObject = requireIsPlainObject(),
	    isTypedArray = requireIsTypedArray(),
	    safeGet = require_safeGet(),
	    toPlainObject = requireToPlainObject();

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = safeGet(object, key),
	      srcValue = safeGet(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || isFunction(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	_baseMergeDeep = baseMergeDeep;
	return _baseMergeDeep;
}

var _baseMerge;
var hasRequired_baseMerge;

function require_baseMerge () {
	if (hasRequired_baseMerge) return _baseMerge;
	hasRequired_baseMerge = 1;
	var Stack = require_Stack(),
	    assignMergeValue = require_assignMergeValue(),
	    baseFor = require_baseFor(),
	    baseMergeDeep = require_baseMergeDeep(),
	    isObject = requireIsObject(),
	    keysIn = requireKeysIn(),
	    safeGet = require_safeGet();

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    stack || (stack = new Stack);
	    if (isObject(srcValue)) {
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn);
	}

	_baseMerge = baseMerge;
	return _baseMerge;
}

var _createAssigner;
var hasRequired_createAssigner;

function require_createAssigner () {
	if (hasRequired_createAssigner) return _createAssigner;
	hasRequired_createAssigner = 1;
	var baseRest = require_baseRest(),
	    isIterateeCall = require_isIterateeCall();

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	_createAssigner = createAssigner;
	return _createAssigner;
}

var merge_1;
var hasRequiredMerge;

function requireMerge () {
	if (hasRequiredMerge) return merge_1;
	hasRequiredMerge = 1;
	var baseMerge = require_baseMerge(),
	    createAssigner = require_createAssigner();

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	merge_1 = merge;
	return merge_1;
}

/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */

var _baseLt;
var hasRequired_baseLt;

function require_baseLt () {
	if (hasRequired_baseLt) return _baseLt;
	hasRequired_baseLt = 1;
	function baseLt(value, other) {
	  return value < other;
	}

	_baseLt = baseLt;
	return _baseLt;
}

var min_1;
var hasRequiredMin;

function requireMin () {
	if (hasRequiredMin) return min_1;
	hasRequiredMin = 1;
	var baseExtremum = require_baseExtremum(),
	    baseLt = require_baseLt(),
	    identity = requireIdentity();

	/**
	 * Computes the minimum value of `array`. If `array` is empty or falsey,
	 * `undefined` is returned.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @returns {*} Returns the minimum value.
	 * @example
	 *
	 * _.min([4, 2, 8, 6]);
	 * // => 2
	 *
	 * _.min([]);
	 * // => undefined
	 */
	function min(array) {
	  return (array && array.length)
	    ? baseExtremum(array, identity, baseLt)
	    : undefined;
	}

	min_1 = min;
	return min_1;
}

var minBy_1;
var hasRequiredMinBy;

function requireMinBy () {
	if (hasRequiredMinBy) return minBy_1;
	hasRequiredMinBy = 1;
	var baseExtremum = require_baseExtremum(),
	    baseIteratee = require_baseIteratee(),
	    baseLt = require_baseLt();

	/**
	 * This method is like `_.min` except that it accepts `iteratee` which is
	 * invoked for each element in `array` to generate the criterion by which
	 * the value is ranked. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {*} Returns the minimum value.
	 * @example
	 *
	 * var objects = [{ 'n': 1 }, { 'n': 2 }];
	 *
	 * _.minBy(objects, function(o) { return o.n; });
	 * // => { 'n': 1 }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.minBy(objects, 'n');
	 * // => { 'n': 1 }
	 */
	function minBy(array, iteratee) {
	  return (array && array.length)
	    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)
	    : undefined;
	}

	minBy_1 = minBy;
	return minBy_1;
}

var now_1;
var hasRequiredNow;

function requireNow () {
	if (hasRequiredNow) return now_1;
	hasRequiredNow = 1;
	var root = require_root();

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root.Date.now();
	};

	now_1 = now;
	return now_1;
}

var _baseSet;
var hasRequired_baseSet;

function require_baseSet () {
	if (hasRequired_baseSet) return _baseSet;
	hasRequired_baseSet = 1;
	var assignValue = require_assignValue(),
	    castPath = require_castPath(),
	    isIndex = require_isIndex(),
	    isObject = requireIsObject(),
	    toKey = require_toKey();

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	        newValue = value;

	    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
	      return object;
	    }

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	_baseSet = baseSet;
	return _baseSet;
}

var _basePickBy;
var hasRequired_basePickBy;

function require_basePickBy () {
	if (hasRequired_basePickBy) return _basePickBy;
	hasRequired_basePickBy = 1;
	var baseGet = require_baseGet(),
	    baseSet = require_baseSet(),
	    castPath = require_castPath();

	/**
	 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} paths The property paths to pick.
	 * @param {Function} predicate The function invoked per property.
	 * @returns {Object} Returns the new object.
	 */
	function basePickBy(object, paths, predicate) {
	  var index = -1,
	      length = paths.length,
	      result = {};

	  while (++index < length) {
	    var path = paths[index],
	        value = baseGet(object, path);

	    if (predicate(value, path)) {
	      baseSet(result, castPath(path, object), value);
	    }
	  }
	  return result;
	}

	_basePickBy = basePickBy;
	return _basePickBy;
}

var _basePick;
var hasRequired_basePick;

function require_basePick () {
	if (hasRequired_basePick) return _basePick;
	hasRequired_basePick = 1;
	var basePickBy = require_basePickBy(),
	    hasIn = requireHasIn();

	/**
	 * The base implementation of `_.pick` without support for individual
	 * property identifiers.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} paths The property paths to pick.
	 * @returns {Object} Returns the new object.
	 */
	function basePick(object, paths) {
	  return basePickBy(object, paths, function(value, path) {
	    return hasIn(object, path);
	  });
	}

	_basePick = basePick;
	return _basePick;
}

var _flatRest;
var hasRequired_flatRest;

function require_flatRest () {
	if (hasRequired_flatRest) return _flatRest;
	hasRequired_flatRest = 1;
	var flatten = requireFlatten(),
	    overRest = require_overRest(),
	    setToString = require_setToString();

	/**
	 * A specialized version of `baseRest` which flattens the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @returns {Function} Returns the new function.
	 */
	function flatRest(func) {
	  return setToString(overRest(func, undefined, flatten), func + '');
	}

	_flatRest = flatRest;
	return _flatRest;
}

var pick_1;
var hasRequiredPick;

function requirePick () {
	if (hasRequiredPick) return pick_1;
	hasRequiredPick = 1;
	var basePick = require_basePick(),
	    flatRest = require_flatRest();

	/**
	 * Creates an object composed of the picked `object` properties.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {...(string|string[])} [paths] The property paths to pick.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.pick(object, ['a', 'c']);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var pick = flatRest(function(object, paths) {
	  return object == null ? {} : basePick(object, paths);
	});

	pick_1 = pick;
	return pick_1;
}

/* Built-in method references for those with the same name as other `lodash` methods. */

var _baseRange;
var hasRequired_baseRange;

function require_baseRange () {
	if (hasRequired_baseRange) return _baseRange;
	hasRequired_baseRange = 1;
	var nativeCeil = Math.ceil,
	    nativeMax = Math.max;

	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	      result = Array(length);

	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}

	_baseRange = baseRange;
	return _baseRange;
}

var _createRange;
var hasRequired_createRange;

function require_createRange () {
	if (hasRequired_createRange) return _createRange;
	hasRequired_createRange = 1;
	var baseRange = require_baseRange(),
	    isIterateeCall = require_isIterateeCall(),
	    toFinite = requireToFinite();

	/**
	 * Creates a `_.range` or `_.rangeRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new range function.
	 */
	function createRange(fromRight) {
	  return function(start, end, step) {
	    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	      end = step = undefined;
	    }
	    // Ensure the sign of `-0` is preserved.
	    start = toFinite(start);
	    if (end === undefined) {
	      end = start;
	      start = 0;
	    } else {
	      end = toFinite(end);
	    }
	    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	    return baseRange(start, end, step, fromRight);
	  };
	}

	_createRange = createRange;
	return _createRange;
}

var range_1;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range_1;
	hasRequiredRange = 1;
	var createRange = require_createRange();

	/**
	 * Creates an array of numbers (positive and/or negative) progressing from
	 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	 * `start` is specified without an `end` or `step`. If `end` is not specified,
	 * it's set to `start` with `start` then set to `0`.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.rangeRight
	 * @example
	 *
	 * _.range(4);
	 * // => [0, 1, 2, 3]
	 *
	 * _.range(-4);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 5);
	 * // => [1, 2, 3, 4]
	 *
	 * _.range(0, 20, 5);
	 * // => [0, 5, 10, 15]
	 *
	 * _.range(0, -4, -1);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.range(0);
	 * // => []
	 */
	var range = createRange();

	range_1 = range;
	return range_1;
}

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */

var _baseSortBy;
var hasRequired_baseSortBy;

function require_baseSortBy () {
	if (hasRequired_baseSortBy) return _baseSortBy;
	hasRequired_baseSortBy = 1;
	function baseSortBy(array, comparer) {
	  var length = array.length;

	  array.sort(comparer);
	  while (length--) {
	    array[length] = array[length].value;
	  }
	  return array;
	}

	_baseSortBy = baseSortBy;
	return _baseSortBy;
}

var _compareAscending;
var hasRequired_compareAscending;

function require_compareAscending () {
	if (hasRequired_compareAscending) return _compareAscending;
	hasRequired_compareAscending = 1;
	var isSymbol = requireIsSymbol();

	/**
	 * Compares values to sort them in ascending order.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {number} Returns the sort order indicator for `value`.
	 */
	function compareAscending(value, other) {
	  if (value !== other) {
	    var valIsDefined = value !== undefined,
	        valIsNull = value === null,
	        valIsReflexive = value === value,
	        valIsSymbol = isSymbol(value);

	    var othIsDefined = other !== undefined,
	        othIsNull = other === null,
	        othIsReflexive = other === other,
	        othIsSymbol = isSymbol(other);

	    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	        (valIsNull && othIsDefined && othIsReflexive) ||
	        (!valIsDefined && othIsReflexive) ||
	        !valIsReflexive) {
	      return 1;
	    }
	    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	        (othIsNull && valIsDefined && valIsReflexive) ||
	        (!othIsDefined && valIsReflexive) ||
	        !othIsReflexive) {
	      return -1;
	    }
	  }
	  return 0;
	}

	_compareAscending = compareAscending;
	return _compareAscending;
}

var _compareMultiple;
var hasRequired_compareMultiple;

function require_compareMultiple () {
	if (hasRequired_compareMultiple) return _compareMultiple;
	hasRequired_compareMultiple = 1;
	var compareAscending = require_compareAscending();

	/**
	 * Used by `_.orderBy` to compare multiple properties of a value to another
	 * and stable sort them.
	 *
	 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	 * specify an order of "desc" for descending or "asc" for ascending sort order
	 * of corresponding values.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {boolean[]|string[]} orders The order to sort by for each property.
	 * @returns {number} Returns the sort order indicator for `object`.
	 */
	function compareMultiple(object, other, orders) {
	  var index = -1,
	      objCriteria = object.criteria,
	      othCriteria = other.criteria,
	      length = objCriteria.length,
	      ordersLength = orders.length;

	  while (++index < length) {
	    var result = compareAscending(objCriteria[index], othCriteria[index]);
	    if (result) {
	      if (index >= ordersLength) {
	        return result;
	      }
	      var order = orders[index];
	      return result * (order == 'desc' ? -1 : 1);
	    }
	  }
	  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	  // that causes it, under certain circumstances, to provide the same value for
	  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	  // for more details.
	  //
	  // This also ensures a stable sort in V8 and other engines.
	  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	  return object.index - other.index;
	}

	_compareMultiple = compareMultiple;
	return _compareMultiple;
}

var _baseOrderBy;
var hasRequired_baseOrderBy;

function require_baseOrderBy () {
	if (hasRequired_baseOrderBy) return _baseOrderBy;
	hasRequired_baseOrderBy = 1;
	var arrayMap = require_arrayMap(),
	    baseGet = require_baseGet(),
	    baseIteratee = require_baseIteratee(),
	    baseMap = require_baseMap(),
	    baseSortBy = require_baseSortBy(),
	    baseUnary = require_baseUnary(),
	    compareMultiple = require_compareMultiple(),
	    identity = requireIdentity(),
	    isArray = requireIsArray();

	/**
	 * The base implementation of `_.orderBy` without param guards.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	 * @param {string[]} orders The sort orders of `iteratees`.
	 * @returns {Array} Returns the new sorted array.
	 */
	function baseOrderBy(collection, iteratees, orders) {
	  if (iteratees.length) {
	    iteratees = arrayMap(iteratees, function(iteratee) {
	      if (isArray(iteratee)) {
	        return function(value) {
	          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
	        }
	      }
	      return iteratee;
	    });
	  } else {
	    iteratees = [identity];
	  }

	  var index = -1;
	  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

	  var result = baseMap(collection, function(value, key, collection) {
	    var criteria = arrayMap(iteratees, function(iteratee) {
	      return iteratee(value);
	    });
	    return { 'criteria': criteria, 'index': ++index, 'value': value };
	  });

	  return baseSortBy(result, function(object, other) {
	    return compareMultiple(object, other, orders);
	  });
	}

	_baseOrderBy = baseOrderBy;
	return _baseOrderBy;
}

var sortBy_1;
var hasRequiredSortBy;

function requireSortBy () {
	if (hasRequiredSortBy) return sortBy_1;
	hasRequiredSortBy = 1;
	var baseFlatten = require_baseFlatten(),
	    baseOrderBy = require_baseOrderBy(),
	    baseRest = require_baseRest(),
	    isIterateeCall = require_isIterateeCall();

	/**
	 * Creates an array of elements, sorted in ascending order by the results of
	 * running each element in a collection thru each iteratee. This method
	 * performs a stable sort, that is, it preserves the original sort order of
	 * equal elements. The iteratees are invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {...(Function|Function[])} [iteratees=[_.identity]]
	 *  The iteratees to sort by.
	 * @returns {Array} Returns the new sorted array.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'fred',   'age': 48 },
	 *   { 'user': 'barney', 'age': 36 },
	 *   { 'user': 'fred',   'age': 30 },
	 *   { 'user': 'barney', 'age': 34 }
	 * ];
	 *
	 * _.sortBy(users, [function(o) { return o.user; }]);
	 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
	 *
	 * _.sortBy(users, ['user', 'age']);
	 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
	 */
	var sortBy = baseRest(function(collection, iteratees) {
	  if (collection == null) {
	    return [];
	  }
	  var length = iteratees.length;
	  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	    iteratees = [];
	  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	    iteratees = [iteratees[0]];
	  }
	  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	});

	sortBy_1 = sortBy;
	return sortBy_1;
}

var uniqueId_1;
var hasRequiredUniqueId;

function requireUniqueId () {
	if (hasRequiredUniqueId) return uniqueId_1;
	hasRequiredUniqueId = 1;
	var toString = requireToString();

	/** Used to generate unique IDs. */
	var idCounter = 0;

	/**
	 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {string} [prefix=''] The value to prefix the ID with.
	 * @returns {string} Returns the unique ID.
	 * @example
	 *
	 * _.uniqueId('contact_');
	 * // => 'contact_104'
	 *
	 * _.uniqueId();
	 * // => '105'
	 */
	function uniqueId(prefix) {
	  var id = ++idCounter;
	  return toString(prefix) + id;
	}

	uniqueId_1 = uniqueId;
	return uniqueId_1;
}

/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */

var _baseZipObject;
var hasRequired_baseZipObject;

function require_baseZipObject () {
	if (hasRequired_baseZipObject) return _baseZipObject;
	hasRequired_baseZipObject = 1;
	function baseZipObject(props, values, assignFunc) {
	  var index = -1,
	      length = props.length,
	      valsLength = values.length,
	      result = {};

	  while (++index < length) {
	    var value = index < valsLength ? values[index] : undefined;
	    assignFunc(result, props[index], value);
	  }
	  return result;
	}

	_baseZipObject = baseZipObject;
	return _baseZipObject;
}

var zipObject_1;
var hasRequiredZipObject;

function requireZipObject () {
	if (hasRequiredZipObject) return zipObject_1;
	hasRequiredZipObject = 1;
	var assignValue = require_assignValue(),
	    baseZipObject = require_baseZipObject();

	/**
	 * This method is like `_.fromPairs` except that it accepts two arrays,
	 * one of property identifiers and one of corresponding values.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.4.0
	 * @category Array
	 * @param {Array} [props=[]] The property identifiers.
	 * @param {Array} [values=[]] The property values.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * _.zipObject(['a', 'b'], [1, 2]);
	 * // => { 'a': 1, 'b': 2 }
	 */
	function zipObject(props, values) {
	  return baseZipObject(props || [], values || [], assignValue);
	}

	zipObject_1 = zipObject;
	return zipObject_1;
}

/* global window */

var lodash_1;
var hasRequiredLodash;

function requireLodash () {
	if (hasRequiredLodash) return lodash_1;
	hasRequiredLodash = 1;
	var lodash;

	if (typeof commonjsRequire === "function") {
	  try {
	    lodash = {
	      cloneDeep: requireCloneDeep(),
	      constant: requireConstant(),
	      defaults: requireDefaults(),
	      each: requireEach(),
	      filter: requireFilter(),
	      find: requireFind(),
	      flatten: requireFlatten(),
	      forEach: requireForEach(),
	      forIn: requireForIn(),
	      has:  requireHas(),
	      isUndefined: requireIsUndefined(),
	      last: requireLast(),
	      map: requireMap(),
	      mapValues: requireMapValues(),
	      max: requireMax(),
	      merge: requireMerge(),
	      min: requireMin(),
	      minBy: requireMinBy(),
	      now: requireNow(),
	      pick: requirePick(),
	      range: requireRange(),
	      reduce: requireReduce(),
	      sortBy: requireSortBy(),
	      uniqueId: requireUniqueId(),
	      values: requireValues(),
	      zipObject: requireZipObject(),
	    };
	  } catch (e) {
	    // continue regardless of error
	  }
	}

	if (!lodash) {
	  lodash = window._;
	}

	lodash_1 = lodash;
	return lodash_1;
}

/*
 * Simple doubly linked list implementation derived from Cormen, et al.,
 * "Introduction to Algorithms".
 */

var list;
var hasRequiredList;

function requireList () {
	if (hasRequiredList) return list;
	hasRequiredList = 1;
	list = List;

	function List() {
	  var sentinel = {};
	  sentinel._next = sentinel._prev = sentinel;
	  this._sentinel = sentinel;
	}

	List.prototype.dequeue = function() {
	  var sentinel = this._sentinel;
	  var entry = sentinel._prev;
	  if (entry !== sentinel) {
	    unlink(entry);
	    return entry;
	  }
	};

	List.prototype.enqueue = function(entry) {
	  var sentinel = this._sentinel;
	  if (entry._prev && entry._next) {
	    unlink(entry);
	  }
	  entry._next = sentinel._next;
	  sentinel._next._prev = entry;
	  sentinel._next = entry;
	  entry._prev = sentinel;
	};

	List.prototype.toString = function() {
	  var strs = [];
	  var sentinel = this._sentinel;
	  var curr = sentinel._prev;
	  while (curr !== sentinel) {
	    strs.push(JSON.stringify(curr, filterOutLinks));
	    curr = curr._prev;
	  }
	  return "[" + strs.join(", ") + "]";
	};

	function unlink(entry) {
	  entry._prev._next = entry._next;
	  entry._next._prev = entry._prev;
	  delete entry._next;
	  delete entry._prev;
	}

	function filterOutLinks(k, v) {
	  if (k !== "_next" && k !== "_prev") {
	    return v;
	  }
	}
	return list;
}

var greedyFas;
var hasRequiredGreedyFas;

function requireGreedyFas () {
	if (hasRequiredGreedyFas) return greedyFas;
	hasRequiredGreedyFas = 1;
	var _ = requireLodash();
	var Graph = requireGraphlib().Graph;
	var List = requireList();

	/*
	 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
	 * arc set is a set of edges that can be removed to make a graph acyclic.
	 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
	 * effective heuristic for the feedback arc set problem." This implementation
	 * adjusts that from the paper to allow for weighted edges.
	 */
	greedyFas = greedyFAS;

	var DEFAULT_WEIGHT_FN = _.constant(1);

	function greedyFAS(g, weightFn) {
	  if (g.nodeCount() <= 1) {
	    return [];
	  }
	  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
	  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);

	  // Expand multi-edges
	  return _.flatten(_.map(results, function(e) {
	    return g.outEdges(e.v, e.w);
	  }), true);
	}

	function doGreedyFAS(g, buckets, zeroIdx) {
	  var results = [];
	  var sources = buckets[buckets.length - 1];
	  var sinks = buckets[0];

	  var entry;
	  while (g.nodeCount()) {
	    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }
	    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }
	    if (g.nodeCount()) {
	      for (var i = buckets.length - 2; i > 0; --i) {
	        entry = buckets[i].dequeue();
	        if (entry) {
	          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
	          break;
	        }
	      }
	    }
	  }

	  return results;
	}

	function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
	  var results = collectPredecessors ? [] : undefined;

	  _.forEach(g.inEdges(entry.v), function(edge) {
	    var weight = g.edge(edge);
	    var uEntry = g.node(edge.v);

	    if (collectPredecessors) {
	      results.push({ v: edge.v, w: edge.w });
	    }

	    uEntry.out -= weight;
	    assignBucket(buckets, zeroIdx, uEntry);
	  });

	  _.forEach(g.outEdges(entry.v), function(edge) {
	    var weight = g.edge(edge);
	    var w = edge.w;
	    var wEntry = g.node(w);
	    wEntry["in"] -= weight;
	    assignBucket(buckets, zeroIdx, wEntry);
	  });

	  g.removeNode(entry.v);

	  return results;
	}

	function buildState(g, weightFn) {
	  var fasGraph = new Graph();
	  var maxIn = 0;
	  var maxOut = 0;

	  _.forEach(g.nodes(), function(v) {
	    fasGraph.setNode(v, { v: v, "in": 0, out: 0 });
	  });

	  // Aggregate weights on nodes, but also sum the weights across multi-edges
	  // into a single edge for the fasGraph.
	  _.forEach(g.edges(), function(e) {
	    var prevWeight = fasGraph.edge(e.v, e.w) || 0;
	    var weight = weightFn(e);
	    var edgeWeight = prevWeight + weight;
	    fasGraph.setEdge(e.v, e.w, edgeWeight);
	    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
	    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)["in"]  += weight);
	  });

	  var buckets = _.range(maxOut + maxIn + 3).map(function() { return new List(); });
	  var zeroIdx = maxIn + 1;

	  _.forEach(fasGraph.nodes(), function(v) {
	    assignBucket(buckets, zeroIdx, fasGraph.node(v));
	  });

	  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };
	}

	function assignBucket(buckets, zeroIdx, entry) {
	  if (!entry.out) {
	    buckets[0].enqueue(entry);
	  } else if (!entry["in"]) {
	    buckets[buckets.length - 1].enqueue(entry);
	  } else {
	    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
	  }
	}
	return greedyFas;
}

var acyclic;
var hasRequiredAcyclic;

function requireAcyclic () {
	if (hasRequiredAcyclic) return acyclic;
	hasRequiredAcyclic = 1;

	var _ = requireLodash();
	var greedyFAS = requireGreedyFas();

	acyclic = {
	  run: run,
	  undo: undo
	};

	function run(g) {
	  var fas = (g.graph().acyclicer === "greedy"
	    ? greedyFAS(g, weightFn(g))
	    : dfsFAS(g));
	  _.forEach(fas, function(e) {
	    var label = g.edge(e);
	    g.removeEdge(e);
	    label.forwardName = e.name;
	    label.reversed = true;
	    g.setEdge(e.w, e.v, label, _.uniqueId("rev"));
	  });

	  function weightFn(g) {
	    return function(e) {
	      return g.edge(e).weight;
	    };
	  }
	}

	function dfsFAS(g) {
	  var fas = [];
	  var stack = {};
	  var visited = {};

	  function dfs(v) {
	    if (_.has(visited, v)) {
	      return;
	    }
	    visited[v] = true;
	    stack[v] = true;
	    _.forEach(g.outEdges(v), function(e) {
	      if (_.has(stack, e.w)) {
	        fas.push(e);
	      } else {
	        dfs(e.w);
	      }
	    });
	    delete stack[v];
	  }

	  _.forEach(g.nodes(), dfs);
	  return fas;
	}

	function undo(g) {
	  _.forEach(g.edges(), function(e) {
	    var label = g.edge(e);
	    if (label.reversed) {
	      g.removeEdge(e);

	      var forwardName = label.forwardName;
	      delete label.reversed;
	      delete label.forwardName;
	      g.setEdge(e.w, e.v, label, forwardName);
	    }
	  });
	}
	return acyclic;
}

/* eslint "no-console": off */

var util$1;
var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;

	var _ = requireLodash();
	var Graph = requireGraphlib().Graph;

	util$1 = {
	  addDummyNode: addDummyNode,
	  simplify: simplify,
	  asNonCompoundGraph: asNonCompoundGraph,
	  successorWeights: successorWeights,
	  predecessorWeights: predecessorWeights,
	  intersectRect: intersectRect,
	  buildLayerMatrix: buildLayerMatrix,
	  normalizeRanks: normalizeRanks,
	  removeEmptyRanks: removeEmptyRanks,
	  addBorderNode: addBorderNode,
	  maxRank: maxRank,
	  partition: partition,
	  time: time,
	  notime: notime
	};

	/*
	 * Adds a dummy node to the graph and return v.
	 */
	function addDummyNode(g, type, attrs, name) {
	  var v;
	  do {
	    v = _.uniqueId(name);
	  } while (g.hasNode(v));

	  attrs.dummy = type;
	  g.setNode(v, attrs);
	  return v;
	}

	/*
	 * Returns a new graph with only simple edges. Handles aggregation of data
	 * associated with multi-edges.
	 */
	function simplify(g) {
	  var simplified = new Graph().setGraph(g.graph());
	  _.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });
	  _.forEach(g.edges(), function(e) {
	    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
	    var label = g.edge(e);
	    simplified.setEdge(e.v, e.w, {
	      weight: simpleLabel.weight + label.weight,
	      minlen: Math.max(simpleLabel.minlen, label.minlen)
	    });
	  });
	  return simplified;
	}

	function asNonCompoundGraph(g) {
	  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
	  _.forEach(g.nodes(), function(v) {
	    if (!g.children(v).length) {
	      simplified.setNode(v, g.node(v));
	    }
	  });
	  _.forEach(g.edges(), function(e) {
	    simplified.setEdge(e, g.edge(e));
	  });
	  return simplified;
	}

	function successorWeights(g) {
	  var weightMap = _.map(g.nodes(), function(v) {
	    var sucs = {};
	    _.forEach(g.outEdges(v), function(e) {
	      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
	    });
	    return sucs;
	  });
	  return _.zipObject(g.nodes(), weightMap);
	}

	function predecessorWeights(g) {
	  var weightMap = _.map(g.nodes(), function(v) {
	    var preds = {};
	    _.forEach(g.inEdges(v), function(e) {
	      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
	    });
	    return preds;
	  });
	  return _.zipObject(g.nodes(), weightMap);
	}

	/*
	 * Finds where a line starting at point ({x, y}) would intersect a rectangle
	 * ({x, y, width, height}) if it were pointing at the rectangle's center.
	 */
	function intersectRect(rect, point) {
	  var x = rect.x;
	  var y = rect.y;

	  // Rectangle intersection algorithm from:
	  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
	  var dx = point.x - x;
	  var dy = point.y - y;
	  var w = rect.width / 2;
	  var h = rect.height / 2;

	  if (!dx && !dy) {
	    throw new Error("Not possible to find intersection inside of the rectangle");
	  }

	  var sx, sy;
	  if (Math.abs(dy) * w > Math.abs(dx) * h) {
	    // Intersection is top or bottom of rect.
	    if (dy < 0) {
	      h = -h;
	    }
	    sx = h * dx / dy;
	    sy = h;
	  } else {
	    // Intersection is left or right of rect.
	    if (dx < 0) {
	      w = -w;
	    }
	    sx = w;
	    sy = w * dy / dx;
	  }

	  return { x: x + sx, y: y + sy };
	}

	/*
	 * Given a DAG with each node assigned "rank" and "order" properties, this
	 * function will produce a matrix with the ids of each node.
	 */
	function buildLayerMatrix(g) {
	  var layering = _.map(_.range(maxRank(g) + 1), function() { return []; });
	  _.forEach(g.nodes(), function(v) {
	    var node = g.node(v);
	    var rank = node.rank;
	    if (!_.isUndefined(rank)) {
	      layering[rank][node.order] = v;
	    }
	  });
	  return layering;
	}

	/*
	 * Adjusts the ranks for all nodes in the graph such that all nodes v have
	 * rank(v) >= 0 and at least one node w has rank(w) = 0.
	 */
	function normalizeRanks(g) {
	  var min = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));
	  _.forEach(g.nodes(), function(v) {
	    var node = g.node(v);
	    if (_.has(node, "rank")) {
	      node.rank -= min;
	    }
	  });
	}

	function removeEmptyRanks(g) {
	  // Ranks may not start at 0, so we need to offset them
	  var offset = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));

	  var layers = [];
	  _.forEach(g.nodes(), function(v) {
	    var rank = g.node(v).rank - offset;
	    if (!layers[rank]) {
	      layers[rank] = [];
	    }
	    layers[rank].push(v);
	  });

	  var delta = 0;
	  var nodeRankFactor = g.graph().nodeRankFactor;
	  _.forEach(layers, function(vs, i) {
	    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {
	      --delta;
	    } else if (delta) {
	      _.forEach(vs, function(v) { g.node(v).rank += delta; });
	    }
	  });
	}

	function addBorderNode(g, prefix, rank, order) {
	  var node = {
	    width: 0,
	    height: 0
	  };
	  if (arguments.length >= 4) {
	    node.rank = rank;
	    node.order = order;
	  }
	  return addDummyNode(g, "border", node, prefix);
	}

	function maxRank(g) {
	  return _.max(_.map(g.nodes(), function(v) {
	    var rank = g.node(v).rank;
	    if (!_.isUndefined(rank)) {
	      return rank;
	    }
	  }));
	}

	/*
	 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
	 * function returns true for an entry it goes into `lhs`. Otherwise it goes
	 * into `rhs.
	 */
	function partition(collection, fn) {
	  var result = { lhs: [], rhs: [] };
	  _.forEach(collection, function(value) {
	    if (fn(value)) {
	      result.lhs.push(value);
	    } else {
	      result.rhs.push(value);
	    }
	  });
	  return result;
	}

	/*
	 * Returns a new function that wraps `fn` with a timer. The wrapper logs the
	 * time it takes to execute the function.
	 */
	function time(name, fn) {
	  var start = _.now();
	  try {
	    return fn();
	  } finally {
	    console.log(name + " time: " + (_.now() - start) + "ms");
	  }
	}

	function notime(name, fn) {
	  return fn();
	}
	return util$1;
}

var normalize;
var hasRequiredNormalize;

function requireNormalize () {
	if (hasRequiredNormalize) return normalize;
	hasRequiredNormalize = 1;

	var _ = requireLodash();
	var util = requireUtil$1();

	normalize = {
	  run: run,
	  undo: undo
	};

	/*
	 * Breaks any long edges in the graph into short segments that span 1 layer
	 * each. This operation is undoable with the denormalize function.
	 *
	 * Pre-conditions:
	 *
	 *    1. The input graph is a DAG.
	 *    2. Each node in the graph has a "rank" property.
	 *
	 * Post-condition:
	 *
	 *    1. All edges in the graph have a length of 1.
	 *    2. Dummy nodes are added where edges have been split into segments.
	 *    3. The graph is augmented with a "dummyChains" attribute which contains
	 *       the first dummy in each chain of dummy nodes produced.
	 */
	function run(g) {
	  g.graph().dummyChains = [];
	  _.forEach(g.edges(), function(edge) { normalizeEdge(g, edge); });
	}

	function normalizeEdge(g, e) {
	  var v = e.v;
	  var vRank = g.node(v).rank;
	  var w = e.w;
	  var wRank = g.node(w).rank;
	  var name = e.name;
	  var edgeLabel = g.edge(e);
	  var labelRank = edgeLabel.labelRank;

	  if (wRank === vRank + 1) return;

	  g.removeEdge(e);

	  var dummy, attrs, i;
	  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
	    edgeLabel.points = [];
	    attrs = {
	      width: 0, height: 0,
	      edgeLabel: edgeLabel, edgeObj: e,
	      rank: vRank
	    };
	    dummy = util.addDummyNode(g, "edge", attrs, "_d");
	    if (vRank === labelRank) {
	      attrs.width = edgeLabel.width;
	      attrs.height = edgeLabel.height;
	      attrs.dummy = "edge-label";
	      attrs.labelpos = edgeLabel.labelpos;
	    }
	    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
	    if (i === 0) {
	      g.graph().dummyChains.push(dummy);
	    }
	    v = dummy;
	  }

	  g.setEdge(v, w, { weight: edgeLabel.weight }, name);
	}

	function undo(g) {
	  _.forEach(g.graph().dummyChains, function(v) {
	    var node = g.node(v);
	    var origLabel = node.edgeLabel;
	    var w;
	    g.setEdge(node.edgeObj, origLabel);
	    while (node.dummy) {
	      w = g.successors(v)[0];
	      g.removeNode(v);
	      origLabel.points.push({ x: node.x, y: node.y });
	      if (node.dummy === "edge-label") {
	        origLabel.x = node.x;
	        origLabel.y = node.y;
	        origLabel.width = node.width;
	        origLabel.height = node.height;
	      }
	      v = w;
	      node = g.node(v);
	    }
	  });
	}
	return normalize;
}

var util;
var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;

	var _ = requireLodash();

	util = {
	  longestPath: longestPath,
	  slack: slack
	};

	/*
	 * Initializes ranks for the input graph using the longest path algorithm. This
	 * algorithm scales well and is fast in practice, it yields rather poor
	 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
	 * ranks wide and leaving edges longer than necessary. However, due to its
	 * speed, this algorithm is good for getting an initial ranking that can be fed
	 * into other algorithms.
	 *
	 * This algorithm does not normalize layers because it will be used by other
	 * algorithms in most cases. If using this algorithm directly, be sure to
	 * run normalize at the end.
	 *
	 * Pre-conditions:
	 *
	 *    1. Input graph is a DAG.
	 *    2. Input graph node labels can be assigned properties.
	 *
	 * Post-conditions:
	 *
	 *    1. Each node will be assign an (unnormalized) "rank" property.
	 */
	function longestPath(g) {
	  var visited = {};

	  function dfs(v) {
	    var label = g.node(v);
	    if (_.has(visited, v)) {
	      return label.rank;
	    }
	    visited[v] = true;

	    var rank = _.min(_.map(g.outEdges(v), function(e) {
	      return dfs(e.w) - g.edge(e).minlen;
	    }));

	    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
	        rank === undefined || // return value of _.map([]) for Lodash 4
	        rank === null) { // return value of _.map([null])
	      rank = 0;
	    }

	    return (label.rank = rank);
	  }

	  _.forEach(g.sources(), dfs);
	}

	/*
	 * Returns the amount of slack for the given edge. The slack is defined as the
	 * difference between the length of the edge and its minimum length.
	 */
	function slack(g, e) {
	  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
	}
	return util;
}

var feasibleTree_1;
var hasRequiredFeasibleTree;

function requireFeasibleTree () {
	if (hasRequiredFeasibleTree) return feasibleTree_1;
	hasRequiredFeasibleTree = 1;

	var _ = requireLodash();
	var Graph = requireGraphlib().Graph;
	var slack = requireUtil().slack;

	feasibleTree_1 = feasibleTree;

	/*
	 * Constructs a spanning tree with tight edges and adjusted the input node's
	 * ranks to achieve this. A tight edge is one that is has a length that matches
	 * its "minlen" attribute.
	 *
	 * The basic structure for this function is derived from Gansner, et al., "A
	 * Technique for Drawing Directed Graphs."
	 *
	 * Pre-conditions:
	 *
	 *    1. Graph must be a DAG.
	 *    2. Graph must be connected.
	 *    3. Graph must have at least one node.
	 *    5. Graph nodes must have been previously assigned a "rank" property that
	 *       respects the "minlen" property of incident edges.
	 *    6. Graph edges must have a "minlen" property.
	 *
	 * Post-conditions:
	 *
	 *    - Graph nodes will have their rank adjusted to ensure that all edges are
	 *      tight.
	 *
	 * Returns a tree (undirected graph) that is constructed using only "tight"
	 * edges.
	 */
	function feasibleTree(g) {
	  var t = new Graph({ directed: false });

	  // Choose arbitrary node from which to start our tree
	  var start = g.nodes()[0];
	  var size = g.nodeCount();
	  t.setNode(start, {});

	  var edge, delta;
	  while (tightTree(t, g) < size) {
	    edge = findMinSlackEdge(t, g);
	    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
	    shiftRanks(t, g, delta);
	  }

	  return t;
	}

	/*
	 * Finds a maximal tree of tight edges and returns the number of nodes in the
	 * tree.
	 */
	function tightTree(t, g) {
	  function dfs(v) {
	    _.forEach(g.nodeEdges(v), function(e) {
	      var edgeV = e.v,
	        w = (v === edgeV) ? e.w : edgeV;
	      if (!t.hasNode(w) && !slack(g, e)) {
	        t.setNode(w, {});
	        t.setEdge(v, w, {});
	        dfs(w);
	      }
	    });
	  }

	  _.forEach(t.nodes(), dfs);
	  return t.nodeCount();
	}

	/*
	 * Finds the edge with the smallest slack that is incident on tree and returns
	 * it.
	 */
	function findMinSlackEdge(t, g) {
	  return _.minBy(g.edges(), function(e) {
	    if (t.hasNode(e.v) !== t.hasNode(e.w)) {
	      return slack(g, e);
	    }
	  });
	}

	function shiftRanks(t, g, delta) {
	  _.forEach(t.nodes(), function(v) {
	    g.node(v).rank += delta;
	  });
	}
	return feasibleTree_1;
}

var networkSimplex_1;
var hasRequiredNetworkSimplex;

function requireNetworkSimplex () {
	if (hasRequiredNetworkSimplex) return networkSimplex_1;
	hasRequiredNetworkSimplex = 1;

	var _ = requireLodash();
	var feasibleTree = requireFeasibleTree();
	var slack = requireUtil().slack;
	var initRank = requireUtil().longestPath;
	var preorder = requireGraphlib().alg.preorder;
	var postorder = requireGraphlib().alg.postorder;
	var simplify = requireUtil$1().simplify;

	networkSimplex_1 = networkSimplex;

	// Expose some internals for testing purposes
	networkSimplex.initLowLimValues = initLowLimValues;
	networkSimplex.initCutValues = initCutValues;
	networkSimplex.calcCutValue = calcCutValue;
	networkSimplex.leaveEdge = leaveEdge;
	networkSimplex.enterEdge = enterEdge;
	networkSimplex.exchangeEdges = exchangeEdges;

	/*
	 * The network simplex algorithm assigns ranks to each node in the input graph
	 * and iteratively improves the ranking to reduce the length of edges.
	 *
	 * Preconditions:
	 *
	 *    1. The input graph must be a DAG.
	 *    2. All nodes in the graph must have an object value.
	 *    3. All edges in the graph must have "minlen" and "weight" attributes.
	 *
	 * Postconditions:
	 *
	 *    1. All nodes in the graph will have an assigned "rank" attribute that has
	 *       been optimized by the network simplex algorithm. Ranks start at 0.
	 *
	 *
	 * A rough sketch of the algorithm is as follows:
	 *
	 *    1. Assign initial ranks to each node. We use the longest path algorithm,
	 *       which assigns ranks to the lowest position possible. In general this
	 *       leads to very wide bottom ranks and unnecessarily long edges.
	 *    2. Construct a feasible tight tree. A tight tree is one such that all
	 *       edges in the tree have no slack (difference between length of edge
	 *       and minlen for the edge). This by itself greatly improves the assigned
	 *       rankings by shorting edges.
	 *    3. Iteratively find edges that have negative cut values. Generally a
	 *       negative cut value indicates that the edge could be removed and a new
	 *       tree edge could be added to produce a more compact graph.
	 *
	 * Much of the algorithms here are derived from Gansner, et al., "A Technique
	 * for Drawing Directed Graphs." The structure of the file roughly follows the
	 * structure of the overall algorithm.
	 */
	function networkSimplex(g) {
	  g = simplify(g);
	  initRank(g);
	  var t = feasibleTree(g);
	  initLowLimValues(t);
	  initCutValues(t, g);

	  var e, f;
	  while ((e = leaveEdge(t))) {
	    f = enterEdge(t, g, e);
	    exchangeEdges(t, g, e, f);
	  }
	}

	/*
	 * Initializes cut values for all edges in the tree.
	 */
	function initCutValues(t, g) {
	  var vs = postorder(t, t.nodes());
	  vs = vs.slice(0, vs.length - 1);
	  _.forEach(vs, function(v) {
	    assignCutValue(t, g, v);
	  });
	}

	function assignCutValue(t, g, child) {
	  var childLab = t.node(child);
	  var parent = childLab.parent;
	  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
	}

	/*
	 * Given the tight tree, its graph, and a child in the graph calculate and
	 * return the cut value for the edge between the child and its parent.
	 */
	function calcCutValue(t, g, child) {
	  var childLab = t.node(child);
	  var parent = childLab.parent;
	  // True if the child is on the tail end of the edge in the directed graph
	  var childIsTail = true;
	  // The graph's view of the tree edge we're inspecting
	  var graphEdge = g.edge(child, parent);
	  // The accumulated cut value for the edge between this node and its parent
	  var cutValue = 0;

	  if (!graphEdge) {
	    childIsTail = false;
	    graphEdge = g.edge(parent, child);
	  }

	  cutValue = graphEdge.weight;

	  _.forEach(g.nodeEdges(child), function(e) {
	    var isOutEdge = e.v === child,
	      other = isOutEdge ? e.w : e.v;

	    if (other !== parent) {
	      var pointsToHead = isOutEdge === childIsTail,
	        otherWeight = g.edge(e).weight;

	      cutValue += pointsToHead ? otherWeight : -otherWeight;
	      if (isTreeEdge(t, child, other)) {
	        var otherCutValue = t.edge(child, other).cutvalue;
	        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
	      }
	    }
	  });

	  return cutValue;
	}

	function initLowLimValues(tree, root) {
	  if (arguments.length < 2) {
	    root = tree.nodes()[0];
	  }
	  dfsAssignLowLim(tree, {}, 1, root);
	}

	function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
	  var low = nextLim;
	  var label = tree.node(v);

	  visited[v] = true;
	  _.forEach(tree.neighbors(v), function(w) {
	    if (!_.has(visited, w)) {
	      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
	    }
	  });

	  label.low = low;
	  label.lim = nextLim++;
	  if (parent) {
	    label.parent = parent;
	  } else {
	    // TODO should be able to remove this when we incrementally update low lim
	    delete label.parent;
	  }

	  return nextLim;
	}

	function leaveEdge(tree) {
	  return _.find(tree.edges(), function(e) {
	    return tree.edge(e).cutvalue < 0;
	  });
	}

	function enterEdge(t, g, edge) {
	  var v = edge.v;
	  var w = edge.w;

	  // For the rest of this function we assume that v is the tail and w is the
	  // head, so if we don't have this edge in the graph we should flip it to
	  // match the correct orientation.
	  if (!g.hasEdge(v, w)) {
	    v = edge.w;
	    w = edge.v;
	  }

	  var vLabel = t.node(v);
	  var wLabel = t.node(w);
	  var tailLabel = vLabel;
	  var flip = false;

	  // If the root is in the tail of the edge then we need to flip the logic that
	  // checks for the head and tail nodes in the candidates function below.
	  if (vLabel.lim > wLabel.lim) {
	    tailLabel = wLabel;
	    flip = true;
	  }

	  var candidates = _.filter(g.edges(), function(edge) {
	    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&
	           flip !== isDescendant(t, t.node(edge.w), tailLabel);
	  });

	  return _.minBy(candidates, function(edge) { return slack(g, edge); });
	}

	function exchangeEdges(t, g, e, f) {
	  var v = e.v;
	  var w = e.w;
	  t.removeEdge(v, w);
	  t.setEdge(f.v, f.w, {});
	  initLowLimValues(t);
	  initCutValues(t, g);
	  updateRanks(t, g);
	}

	function updateRanks(t, g) {
	  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });
	  var vs = preorder(t, root);
	  vs = vs.slice(1);
	  _.forEach(vs, function(v) {
	    var parent = t.node(v).parent,
	      edge = g.edge(v, parent),
	      flipped = false;

	    if (!edge) {
	      edge = g.edge(parent, v);
	      flipped = true;
	    }

	    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
	  });
	}

	/*
	 * Returns true if the edge is in the tree.
	 */
	function isTreeEdge(tree, u, v) {
	  return tree.hasEdge(u, v);
	}

	/*
	 * Returns true if the specified node is descendant of the root node per the
	 * assigned low and lim attributes in the tree.
	 */
	function isDescendant(tree, vLabel, rootLabel) {
	  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
	}
	return networkSimplex_1;
}

var rank_1;
var hasRequiredRank;

function requireRank () {
	if (hasRequiredRank) return rank_1;
	hasRequiredRank = 1;

	var rankUtil = requireUtil();
	var longestPath = rankUtil.longestPath;
	var feasibleTree = requireFeasibleTree();
	var networkSimplex = requireNetworkSimplex();

	rank_1 = rank;

	/*
	 * Assigns a rank to each node in the input graph that respects the "minlen"
	 * constraint specified on edges between nodes.
	 *
	 * This basic structure is derived from Gansner, et al., "A Technique for
	 * Drawing Directed Graphs."
	 *
	 * Pre-conditions:
	 *
	 *    1. Graph must be a connected DAG
	 *    2. Graph nodes must be objects
	 *    3. Graph edges must have "weight" and "minlen" attributes
	 *
	 * Post-conditions:
	 *
	 *    1. Graph nodes will have a "rank" attribute based on the results of the
	 *       algorithm. Ranks can start at any index (including negative), we'll
	 *       fix them up later.
	 */
	function rank(g) {
	  switch(g.graph().ranker) {
	  case "network-simplex": networkSimplexRanker(g); break;
	  case "tight-tree": tightTreeRanker(g); break;
	  case "longest-path": longestPathRanker(g); break;
	  default: networkSimplexRanker(g);
	  }
	}

	// A fast and simple ranker, but results are far from optimal.
	var longestPathRanker = longestPath;

	function tightTreeRanker(g) {
	  longestPath(g);
	  feasibleTree(g);
	}

	function networkSimplexRanker(g) {
	  networkSimplex(g);
	}
	return rank_1;
}

var parentDummyChains_1;
var hasRequiredParentDummyChains;

function requireParentDummyChains () {
	if (hasRequiredParentDummyChains) return parentDummyChains_1;
	hasRequiredParentDummyChains = 1;
	var _ = requireLodash();

	parentDummyChains_1 = parentDummyChains;

	function parentDummyChains(g) {
	  var postorderNums = postorder(g);

	  _.forEach(g.graph().dummyChains, function(v) {
	    var node = g.node(v);
	    var edgeObj = node.edgeObj;
	    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
	    var path = pathData.path;
	    var lca = pathData.lca;
	    var pathIdx = 0;
	    var pathV = path[pathIdx];
	    var ascending = true;

	    while (v !== edgeObj.w) {
	      node = g.node(v);

	      if (ascending) {
	        while ((pathV = path[pathIdx]) !== lca &&
	               g.node(pathV).maxRank < node.rank) {
	          pathIdx++;
	        }

	        if (pathV === lca) {
	          ascending = false;
	        }
	      }

	      if (!ascending) {
	        while (pathIdx < path.length - 1 &&
	               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
	          pathIdx++;
	        }
	        pathV = path[pathIdx];
	      }

	      g.setParent(v, pathV);
	      v = g.successors(v)[0];
	    }
	  });
	}

	// Find a path from v to w through the lowest common ancestor (LCA). Return the
	// full path and the LCA.
	function findPath(g, postorderNums, v, w) {
	  var vPath = [];
	  var wPath = [];
	  var low = Math.min(postorderNums[v].low, postorderNums[w].low);
	  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
	  var parent;
	  var lca;

	  // Traverse up from v to find the LCA
	  parent = v;
	  do {
	    parent = g.parent(parent);
	    vPath.push(parent);
	  } while (parent &&
	           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
	  lca = parent;

	  // Traverse from w to LCA
	  parent = w;
	  while ((parent = g.parent(parent)) !== lca) {
	    wPath.push(parent);
	  }

	  return { path: vPath.concat(wPath.reverse()), lca: lca };
	}

	function postorder(g) {
	  var result = {};
	  var lim = 0;

	  function dfs(v) {
	    var low = lim;
	    _.forEach(g.children(v), dfs);
	    result[v] = { low: low, lim: lim++ };
	  }
	  _.forEach(g.children(), dfs);

	  return result;
	}
	return parentDummyChains_1;
}

var nestingGraph;
var hasRequiredNestingGraph;

function requireNestingGraph () {
	if (hasRequiredNestingGraph) return nestingGraph;
	hasRequiredNestingGraph = 1;
	var _ = requireLodash();
	var util = requireUtil$1();

	nestingGraph = {
	  run: run,
	  cleanup: cleanup
	};

	/*
	 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
	 * adds appropriate edges to ensure that all cluster nodes are placed between
	 * these boundries, and ensures that the graph is connected.
	 *
	 * In addition we ensure, through the use of the minlen property, that nodes
	 * and subgraph border nodes to not end up on the same rank.
	 *
	 * Preconditions:
	 *
	 *    1. Input graph is a DAG
	 *    2. Nodes in the input graph has a minlen attribute
	 *
	 * Postconditions:
	 *
	 *    1. Input graph is connected.
	 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
	 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
	 *       get placed on the same rank as subgraph border nodes.
	 *
	 * The nesting graph idea comes from Sander, "Layout of Compound Directed
	 * Graphs."
	 */
	function run(g) {
	  var root = util.addDummyNode(g, "root", {}, "_root");
	  var depths = treeDepths(g);
	  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array
	  var nodeSep = 2 * height + 1;

	  g.graph().nestingRoot = root;

	  // Multiply minlen by nodeSep to align nodes on non-border ranks.
	  _.forEach(g.edges(), function(e) { g.edge(e).minlen *= nodeSep; });

	  // Calculate a weight that is sufficient to keep subgraphs vertically compact
	  var weight = sumWeights(g) + 1;

	  // Create border nodes and link them up
	  _.forEach(g.children(), function(child) {
	    dfs(g, root, nodeSep, weight, height, depths, child);
	  });

	  // Save the multiplier for node layers for later removal of empty border
	  // layers.
	  g.graph().nodeRankFactor = nodeSep;
	}

	function dfs(g, root, nodeSep, weight, height, depths, v) {
	  var children = g.children(v);
	  if (!children.length) {
	    if (v !== root) {
	      g.setEdge(root, v, { weight: 0, minlen: nodeSep });
	    }
	    return;
	  }

	  var top = util.addBorderNode(g, "_bt");
	  var bottom = util.addBorderNode(g, "_bb");
	  var label = g.node(v);

	  g.setParent(top, v);
	  label.borderTop = top;
	  g.setParent(bottom, v);
	  label.borderBottom = bottom;

	  _.forEach(children, function(child) {
	    dfs(g, root, nodeSep, weight, height, depths, child);

	    var childNode = g.node(child);
	    var childTop = childNode.borderTop ? childNode.borderTop : child;
	    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
	    var thisWeight = childNode.borderTop ? weight : 2 * weight;
	    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;

	    g.setEdge(top, childTop, {
	      weight: thisWeight,
	      minlen: minlen,
	      nestingEdge: true
	    });

	    g.setEdge(childBottom, bottom, {
	      weight: thisWeight,
	      minlen: minlen,
	      nestingEdge: true
	    });
	  });

	  if (!g.parent(v)) {
	    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
	  }
	}

	function treeDepths(g) {
	  var depths = {};
	  function dfs(v, depth) {
	    var children = g.children(v);
	    if (children && children.length) {
	      _.forEach(children, function(child) {
	        dfs(child, depth + 1);
	      });
	    }
	    depths[v] = depth;
	  }
	  _.forEach(g.children(), function(v) { dfs(v, 1); });
	  return depths;
	}

	function sumWeights(g) {
	  return _.reduce(g.edges(), function(acc, e) {
	    return acc + g.edge(e).weight;
	  }, 0);
	}

	function cleanup(g) {
	  var graphLabel = g.graph();
	  g.removeNode(graphLabel.nestingRoot);
	  delete graphLabel.nestingRoot;
	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    if (edge.nestingEdge) {
	      g.removeEdge(e);
	    }
	  });
	}
	return nestingGraph;
}

var addBorderSegments_1;
var hasRequiredAddBorderSegments;

function requireAddBorderSegments () {
	if (hasRequiredAddBorderSegments) return addBorderSegments_1;
	hasRequiredAddBorderSegments = 1;
	var _ = requireLodash();
	var util = requireUtil$1();

	addBorderSegments_1 = addBorderSegments;

	function addBorderSegments(g) {
	  function dfs(v) {
	    var children = g.children(v);
	    var node = g.node(v);
	    if (children.length) {
	      _.forEach(children, dfs);
	    }

	    if (_.has(node, "minRank")) {
	      node.borderLeft = [];
	      node.borderRight = [];
	      for (var rank = node.minRank, maxRank = node.maxRank + 1;
	        rank < maxRank;
	        ++rank) {
	        addBorderNode(g, "borderLeft", "_bl", v, node, rank);
	        addBorderNode(g, "borderRight", "_br", v, node, rank);
	      }
	    }
	  }

	  _.forEach(g.children(), dfs);
	}

	function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
	  var label = { width: 0, height: 0, rank: rank, borderType: prop };
	  var prev = sgNode[prop][rank - 1];
	  var curr = util.addDummyNode(g, "border", label, prefix);
	  sgNode[prop][rank] = curr;
	  g.setParent(curr, sg);
	  if (prev) {
	    g.setEdge(prev, curr, { weight: 1 });
	  }
	}
	return addBorderSegments_1;
}

var coordinateSystem;
var hasRequiredCoordinateSystem;

function requireCoordinateSystem () {
	if (hasRequiredCoordinateSystem) return coordinateSystem;
	hasRequiredCoordinateSystem = 1;

	var _ = requireLodash();

	coordinateSystem = {
	  adjust: adjust,
	  undo: undo
	};

	function adjust(g) {
	  var rankDir = g.graph().rankdir.toLowerCase();
	  if (rankDir === "lr" || rankDir === "rl") {
	    swapWidthHeight(g);
	  }
	}

	function undo(g) {
	  var rankDir = g.graph().rankdir.toLowerCase();
	  if (rankDir === "bt" || rankDir === "rl") {
	    reverseY(g);
	  }

	  if (rankDir === "lr" || rankDir === "rl") {
	    swapXY(g);
	    swapWidthHeight(g);
	  }
	}

	function swapWidthHeight(g) {
	  _.forEach(g.nodes(), function(v) { swapWidthHeightOne(g.node(v)); });
	  _.forEach(g.edges(), function(e) { swapWidthHeightOne(g.edge(e)); });
	}

	function swapWidthHeightOne(attrs) {
	  var w = attrs.width;
	  attrs.width = attrs.height;
	  attrs.height = w;
	}

	function reverseY(g) {
	  _.forEach(g.nodes(), function(v) { reverseYOne(g.node(v)); });

	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    _.forEach(edge.points, reverseYOne);
	    if (_.has(edge, "y")) {
	      reverseYOne(edge);
	    }
	  });
	}

	function reverseYOne(attrs) {
	  attrs.y = -attrs.y;
	}

	function swapXY(g) {
	  _.forEach(g.nodes(), function(v) { swapXYOne(g.node(v)); });

	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    _.forEach(edge.points, swapXYOne);
	    if (_.has(edge, "x")) {
	      swapXYOne(edge);
	    }
	  });
	}

	function swapXYOne(attrs) {
	  var x = attrs.x;
	  attrs.x = attrs.y;
	  attrs.y = x;
	}
	return coordinateSystem;
}

var initOrder_1;
var hasRequiredInitOrder;

function requireInitOrder () {
	if (hasRequiredInitOrder) return initOrder_1;
	hasRequiredInitOrder = 1;

	var _ = requireLodash();

	initOrder_1 = initOrder;

	/*
	 * Assigns an initial order value for each node by performing a DFS search
	 * starting from nodes in the first rank. Nodes are assigned an order in their
	 * rank as they are first visited.
	 *
	 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
	 * Graphs."
	 *
	 * Returns a layering matrix with an array per layer and each layer sorted by
	 * the order of its nodes.
	 */
	function initOrder(g) {
	  var visited = {};
	  var simpleNodes = _.filter(g.nodes(), function(v) {
	    return !g.children(v).length;
	  });
	  var maxRank = _.max(_.map(simpleNodes, function(v) { return g.node(v).rank; }));
	  var layers = _.map(_.range(maxRank + 1), function() { return []; });

	  function dfs(v) {
	    if (_.has(visited, v)) return;
	    visited[v] = true;
	    var node = g.node(v);
	    layers[node.rank].push(v);
	    _.forEach(g.successors(v), dfs);
	  }

	  var orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v).rank; });
	  _.forEach(orderedVs, dfs);

	  return layers;
	}
	return initOrder_1;
}

var crossCount_1;
var hasRequiredCrossCount;

function requireCrossCount () {
	if (hasRequiredCrossCount) return crossCount_1;
	hasRequiredCrossCount = 1;

	var _ = requireLodash();

	crossCount_1 = crossCount;

	/*
	 * A function that takes a layering (an array of layers, each with an array of
	 * ordererd nodes) and a graph and returns a weighted crossing count.
	 *
	 * Pre-conditions:
	 *
	 *    1. Input graph must be simple (not a multigraph), directed, and include
	 *       only simple edges.
	 *    2. Edges in the input graph must have assigned weights.
	 *
	 * Post-conditions:
	 *
	 *    1. The graph and layering matrix are left unchanged.
	 *
	 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
	 */
	function crossCount(g, layering) {
	  var cc = 0;
	  for (var i = 1; i < layering.length; ++i) {
	    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);
	  }
	  return cc;
	}

	function twoLayerCrossCount(g, northLayer, southLayer) {
	  // Sort all of the edges between the north and south layers by their position
	  // in the north layer and then the south. Map these edges to the position of
	  // their head in the south layer.
	  var southPos = _.zipObject(southLayer,
	    _.map(southLayer, function (v, i) { return i; }));
	  var southEntries = _.flatten(_.map(northLayer, function(v) {
	    return _.sortBy(_.map(g.outEdges(v), function(e) {
	      return { pos: southPos[e.w], weight: g.edge(e).weight };
	    }), "pos");
	  }), true);

	  // Build the accumulator tree
	  var firstIndex = 1;
	  while (firstIndex < southLayer.length) firstIndex <<= 1;
	  var treeSize = 2 * firstIndex - 1;
	  firstIndex -= 1;
	  var tree = _.map(new Array(treeSize), function() { return 0; });

	  // Calculate the weighted crossings
	  var cc = 0;
	  _.forEach(southEntries.forEach(function(entry) {
	    var index = entry.pos + firstIndex;
	    tree[index] += entry.weight;
	    var weightSum = 0;
	    while (index > 0) {
	      if (index % 2) {
	        weightSum += tree[index + 1];
	      }
	      index = (index - 1) >> 1;
	      tree[index] += entry.weight;
	    }
	    cc += entry.weight * weightSum;
	  }));

	  return cc;
	}
	return crossCount_1;
}

var barycenter_1;
var hasRequiredBarycenter;

function requireBarycenter () {
	if (hasRequiredBarycenter) return barycenter_1;
	hasRequiredBarycenter = 1;
	var _ = requireLodash();

	barycenter_1 = barycenter;

	function barycenter(g, movable) {
	  return _.map(movable, function(v) {
	    var inV = g.inEdges(v);
	    if (!inV.length) {
	      return { v: v };
	    } else {
	      var result = _.reduce(inV, function(acc, e) {
	        var edge = g.edge(e),
	          nodeU = g.node(e.v);
	        return {
	          sum: acc.sum + (edge.weight * nodeU.order),
	          weight: acc.weight + edge.weight
	        };
	      }, { sum: 0, weight: 0 });

	      return {
	        v: v,
	        barycenter: result.sum / result.weight,
	        weight: result.weight
	      };
	    }
	  });
	}
	return barycenter_1;
}

var resolveConflicts_1;
var hasRequiredResolveConflicts;

function requireResolveConflicts () {
	if (hasRequiredResolveConflicts) return resolveConflicts_1;
	hasRequiredResolveConflicts = 1;

	var _ = requireLodash();

	resolveConflicts_1 = resolveConflicts;

	/*
	 * Given a list of entries of the form {v, barycenter, weight} and a
	 * constraint graph this function will resolve any conflicts between the
	 * constraint graph and the barycenters for the entries. If the barycenters for
	 * an entry would violate a constraint in the constraint graph then we coalesce
	 * the nodes in the conflict into a new node that respects the contraint and
	 * aggregates barycenter and weight information.
	 *
	 * This implementation is based on the description in Forster, "A Fast and
	 * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
	 * differs in some specific details.
	 *
	 * Pre-conditions:
	 *
	 *    1. Each entry has the form {v, barycenter, weight}, or if the node has
	 *       no barycenter, then {v}.
	 *
	 * Returns:
	 *
	 *    A new list of entries of the form {vs, i, barycenter, weight}. The list
	 *    `vs` may either be a singleton or it may be an aggregation of nodes
	 *    ordered such that they do not violate constraints from the constraint
	 *    graph. The property `i` is the lowest original index of any of the
	 *    elements in `vs`.
	 */
	function resolveConflicts(entries, cg) {
	  var mappedEntries = {};
	  _.forEach(entries, function(entry, i) {
	    var tmp = mappedEntries[entry.v] = {
	      indegree: 0,
	      "in": [],
	      out: [],
	      vs: [entry.v],
	      i: i
	    };
	    if (!_.isUndefined(entry.barycenter)) {
	      tmp.barycenter = entry.barycenter;
	      tmp.weight = entry.weight;
	    }
	  });

	  _.forEach(cg.edges(), function(e) {
	    var entryV = mappedEntries[e.v];
	    var entryW = mappedEntries[e.w];
	    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {
	      entryW.indegree++;
	      entryV.out.push(mappedEntries[e.w]);
	    }
	  });

	  var sourceSet = _.filter(mappedEntries, function(entry) {
	    return !entry.indegree;
	  });

	  return doResolveConflicts(sourceSet);
	}

	function doResolveConflicts(sourceSet) {
	  var entries = [];

	  function handleIn(vEntry) {
	    return function(uEntry) {
	      if (uEntry.merged) {
	        return;
	      }
	      if (_.isUndefined(uEntry.barycenter) ||
	          _.isUndefined(vEntry.barycenter) ||
	          uEntry.barycenter >= vEntry.barycenter) {
	        mergeEntries(vEntry, uEntry);
	      }
	    };
	  }

	  function handleOut(vEntry) {
	    return function(wEntry) {
	      wEntry["in"].push(vEntry);
	      if (--wEntry.indegree === 0) {
	        sourceSet.push(wEntry);
	      }
	    };
	  }

	  while (sourceSet.length) {
	    var entry = sourceSet.pop();
	    entries.push(entry);
	    _.forEach(entry["in"].reverse(), handleIn(entry));
	    _.forEach(entry.out, handleOut(entry));
	  }

	  return _.map(_.filter(entries, function(entry) { return !entry.merged; }),
	    function(entry) {
	      return _.pick(entry, ["vs", "i", "barycenter", "weight"]);
	    });

	}

	function mergeEntries(target, source) {
	  var sum = 0;
	  var weight = 0;

	  if (target.weight) {
	    sum += target.barycenter * target.weight;
	    weight += target.weight;
	  }

	  if (source.weight) {
	    sum += source.barycenter * source.weight;
	    weight += source.weight;
	  }

	  target.vs = source.vs.concat(target.vs);
	  target.barycenter = sum / weight;
	  target.weight = weight;
	  target.i = Math.min(source.i, target.i);
	  source.merged = true;
	}
	return resolveConflicts_1;
}

var sort_1;
var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort_1;
	hasRequiredSort = 1;
	var _ = requireLodash();
	var util = requireUtil$1();

	sort_1 = sort;

	function sort(entries, biasRight) {
	  var parts = util.partition(entries, function(entry) {
	    return _.has(entry, "barycenter");
	  });
	  var sortable = parts.lhs,
	    unsortable = _.sortBy(parts.rhs, function(entry) { return -entry.i; }),
	    vs = [],
	    sum = 0,
	    weight = 0,
	    vsIndex = 0;

	  sortable.sort(compareWithBias(!!biasRight));

	  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);

	  _.forEach(sortable, function (entry) {
	    vsIndex += entry.vs.length;
	    vs.push(entry.vs);
	    sum += entry.barycenter * entry.weight;
	    weight += entry.weight;
	    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
	  });

	  var result = { vs: _.flatten(vs, true) };
	  if (weight) {
	    result.barycenter = sum / weight;
	    result.weight = weight;
	  }
	  return result;
	}

	function consumeUnsortable(vs, unsortable, index) {
	  var last;
	  while (unsortable.length && (last = _.last(unsortable)).i <= index) {
	    unsortable.pop();
	    vs.push(last.vs);
	    index++;
	  }
	  return index;
	}

	function compareWithBias(bias) {
	  return function(entryV, entryW) {
	    if (entryV.barycenter < entryW.barycenter) {
	      return -1;
	    } else if (entryV.barycenter > entryW.barycenter) {
	      return 1;
	    }

	    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
	  };
	}
	return sort_1;
}

var sortSubgraph_1;
var hasRequiredSortSubgraph;

function requireSortSubgraph () {
	if (hasRequiredSortSubgraph) return sortSubgraph_1;
	hasRequiredSortSubgraph = 1;
	var _ = requireLodash();
	var barycenter = requireBarycenter();
	var resolveConflicts = requireResolveConflicts();
	var sort = requireSort();

	sortSubgraph_1 = sortSubgraph;

	function sortSubgraph(g, v, cg, biasRight) {
	  var movable = g.children(v);
	  var node = g.node(v);
	  var bl = node ? node.borderLeft : undefined;
	  var br = node ? node.borderRight: undefined;
	  var subgraphs = {};

	  if (bl) {
	    movable = _.filter(movable, function(w) {
	      return w !== bl && w !== br;
	    });
	  }

	  var barycenters = barycenter(g, movable);
	  _.forEach(barycenters, function(entry) {
	    if (g.children(entry.v).length) {
	      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
	      subgraphs[entry.v] = subgraphResult;
	      if (_.has(subgraphResult, "barycenter")) {
	        mergeBarycenters(entry, subgraphResult);
	      }
	    }
	  });

	  var entries = resolveConflicts(barycenters, cg);
	  expandSubgraphs(entries, subgraphs);

	  var result = sort(entries, biasRight);

	  if (bl) {
	    result.vs = _.flatten([bl, result.vs, br], true);
	    if (g.predecessors(bl).length) {
	      var blPred = g.node(g.predecessors(bl)[0]),
	        brPred = g.node(g.predecessors(br)[0]);
	      if (!_.has(result, "barycenter")) {
	        result.barycenter = 0;
	        result.weight = 0;
	      }
	      result.barycenter = (result.barycenter * result.weight +
	                           blPred.order + brPred.order) / (result.weight + 2);
	      result.weight += 2;
	    }
	  }

	  return result;
	}

	function expandSubgraphs(entries, subgraphs) {
	  _.forEach(entries, function(entry) {
	    entry.vs = _.flatten(entry.vs.map(function(v) {
	      if (subgraphs[v]) {
	        return subgraphs[v].vs;
	      }
	      return v;
	    }), true);
	  });
	}

	function mergeBarycenters(target, other) {
	  if (!_.isUndefined(target.barycenter)) {
	    target.barycenter = (target.barycenter * target.weight +
	                         other.barycenter * other.weight) /
	                        (target.weight + other.weight);
	    target.weight += other.weight;
	  } else {
	    target.barycenter = other.barycenter;
	    target.weight = other.weight;
	  }
	}
	return sortSubgraph_1;
}

var buildLayerGraph_1;
var hasRequiredBuildLayerGraph;

function requireBuildLayerGraph () {
	if (hasRequiredBuildLayerGraph) return buildLayerGraph_1;
	hasRequiredBuildLayerGraph = 1;
	var _ = requireLodash();
	var Graph = requireGraphlib().Graph;

	buildLayerGraph_1 = buildLayerGraph;

	/*
	 * Constructs a graph that can be used to sort a layer of nodes. The graph will
	 * contain all base and subgraph nodes from the request layer in their original
	 * hierarchy and any edges that are incident on these nodes and are of the type
	 * requested by the "relationship" parameter.
	 *
	 * Nodes from the requested rank that do not have parents are assigned a root
	 * node in the output graph, which is set in the root graph attribute. This
	 * makes it easy to walk the hierarchy of movable nodes during ordering.
	 *
	 * Pre-conditions:
	 *
	 *    1. Input graph is a DAG
	 *    2. Base nodes in the input graph have a rank attribute
	 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
	 *    4. Edges have an assigned weight
	 *
	 * Post-conditions:
	 *
	 *    1. Output graph has all nodes in the movable rank with preserved
	 *       hierarchy.
	 *    2. Root nodes in the movable layer are made children of the node
	 *       indicated by the root attribute of the graph.
	 *    3. Non-movable nodes incident on movable nodes, selected by the
	 *       relationship parameter, are included in the graph (without hierarchy).
	 *    4. Edges incident on movable nodes, selected by the relationship
	 *       parameter, are added to the output graph.
	 *    5. The weights for copied edges are aggregated as need, since the output
	 *       graph is not a multi-graph.
	 */
	function buildLayerGraph(g, rank, relationship) {
	  var root = createRootNode(g),
	    result = new Graph({ compound: true }).setGraph({ root: root })
	      .setDefaultNodeLabel(function(v) { return g.node(v); });

	  _.forEach(g.nodes(), function(v) {
	    var node = g.node(v),
	      parent = g.parent(v);

	    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
	      result.setNode(v);
	      result.setParent(v, parent || root);

	      // This assumes we have only short edges!
	      _.forEach(g[relationship](v), function(e) {
	        var u = e.v === v ? e.w : e.v,
	          edge = result.edge(u, v),
	          weight = !_.isUndefined(edge) ? edge.weight : 0;
	        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
	      });

	      if (_.has(node, "minRank")) {
	        result.setNode(v, {
	          borderLeft: node.borderLeft[rank],
	          borderRight: node.borderRight[rank]
	        });
	      }
	    }
	  });

	  return result;
	}

	function createRootNode(g) {
	  var v;
	  while (g.hasNode((v = _.uniqueId("_root"))));
	  return v;
	}
	return buildLayerGraph_1;
}

var addSubgraphConstraints_1;
var hasRequiredAddSubgraphConstraints;

function requireAddSubgraphConstraints () {
	if (hasRequiredAddSubgraphConstraints) return addSubgraphConstraints_1;
	hasRequiredAddSubgraphConstraints = 1;
	var _ = requireLodash();

	addSubgraphConstraints_1 = addSubgraphConstraints;

	function addSubgraphConstraints(g, cg, vs) {
	  var prev = {},
	    rootPrev;

	  _.forEach(vs, function(v) {
	    var child = g.parent(v),
	      parent,
	      prevChild;
	    while (child) {
	      parent = g.parent(child);
	      if (parent) {
	        prevChild = prev[parent];
	        prev[parent] = child;
	      } else {
	        prevChild = rootPrev;
	        rootPrev = child;
	      }
	      if (prevChild && prevChild !== child) {
	        cg.setEdge(prevChild, child);
	        return;
	      }
	      child = parent;
	    }
	  });

	  /*
	  function dfs(v) {
	    var children = v ? g.children(v) : g.children();
	    if (children.length) {
	      var min = Number.POSITIVE_INFINITY,
	          subgraphs = [];
	      _.each(children, function(child) {
	        var childMin = dfs(child);
	        if (g.children(child).length) {
	          subgraphs.push({ v: child, order: childMin });
	        }
	        min = Math.min(min, childMin);
	      });
	      _.reduce(_.sortBy(subgraphs, "order"), function(prev, curr) {
	        cg.setEdge(prev.v, curr.v);
	        return curr;
	      });
	      return min;
	    }
	    return g.node(v).order;
	  }
	  dfs(undefined);
	  */
	}
	return addSubgraphConstraints_1;
}

var order_1;
var hasRequiredOrder;

function requireOrder () {
	if (hasRequiredOrder) return order_1;
	hasRequiredOrder = 1;

	var _ = requireLodash();
	var initOrder = requireInitOrder();
	var crossCount = requireCrossCount();
	var sortSubgraph = requireSortSubgraph();
	var buildLayerGraph = requireBuildLayerGraph();
	var addSubgraphConstraints = requireAddSubgraphConstraints();
	var Graph = requireGraphlib().Graph;
	var util = requireUtil$1();

	order_1 = order;

	/*
	 * Applies heuristics to minimize edge crossings in the graph and sets the best
	 * order solution as an order attribute on each node.
	 *
	 * Pre-conditions:
	 *
	 *    1. Graph must be DAG
	 *    2. Graph nodes must be objects with a "rank" attribute
	 *    3. Graph edges must have the "weight" attribute
	 *
	 * Post-conditions:
	 *
	 *    1. Graph nodes will have an "order" attribute based on the results of the
	 *       algorithm.
	 */
	function order(g) {
	  var maxRank = util.maxRank(g),
	    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), "inEdges"),
	    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), "outEdges");

	  var layering = initOrder(g);
	  assignOrder(g, layering);

	  var bestCC = Number.POSITIVE_INFINITY,
	    best;

	  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
	    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);

	    layering = util.buildLayerMatrix(g);
	    var cc = crossCount(g, layering);
	    if (cc < bestCC) {
	      lastBest = 0;
	      best = _.cloneDeep(layering);
	      bestCC = cc;
	    }
	  }

	  assignOrder(g, best);
	}

	function buildLayerGraphs(g, ranks, relationship) {
	  return _.map(ranks, function(rank) {
	    return buildLayerGraph(g, rank, relationship);
	  });
	}

	function sweepLayerGraphs(layerGraphs, biasRight) {
	  var cg = new Graph();
	  _.forEach(layerGraphs, function(lg) {
	    var root = lg.graph().root;
	    var sorted = sortSubgraph(lg, root, cg, biasRight);
	    _.forEach(sorted.vs, function(v, i) {
	      lg.node(v).order = i;
	    });
	    addSubgraphConstraints(lg, cg, sorted.vs);
	  });
	}

	function assignOrder(g, layering) {
	  _.forEach(layering, function(layer) {
	    _.forEach(layer, function(v, i) {
	      g.node(v).order = i;
	    });
	  });
	}
	return order_1;
}

var bk;
var hasRequiredBk;

function requireBk () {
	if (hasRequiredBk) return bk;
	hasRequiredBk = 1;

	var _ = requireLodash();
	var Graph = requireGraphlib().Graph;
	var util = requireUtil$1();

	/*
	 * This module provides coordinate assignment based on Brandes and Köpf, "Fast
	 * and Simple Horizontal Coordinate Assignment."
	 */

	bk = {
	  positionX: positionX,
	  findType1Conflicts: findType1Conflicts,
	  findType2Conflicts: findType2Conflicts,
	  addConflict: addConflict,
	  hasConflict: hasConflict,
	  verticalAlignment: verticalAlignment,
	  horizontalCompaction: horizontalCompaction,
	  alignCoordinates: alignCoordinates,
	  findSmallestWidthAlignment: findSmallestWidthAlignment,
	  balance: balance
	};

	/*
	 * Marks all edges in the graph with a type-1 conflict with the "type1Conflict"
	 * property. A type-1 conflict is one where a non-inner segment crosses an
	 * inner segment. An inner segment is an edge with both incident nodes marked
	 * with the "dummy" property.
	 *
	 * This algorithm scans layer by layer, starting with the second, for type-1
	 * conflicts between the current layer and the previous layer. For each layer
	 * it scans the nodes from left to right until it reaches one that is incident
	 * on an inner segment. It then scans predecessors to determine if they have
	 * edges that cross that inner segment. At the end a final scan is done for all
	 * nodes on the current rank to see if they cross the last visited inner
	 * segment.
	 *
	 * This algorithm (safely) assumes that a dummy node will only be incident on a
	 * single node in the layers being scanned.
	 */
	function findType1Conflicts(g, layering) {
	  var conflicts = {};

	  function visitLayer(prevLayer, layer) {
	    var
	      // last visited node in the previous layer that is incident on an inner
	      // segment.
	      k0 = 0,
	      // Tracks the last node in this layer scanned for crossings with a type-1
	      // segment.
	      scanPos = 0,
	      prevLayerLength = prevLayer.length,
	      lastNode = _.last(layer);

	    _.forEach(layer, function(v, i) {
	      var w = findOtherInnerSegmentNode(g, v),
	        k1 = w ? g.node(w).order : prevLayerLength;

	      if (w || v === lastNode) {
	        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {
	          _.forEach(g.predecessors(scanNode), function(u) {
	            var uLabel = g.node(u),
	              uPos = uLabel.order;
	            if ((uPos < k0 || k1 < uPos) &&
	                !(uLabel.dummy && g.node(scanNode).dummy)) {
	              addConflict(conflicts, u, scanNode);
	            }
	          });
	        });
	        scanPos = i + 1;
	        k0 = k1;
	      }
	    });

	    return layer;
	  }

	  _.reduce(layering, visitLayer);
	  return conflicts;
	}

	function findType2Conflicts(g, layering) {
	  var conflicts = {};

	  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
	    var v;
	    _.forEach(_.range(southPos, southEnd), function(i) {
	      v = south[i];
	      if (g.node(v).dummy) {
	        _.forEach(g.predecessors(v), function(u) {
	          var uNode = g.node(u);
	          if (uNode.dummy &&
	              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
	            addConflict(conflicts, u, v);
	          }
	        });
	      }
	    });
	  }


	  function visitLayer(north, south) {
	    var prevNorthPos = -1,
	      nextNorthPos,
	      southPos = 0;

	    _.forEach(south, function(v, southLookahead) {
	      if (g.node(v).dummy === "border") {
	        var predecessors = g.predecessors(v);
	        if (predecessors.length) {
	          nextNorthPos = g.node(predecessors[0]).order;
	          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
	          southPos = southLookahead;
	          prevNorthPos = nextNorthPos;
	        }
	      }
	      scan(south, southPos, south.length, nextNorthPos, north.length);
	    });

	    return south;
	  }

	  _.reduce(layering, visitLayer);
	  return conflicts;
	}

	function findOtherInnerSegmentNode(g, v) {
	  if (g.node(v).dummy) {
	    return _.find(g.predecessors(v), function(u) {
	      return g.node(u).dummy;
	    });
	  }
	}

	function addConflict(conflicts, v, w) {
	  if (v > w) {
	    var tmp = v;
	    v = w;
	    w = tmp;
	  }

	  var conflictsV = conflicts[v];
	  if (!conflictsV) {
	    conflicts[v] = conflictsV = {};
	  }
	  conflictsV[w] = true;
	}

	function hasConflict(conflicts, v, w) {
	  if (v > w) {
	    var tmp = v;
	    v = w;
	    w = tmp;
	  }
	  return _.has(conflicts[v], w);
	}

	/*
	 * Try to align nodes into vertical "blocks" where possible. This algorithm
	 * attempts to align a node with one of its median neighbors. If the edge
	 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
	 * If a previous node has already formed a block with a node after the node
	 * we're trying to form a block with, we also ignore that possibility - our
	 * blocks would be split in that scenario.
	 */
	function verticalAlignment(g, layering, conflicts, neighborFn) {
	  var root = {},
	    align = {},
	    pos = {};

	  // We cache the position here based on the layering because the graph and
	  // layering may be out of sync. The layering matrix is manipulated to
	  // generate different extreme alignments.
	  _.forEach(layering, function(layer) {
	    _.forEach(layer, function(v, order) {
	      root[v] = v;
	      align[v] = v;
	      pos[v] = order;
	    });
	  });

	  _.forEach(layering, function(layer) {
	    var prevIdx = -1;
	    _.forEach(layer, function(v) {
	      var ws = neighborFn(v);
	      if (ws.length) {
	        ws = _.sortBy(ws, function(w) { return pos[w]; });
	        var mp = (ws.length - 1) / 2;
	        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
	          var w = ws[i];
	          if (align[v] === v &&
	              prevIdx < pos[w] &&
	              !hasConflict(conflicts, v, w)) {
	            align[w] = v;
	            align[v] = root[v] = root[w];
	            prevIdx = pos[w];
	          }
	        }
	      }
	    });
	  });

	  return { root: root, align: align };
	}

	function horizontalCompaction(g, layering, root, align, reverseSep) {
	  // This portion of the algorithm differs from BK due to a number of problems.
	  // Instead of their algorithm we construct a new block graph and do two
	  // sweeps. The first sweep places blocks with the smallest possible
	  // coordinates. The second sweep removes unused space by moving blocks to the
	  // greatest coordinates without violating separation.
	  var xs = {},
	    blockG = buildBlockGraph(g, layering, root, reverseSep),
	    borderType = reverseSep ? "borderLeft" : "borderRight";

	  function iterate(setXsFunc, nextNodesFunc) {
	    var stack = blockG.nodes();
	    var elem = stack.pop();
	    var visited = {};
	    while (elem) {
	      if (visited[elem]) {
	        setXsFunc(elem);
	      } else {
	        visited[elem] = true;
	        stack.push(elem);
	        stack = stack.concat(nextNodesFunc(elem));
	      }

	      elem = stack.pop();
	    }
	  }

	  // First pass, assign smallest coordinates
	  function pass1(elem) {
	    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
	      return Math.max(acc, xs[e.v] + blockG.edge(e));
	    }, 0);
	  }

	  // Second pass, assign greatest coordinates
	  function pass2(elem) {
	    var min = blockG.outEdges(elem).reduce(function(acc, e) {
	      return Math.min(acc, xs[e.w] - blockG.edge(e));
	    }, Number.POSITIVE_INFINITY);

	    var node = g.node(elem);
	    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
	      xs[elem] = Math.max(xs[elem], min);
	    }
	  }

	  iterate(pass1, blockG.predecessors.bind(blockG));
	  iterate(pass2, blockG.successors.bind(blockG));

	  // Assign x coordinates to all nodes
	  _.forEach(align, function(v) {
	    xs[v] = xs[root[v]];
	  });

	  return xs;
	}


	function buildBlockGraph(g, layering, root, reverseSep) {
	  var blockGraph = new Graph(),
	    graphLabel = g.graph(),
	    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);

	  _.forEach(layering, function(layer) {
	    var u;
	    _.forEach(layer, function(v) {
	      var vRoot = root[v];
	      blockGraph.setNode(vRoot);
	      if (u) {
	        var uRoot = root[u],
	          prevMax = blockGraph.edge(uRoot, vRoot);
	        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
	      }
	      u = v;
	    });
	  });

	  return blockGraph;
	}

	/*
	 * Returns the alignment that has the smallest width of the given alignments.
	 */
	function findSmallestWidthAlignment(g, xss) {
	  return _.minBy(_.values(xss), function (xs) {
	    var max = Number.NEGATIVE_INFINITY;
	    var min = Number.POSITIVE_INFINITY;

	    _.forIn(xs, function (x, v) {
	      var halfWidth = width(g, v) / 2;

	      max = Math.max(x + halfWidth, max);
	      min = Math.min(x - halfWidth, min);
	    });

	    return max - min;
	  });
	}

	/*
	 * Align the coordinates of each of the layout alignments such that
	 * left-biased alignments have their minimum coordinate at the same point as
	 * the minimum coordinate of the smallest width alignment and right-biased
	 * alignments have their maximum coordinate at the same point as the maximum
	 * coordinate of the smallest width alignment.
	 */
	function alignCoordinates(xss, alignTo) {
	  var alignToVals = _.values(alignTo),
	    alignToMin = _.min(alignToVals),
	    alignToMax = _.max(alignToVals);

	  _.forEach(["u", "d"], function(vert) {
	    _.forEach(["l", "r"], function(horiz) {
	      var alignment = vert + horiz,
	        xs = xss[alignment],
	        delta;
	      if (xs === alignTo) return;

	      var xsVals = _.values(xs);
	      delta = horiz === "l" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);

	      if (delta) {
	        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });
	      }
	    });
	  });
	}

	function balance(xss, align) {
	  return _.mapValues(xss.ul, function(ignore, v) {
	    if (align) {
	      return xss[align.toLowerCase()][v];
	    } else {
	      var xs = _.sortBy(_.map(xss, v));
	      return (xs[1] + xs[2]) / 2;
	    }
	  });
	}

	function positionX(g) {
	  var layering = util.buildLayerMatrix(g);
	  var conflicts = _.merge(
	    findType1Conflicts(g, layering),
	    findType2Conflicts(g, layering));

	  var xss = {};
	  var adjustedLayering;
	  _.forEach(["u", "d"], function(vert) {
	    adjustedLayering = vert === "u" ? layering : _.values(layering).reverse();
	    _.forEach(["l", "r"], function(horiz) {
	      if (horiz === "r") {
	        adjustedLayering = _.map(adjustedLayering, function(inner) {
	          return _.values(inner).reverse();
	        });
	      }

	      var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
	      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
	      var xs = horizontalCompaction(g, adjustedLayering,
	        align.root, align.align, horiz === "r");
	      if (horiz === "r") {
	        xs = _.mapValues(xs, function(x) { return -x; });
	      }
	      xss[vert + horiz] = xs;
	    });
	  });

	  var smallestWidth = findSmallestWidthAlignment(g, xss);
	  alignCoordinates(xss, smallestWidth);
	  return balance(xss, g.graph().align);
	}

	function sep(nodeSep, edgeSep, reverseSep) {
	  return function(g, v, w) {
	    var vLabel = g.node(v);
	    var wLabel = g.node(w);
	    var sum = 0;
	    var delta;

	    sum += vLabel.width / 2;
	    if (_.has(vLabel, "labelpos")) {
	      switch (vLabel.labelpos.toLowerCase()) {
	      case "l": delta = -vLabel.width / 2; break;
	      case "r": delta = vLabel.width / 2; break;
	      }
	    }
	    if (delta) {
	      sum += reverseSep ? delta : -delta;
	    }
	    delta = 0;

	    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
	    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;

	    sum += wLabel.width / 2;
	    if (_.has(wLabel, "labelpos")) {
	      switch (wLabel.labelpos.toLowerCase()) {
	      case "l": delta = wLabel.width / 2; break;
	      case "r": delta = -wLabel.width / 2; break;
	      }
	    }
	    if (delta) {
	      sum += reverseSep ? delta : -delta;
	    }
	    delta = 0;

	    return sum;
	  };
	}

	function width(g, v) {
	  return g.node(v).width;
	}
	return bk;
}

var position_1;
var hasRequiredPosition;

function requirePosition () {
	if (hasRequiredPosition) return position_1;
	hasRequiredPosition = 1;

	var _ = requireLodash();
	var util = requireUtil$1();
	var positionX = requireBk().positionX;

	position_1 = position;

	function position(g) {
	  g = util.asNonCompoundGraph(g);

	  positionY(g);
	  _.forEach(positionX(g), function(x, v) {
	    g.node(v).x = x;
	  });
	}

	function positionY(g) {
	  var layering = util.buildLayerMatrix(g);
	  var rankSep = g.graph().ranksep;
	  var prevY = 0;
	  _.forEach(layering, function(layer) {
	    var maxHeight = _.max(_.map(layer, function(v) { return g.node(v).height; }));
	    _.forEach(layer, function(v) {
	      g.node(v).y = prevY + maxHeight / 2;
	    });
	    prevY += maxHeight + rankSep;
	  });
	}
	return position_1;
}

var layout_1;
var hasRequiredLayout;

function requireLayout () {
	if (hasRequiredLayout) return layout_1;
	hasRequiredLayout = 1;

	var _ = requireLodash();
	var acyclic = requireAcyclic();
	var normalize = requireNormalize();
	var rank = requireRank();
	var normalizeRanks = requireUtil$1().normalizeRanks;
	var parentDummyChains = requireParentDummyChains();
	var removeEmptyRanks = requireUtil$1().removeEmptyRanks;
	var nestingGraph = requireNestingGraph();
	var addBorderSegments = requireAddBorderSegments();
	var coordinateSystem = requireCoordinateSystem();
	var order = requireOrder();
	var position = requirePosition();
	var util = requireUtil$1();
	var Graph = requireGraphlib().Graph;

	layout_1 = layout;

	function layout(g, opts) {
	  var time = opts && opts.debugTiming ? util.time : util.notime;
	  time("layout", function() {
	    var layoutGraph = 
	      time("  buildLayoutGraph", function() { return buildLayoutGraph(g); });
	    time("  runLayout",        function() { runLayout(layoutGraph, time); });
	    time("  updateInputGraph", function() { updateInputGraph(g, layoutGraph); });
	  });
	}

	function runLayout(g, time) {
	  time("    makeSpaceForEdgeLabels", function() { makeSpaceForEdgeLabels(g); });
	  time("    removeSelfEdges",        function() { removeSelfEdges(g); });
	  time("    acyclic",                function() { acyclic.run(g); });
	  time("    nestingGraph.run",       function() { nestingGraph.run(g); });
	  time("    rank",                   function() { rank(util.asNonCompoundGraph(g)); });
	  time("    injectEdgeLabelProxies", function() { injectEdgeLabelProxies(g); });
	  time("    removeEmptyRanks",       function() { removeEmptyRanks(g); });
	  time("    nestingGraph.cleanup",   function() { nestingGraph.cleanup(g); });
	  time("    normalizeRanks",         function() { normalizeRanks(g); });
	  time("    assignRankMinMax",       function() { assignRankMinMax(g); });
	  time("    removeEdgeLabelProxies", function() { removeEdgeLabelProxies(g); });
	  time("    normalize.run",          function() { normalize.run(g); });
	  time("    parentDummyChains",      function() { parentDummyChains(g); });
	  time("    addBorderSegments",      function() { addBorderSegments(g); });
	  time("    order",                  function() { order(g); });
	  time("    insertSelfEdges",        function() { insertSelfEdges(g); });
	  time("    adjustCoordinateSystem", function() { coordinateSystem.adjust(g); });
	  time("    position",               function() { position(g); });
	  time("    positionSelfEdges",      function() { positionSelfEdges(g); });
	  time("    removeBorderNodes",      function() { removeBorderNodes(g); });
	  time("    normalize.undo",         function() { normalize.undo(g); });
	  time("    fixupEdgeLabelCoords",   function() { fixupEdgeLabelCoords(g); });
	  time("    undoCoordinateSystem",   function() { coordinateSystem.undo(g); });
	  time("    translateGraph",         function() { translateGraph(g); });
	  time("    assignNodeIntersects",   function() { assignNodeIntersects(g); });
	  time("    reversePoints",          function() { reversePointsForReversedEdges(g); });
	  time("    acyclic.undo",           function() { acyclic.undo(g); });
	}

	/*
	 * Copies final layout information from the layout graph back to the input
	 * graph. This process only copies whitelisted attributes from the layout graph
	 * to the input graph, so it serves as a good place to determine what
	 * attributes can influence layout.
	 */
	function updateInputGraph(inputGraph, layoutGraph) {
	  _.forEach(inputGraph.nodes(), function(v) {
	    var inputLabel = inputGraph.node(v);
	    var layoutLabel = layoutGraph.node(v);

	    if (inputLabel) {
	      inputLabel.x = layoutLabel.x;
	      inputLabel.y = layoutLabel.y;

	      if (layoutGraph.children(v).length) {
	        inputLabel.width = layoutLabel.width;
	        inputLabel.height = layoutLabel.height;
	      }
	    }
	  });

	  _.forEach(inputGraph.edges(), function(e) {
	    var inputLabel = inputGraph.edge(e);
	    var layoutLabel = layoutGraph.edge(e);

	    inputLabel.points = layoutLabel.points;
	    if (_.has(layoutLabel, "x")) {
	      inputLabel.x = layoutLabel.x;
	      inputLabel.y = layoutLabel.y;
	    }
	  });

	  inputGraph.graph().width = layoutGraph.graph().width;
	  inputGraph.graph().height = layoutGraph.graph().height;
	}

	var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
	var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
	var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
	var nodeNumAttrs = ["width", "height"];
	var nodeDefaults = { width: 0, height: 0 };
	var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
	var edgeDefaults = {
	  minlen: 1, weight: 1, width: 0, height: 0,
	  labeloffset: 10, labelpos: "r"
	};
	var edgeAttrs = ["labelpos"];

	/*
	 * Constructs a new graph from the input graph, which can be used for layout.
	 * This process copies only whitelisted attributes from the input graph to the
	 * layout graph. Thus this function serves as a good place to determine what
	 * attributes can influence layout.
	 */
	function buildLayoutGraph(inputGraph) {
	  var g = new Graph({ multigraph: true, compound: true });
	  var graph = canonicalize(inputGraph.graph());

	  g.setGraph(_.merge({},
	    graphDefaults,
	    selectNumberAttrs(graph, graphNumAttrs),
	    _.pick(graph, graphAttrs)));

	  _.forEach(inputGraph.nodes(), function(v) {
	    var node = canonicalize(inputGraph.node(v));
	    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
	    g.setParent(v, inputGraph.parent(v));
	  });

	  _.forEach(inputGraph.edges(), function(e) {
	    var edge = canonicalize(inputGraph.edge(e));
	    g.setEdge(e, _.merge({},
	      edgeDefaults,
	      selectNumberAttrs(edge, edgeNumAttrs),
	      _.pick(edge, edgeAttrs)));
	  });

	  return g;
	}

	/*
	 * This idea comes from the Gansner paper: to account for edge labels in our
	 * layout we split each rank in half by doubling minlen and halving ranksep.
	 * Then we can place labels at these mid-points between nodes.
	 *
	 * We also add some minimal padding to the width to push the label for the edge
	 * away from the edge itself a bit.
	 */
	function makeSpaceForEdgeLabels(g) {
	  var graph = g.graph();
	  graph.ranksep /= 2;
	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    edge.minlen *= 2;
	    if (edge.labelpos.toLowerCase() !== "c") {
	      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
	        edge.width += edge.labeloffset;
	      } else {
	        edge.height += edge.labeloffset;
	      }
	    }
	  });
	}

	/*
	 * Creates temporary dummy nodes that capture the rank in which each edge's
	 * label is going to, if it has one of non-zero width and height. We do this
	 * so that we can safely remove empty ranks while preserving balance for the
	 * label's position.
	 */
	function injectEdgeLabelProxies(g) {
	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    if (edge.width && edge.height) {
	      var v = g.node(e.v);
	      var w = g.node(e.w);
	      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };
	      util.addDummyNode(g, "edge-proxy", label, "_ep");
	    }
	  });
	}

	function assignRankMinMax(g) {
	  var maxRank = 0;
	  _.forEach(g.nodes(), function(v) {
	    var node = g.node(v);
	    if (node.borderTop) {
	      node.minRank = g.node(node.borderTop).rank;
	      node.maxRank = g.node(node.borderBottom).rank;
	      maxRank = _.max(maxRank, node.maxRank);
	    }
	  });
	  g.graph().maxRank = maxRank;
	}

	function removeEdgeLabelProxies(g) {
	  _.forEach(g.nodes(), function(v) {
	    var node = g.node(v);
	    if (node.dummy === "edge-proxy") {
	      g.edge(node.e).labelRank = node.rank;
	      g.removeNode(v);
	    }
	  });
	}

	function translateGraph(g) {
	  var minX = Number.POSITIVE_INFINITY;
	  var maxX = 0;
	  var minY = Number.POSITIVE_INFINITY;
	  var maxY = 0;
	  var graphLabel = g.graph();
	  var marginX = graphLabel.marginx || 0;
	  var marginY = graphLabel.marginy || 0;

	  function getExtremes(attrs) {
	    var x = attrs.x;
	    var y = attrs.y;
	    var w = attrs.width;
	    var h = attrs.height;
	    minX = Math.min(minX, x - w / 2);
	    maxX = Math.max(maxX, x + w / 2);
	    minY = Math.min(minY, y - h / 2);
	    maxY = Math.max(maxY, y + h / 2);
	  }

	  _.forEach(g.nodes(), function(v) { getExtremes(g.node(v)); });
	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    if (_.has(edge, "x")) {
	      getExtremes(edge);
	    }
	  });

	  minX -= marginX;
	  minY -= marginY;

	  _.forEach(g.nodes(), function(v) {
	    var node = g.node(v);
	    node.x -= minX;
	    node.y -= minY;
	  });

	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    _.forEach(edge.points, function(p) {
	      p.x -= minX;
	      p.y -= minY;
	    });
	    if (_.has(edge, "x")) { edge.x -= minX; }
	    if (_.has(edge, "y")) { edge.y -= minY; }
	  });

	  graphLabel.width = maxX - minX + marginX;
	  graphLabel.height = maxY - minY + marginY;
	}

	function assignNodeIntersects(g) {
	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    var nodeV = g.node(e.v);
	    var nodeW = g.node(e.w);
	    var p1, p2;
	    if (!edge.points) {
	      edge.points = [];
	      p1 = nodeW;
	      p2 = nodeV;
	    } else {
	      p1 = edge.points[0];
	      p2 = edge.points[edge.points.length - 1];
	    }
	    edge.points.unshift(util.intersectRect(nodeV, p1));
	    edge.points.push(util.intersectRect(nodeW, p2));
	  });
	}

	function fixupEdgeLabelCoords(g) {
	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    if (_.has(edge, "x")) {
	      if (edge.labelpos === "l" || edge.labelpos === "r") {
	        edge.width -= edge.labeloffset;
	      }
	      switch (edge.labelpos) {
	      case "l": edge.x -= edge.width / 2 + edge.labeloffset; break;
	      case "r": edge.x += edge.width / 2 + edge.labeloffset; break;
	      }
	    }
	  });
	}

	function reversePointsForReversedEdges(g) {
	  _.forEach(g.edges(), function(e) {
	    var edge = g.edge(e);
	    if (edge.reversed) {
	      edge.points.reverse();
	    }
	  });
	}

	function removeBorderNodes(g) {
	  _.forEach(g.nodes(), function(v) {
	    if (g.children(v).length) {
	      var node = g.node(v);
	      var t = g.node(node.borderTop);
	      var b = g.node(node.borderBottom);
	      var l = g.node(_.last(node.borderLeft));
	      var r = g.node(_.last(node.borderRight));

	      node.width = Math.abs(r.x - l.x);
	      node.height = Math.abs(b.y - t.y);
	      node.x = l.x + node.width / 2;
	      node.y = t.y + node.height / 2;
	    }
	  });

	  _.forEach(g.nodes(), function(v) {
	    if (g.node(v).dummy === "border") {
	      g.removeNode(v);
	    }
	  });
	}

	function removeSelfEdges(g) {
	  _.forEach(g.edges(), function(e) {
	    if (e.v === e.w) {
	      var node = g.node(e.v);
	      if (!node.selfEdges) {
	        node.selfEdges = [];
	      }
	      node.selfEdges.push({ e: e, label: g.edge(e) });
	      g.removeEdge(e);
	    }
	  });
	}

	function insertSelfEdges(g) {
	  var layers = util.buildLayerMatrix(g);
	  _.forEach(layers, function(layer) {
	    var orderShift = 0;
	    _.forEach(layer, function(v, i) {
	      var node = g.node(v);
	      node.order = i + orderShift;
	      _.forEach(node.selfEdges, function(selfEdge) {
	        util.addDummyNode(g, "selfedge", {
	          width: selfEdge.label.width,
	          height: selfEdge.label.height,
	          rank: node.rank,
	          order: i + (++orderShift),
	          e: selfEdge.e,
	          label: selfEdge.label
	        }, "_se");
	      });
	      delete node.selfEdges;
	    });
	  });
	}

	function positionSelfEdges(g) {
	  _.forEach(g.nodes(), function(v) {
	    var node = g.node(v);
	    if (node.dummy === "selfedge") {
	      var selfNode = g.node(node.e.v);
	      var x = selfNode.x + selfNode.width / 2;
	      var y = selfNode.y;
	      var dx = node.x - x;
	      var dy = selfNode.height / 2;
	      g.setEdge(node.e, node.label);
	      g.removeNode(v);
	      node.label.points = [
	        { x: x + 2 * dx / 3, y: y - dy },
	        { x: x + 5 * dx / 6, y: y - dy },
	        { x: x +     dx    , y: y },
	        { x: x + 5 * dx / 6, y: y + dy },
	        { x: x + 2 * dx / 3, y: y + dy }
	      ];
	      node.label.x = node.x;
	      node.label.y = node.y;
	    }
	  });
	}

	function selectNumberAttrs(obj, attrs) {
	  return _.mapValues(_.pick(obj, attrs), Number);
	}

	function canonicalize(attrs) {
	  var newAttrs = {};
	  _.forEach(attrs, function(v, k) {
	    newAttrs[k.toLowerCase()] = v;
	  });
	  return newAttrs;
	}
	return layout_1;
}

var debug;
var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug;
	hasRequiredDebug = 1;
	var _ = requireLodash();
	var util = requireUtil$1();
	var Graph = requireGraphlib().Graph;

	debug = {
	  debugOrdering: debugOrdering
	};

	/* istanbul ignore next */
	function debugOrdering(g) {
	  var layerMatrix = util.buildLayerMatrix(g);

	  var h = new Graph({ compound: true, multigraph: true }).setGraph({});

	  _.forEach(g.nodes(), function(v) {
	    h.setNode(v, { label: v });
	    h.setParent(v, "layer" + g.node(v).rank);
	  });

	  _.forEach(g.edges(), function(e) {
	    h.setEdge(e.v, e.w, {}, e.name);
	  });

	  _.forEach(layerMatrix, function(layer, i) {
	    var layerV = "layer" + i;
	    h.setNode(layerV, { rank: "same" });
	    _.reduce(layer, function(u, v) {
	      h.setEdge(u, v, { style: "invis" });
	      return v;
	    });
	  });

	  return h;
	}
	return debug;
}

var version;
var hasRequiredVersion;

function requireVersion () {
	if (hasRequiredVersion) return version;
	hasRequiredVersion = 1;
	version = "0.8.5";
	return version;
}

/*
Copyright (c) 2012-2014 Chris Pettitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

var dagre$1;
var hasRequiredDagre;

function requireDagre () {
	if (hasRequiredDagre) return dagre$1;
	hasRequiredDagre = 1;
	dagre$1 = {
	  graphlib: requireGraphlib(),

	  layout: requireLayout(),
	  debug: requireDebug(),
	  util: {
	    time: requireUtil$1().time,
	    notime: requireUtil$1().notime
	  },
	  version: requireVersion()
	};
	return dagre$1;
}

var dagreExports = requireDagre();
const dagre = /*@__PURE__*/getDefaultExportFromCjs(dagreExports);

// 節點尺寸計算工具函數

/**
 * 動態計算節點尺寸，考慮節點內容
 * @param {Object} node - 節點對象
 * @returns {Object} - {width, height}
 */
const calculateNodeDimensions = (node) => {
  const baseWidth = 256;
  const baseHeight = 120;

  switch (node.type) {
    case 'webhook_input': {
      const hasCurlExample = node.data?.curl_example;
      return {
        width: baseWidth + 32,
        height: hasCurlExample ? baseHeight + 80 : baseHeight + 40 // 200 : 160
      };
    }
    case 'schedule_trigger': {
      // 基礎高度包含：標題、類型選擇、指定時間、時區、任務描述 // Schedule node 尺寸計算
      const baseScheduleHeight = 280;

      // 檢查排程類型
      const scheduleType = node.data?.schedule_type || 'one_time';

      if (scheduleType === 'one_time') {
        // 一次性排程：需要日期時間選擇器
        return {
          width: baseWidth + 64, // 320px，比基礎寬度多 64px 容納日期選擇器
          height: baseScheduleHeight + 80 // 360px，額外空間給日期時間選擇器
        };
      } else if (scheduleType === 'recurring') {
        // 週期性排程：需要額外的重複設定選項
        const hasAdvancedRecurring = node.data?.advanced_recurring || false;
        return {
          width: baseWidth + 64, // 320px
          height: hasAdvancedRecurring
            ? baseScheduleHeight + 140 // 420px，進階重複設定需要更多空間
            : baseScheduleHeight + 100 // 380px，基本重複設定
        };
      } else if (scheduleType === 'cron') {
        // Cron 表達式：需要額外空間顯示 cron 輸入和說明
        return {
          width: baseWidth + 64, // 320px
          height: baseScheduleHeight + 120 // 400px，cron 表達式和說明需要額外空間
        };
      }

      // 預設回傳基礎尺寸
      return {
        width: baseWidth + 64, // 320px
        height: baseScheduleHeight // 280px
      };
    }
    case 'customInput': {
      // 根據欄位數量調整高度
      const fieldCount = node.data?.fields?.length || 1;
      return {
        width: baseWidth,
        height: Math.max(baseHeight + 60, baseHeight + fieldCount * 80)
      };
    }

    case 'aiCustomInput':
      return {
        width: baseWidth,
        height: baseHeight + 100 // 220
      };

    case 'browserExtensionInput': {
      // 根據項目數量動態調整高度
      const itemCount = node.data?.items?.length || 1;
      return {
        width: baseWidth,
        height: Math.max(baseHeight + 130, baseHeight + 60 + itemCount * 120)
      };
    }

    case 'browserExtensionOutput': {
      // 根據輸入 handle 數量動態調整高度
      const handleCount = node.data?.inputHandles?.length || 1;
      return {
        width: baseWidth,
        height: Math.max(baseHeight + 80, baseHeight + 30 + handleCount * 50)
      };
    }

    case 'webhook_output': {
      // 根據輸入 handle 數量動態調整高度
      const handleCount = node.data?.inputHandles?.length || 1;
      return {
        width: baseWidth,
        height: Math.max(baseHeight + 80, baseHeight + 30 + handleCount * 50)
      };
    }

    case 'extract_data': {
      // 新增：根據 columns 數量動態調整 ExtractDataNode 高度
      const columnCount = node.data?.columns?.length || 0;
      const baseExtractHeight = 280; // 基礎高度（包含header、model選擇、context等）

      if (columnCount === 0) {
        // 沒有欄位時顯示提示區域
        return {
          width: 386, // w-98 = 3846x
          height: baseExtractHeight + 60 // 提示區域高度
        };
      }

      // 每個欄位大約需要 80px 高度（包含間距）
      const columnsHeight = columnCount * 80;

      return {
        width: 384, // w-96 = 384px，與實際組件寬度一致
        height: baseExtractHeight + columnsHeight + 40 // 額外留一些緩衝空間
      };
    }

    case 'aim_ml': {
      // QOCA AIM 節點尺寸計算
      const baseAimWidth = 320; // w-80 = 320px
      const baseAimHeight = 180; // 基礎高度：header + AIM選擇 + 開關

      // 檢查是否啟用解釋功能
      const enableExplain = node.data?.enable_explain?.data ?? true;

      if (!enableExplain) {
        // 解釋功能關閉時：只有基礎內容
        return {
          width: baseAimWidth,
          height: baseAimHeight
        };
      }

      // 解釋功能開啟時：需要額外空間給 LLM 選擇和 Prompt 輸入
      const llmSectionHeight = 60; // LLM 下拉選單

      // 如果有 prompt 文字，根據長度動態調整高度
      const promptText = node.data?.prompt?.data || '';
      const estimatedPromptHeight = Math.max(
        120,
        Math.min(200, 120 + Math.floor(promptText.length / 60) * 20)
      );

      return {
        width: baseAimWidth,
        height: baseAimHeight + llmSectionHeight + estimatedPromptHeight
      };
    }

    case 'line_webhook_input':
      return {
        width: 320, // Line 節點較寬
        height: baseHeight + 60 // 180
      };

    case 'line_send_message':
      return {
        width: 320, // Line 節點較寬
        height: baseHeight + 80 // 200
      };

    case 'ifElse':
      return {
        width: baseWidth,
        height: baseHeight + 60 // 180
      };

    case 'knowledgeRetrieval':
      return {
        width: baseWidth,
        height: baseHeight + 40 // 160
      };

    case 'end':
      return {
        width: baseWidth,
        height: baseHeight + 20 // 140
      };

    case 'webhook': {
      // 根據是否有 URL 調整高度
      const hasUrl = node.data?.webhookUrl;
      return {
        width: baseWidth,
        height: hasUrl ? baseHeight + 60 : baseHeight + 40 // 180 : 160
      };
    }

    case 'httpRequest': {
      // HTTP Request 節點尺寸計算
      const hasHeaders = node.data?.headers && node.data.headers.length > 0;
      const hasBody =
        node.data?.body && ['POST', 'PUT', 'PATCH'].includes(node.data?.method);
      const headerCount = hasHeaders ? node.data.headers.length : 1;

      let height = baseHeight + 120; // 基礎高度：URL + Method

      // Headers 區域高度
      height += 60; // Headers 標籤和按鈕
      height += headerCount * 45; // 每個 header 約 45px

      // Body 區域高度（僅在支援的方法時）
      if (hasBody) {
        height += 100; // Body 區域
      }

      return {
        width: baseWidth + 32, // 稍微寬一點容納更多內容
        height: Math.max(280, height) // 最小高度 280px
      };
    }

    case 'timer':
      return {
        width: baseWidth,
        height: baseHeight + 80 // 200
      };

    case 'event':
      return {
        width: baseWidth,
        height: baseHeight + 60 // 180
      };

    default:
      return {
        width: baseWidth * 0.78, // 200
        height: baseHeight - 20 // 100
      };
  }
};

/**
 * 根據排版方向調整間距參數
 * @param {string} direction - 排版方向 (TB, BT, LR, RL)
 * @returns {Object} - dagre 佈局配置
 */
const getLayoutConfig = (direction) => {
  const baseConfig = {
    rankdir: direction,
    align: 'UL', // 對齊方式，減少交叉
    ranker: 'tight-tree', // 使用緊密樹狀排列，減少交叉
    marginx: 100,
    marginy: 100
  };

  switch (direction) {
    case 'LR': // 左到右
      return {
        ...baseConfig,
        align: 'UL', // 上左對齊
        nodesep: 160, // 增加垂直間距，考慮到 QOCA AIM 和 ExtractDataNode 的較大尺寸
        edgesep: 90, // 增加邊緣間距
        ranksep: 240, // 大幅增加水平間距，適應較寬的節點
        marginx: 160,
        marginy: 160,
        acyclicer: 'greedy', // 使用貪婪算法減少循環
        ranker: 'tight-tree' // 緊密樹狀排列
      };

    case 'RL': // 右到左
      return {
        ...baseConfig,
        align: 'UR', // 上右對齊
        nodesep: 160,
        edgesep: 90,
        ranksep: 240,
        marginx: 160,
        marginy: 160,
        acyclicer: 'greedy',
        ranker: 'tight-tree'
      };

    case 'TB': // 上到下（默認）
      return {
        ...baseConfig,
        align: 'UL', // 上左對齊
        nodesep: 190, // 增加水平間距，適應 QOCA AIM 和 ExtractDataNode 的較大寬度
        edgesep: 80,
        ranksep: 180, // 增加垂直間距，適應動態高度的節點
        marginx: 160,
        marginy: 140,
        acyclicer: 'greedy',
        ranker: 'tight-tree'
      };

    case 'BT': // 下到上
      return {
        ...baseConfig,
        align: 'DL', // 下左對齊
        nodesep: 190,
        edgesep: 80,
        ranksep: 180,
        marginx: 160,
        marginy: 140,
        acyclicer: 'greedy',
        ranker: 'tight-tree'
      };

    default:
      return {
        ...baseConfig,
        align: 'UL',
        nodesep: 160,
        edgesep: 80,
        ranksep: 180,
        marginx: 140,
        marginy: 140,
        acyclicer: 'greedy',
        ranker: 'tight-tree'
      };
  }
};

/**
 * 計算節點最小所需空間
 * @param {Array} nodes - 節點數組
 * @returns {Object} - {totalWidth, totalHeight, avgWidth, avgHeight}
 */
const calculateCanvasSpace = (nodes) => {
  if (!nodes || nodes.length === 0) {
    return { totalWidth: 0, totalHeight: 0, avgWidth: 0, avgHeight: 0 };
  }

  let totalWidth = 0;
  let totalHeight = 0;

  nodes.forEach((node) => {
    const dimensions = calculateNodeDimensions(node);
    totalWidth += dimensions.width;
    totalHeight += dimensions.height;
  });

  return {
    totalWidth,
    totalHeight,
    avgWidth: totalWidth / nodes.length,
    avgHeight: totalHeight / nodes.length
  };
};

/**
 * 預估自動排版所需的畫布尺寸
 * @param {Array} nodes - 節點數組
 * @param {string} direction - 排版方向
 * @returns {Object} - {estimatedWidth, estimatedHeight}
 */
const estimateLayoutCanvasSize = (nodes, direction = 'TB') => {
  if (!nodes || nodes.length === 0) {
    return { estimatedWidth: 800, estimatedHeight: 600 };
  }

  const canvasSpace = calculateCanvasSpace(nodes);
  const layoutConfig = getLayoutConfig(direction);

  // 檢查是否有大尺寸節點（如 ExtractDataNode 或 QOCA AIM）
  const hasLargeNodes = nodes.some((node) => {
    const dimensions = calculateNodeDimensions(node);
    return dimensions.width > 300 || dimensions.height > 300;
  });

  // 檢查是否有 Schedule 節點（需要特殊處理複雜 UI）
  const hasScheduleNodes = nodes.some(
    (node) => node.type === 'schedule_trigger' || node.type === 'schedule_node'
  );

  // 檢查是否有 QOCA AIM 節點（需要特殊處理動態尺寸）
  const hasQocaAimNodes = nodes.some((node) => node.type === 'qocaAim');

  // 如果有大尺寸節點或 QOCA AIM 節點，增加額外的緩衝空間
  const sizeFactor =
    hasLargeNodes || hasQocaAimNodes || hasScheduleNodes ? 1.4 : 1.0;

  // 基於方向計算預估尺寸
  if (direction === 'LR' || direction === 'RL') {
    // 水平排列：寬度較大，高度較小
    return {
      estimatedWidth: Math.round(
        (canvasSpace.totalWidth +
          (nodes.length - 1) * layoutConfig.ranksep +
          layoutConfig.marginx * 2) *
          sizeFactor
      ),
      estimatedHeight: Math.round(
        (canvasSpace.avgHeight * Math.ceil(Math.sqrt(nodes.length)) +
          layoutConfig.marginy * 2) *
          sizeFactor
      )
    };
  } else {
    // 垂直排列：高度較大，寬度較小
    return {
      estimatedWidth: Math.round(
        (canvasSpace.avgWidth * Math.ceil(Math.sqrt(nodes.length)) +
          layoutConfig.marginx * 2) *
          sizeFactor
      ),
      estimatedHeight: Math.round(
        (canvasSpace.totalHeight +
          (nodes.length - 1) * layoutConfig.ranksep +
          layoutConfig.marginy * 2) *
          sizeFactor
      )
    };
  }
};

/**
 * 檢測節點重疊
 * @param {Array} nodes - 節點數組
 * @returns {Array} - 重疊的節點對
 */
const detectNodeOverlaps = (nodes) => {
  const overlaps = [];

  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const node1 = nodes[i];
      const node2 = nodes[j];

      const dim1 = calculateNodeDimensions(node1);
      const dim2 = calculateNodeDimensions(node2);

      // 計算節點邊界
      const rect1 = {
        left: node1.position.x,
        right: node1.position.x + dim1.width,
        top: node1.position.y,
        bottom: node1.position.y + dim1.height
      };

      const rect2 = {
        left: node2.position.x,
        right: node2.position.x + dim2.width,
        top: node2.position.y,
        bottom: node2.position.y + dim2.height
      };

      // 檢查重疊
      if (
        !(
          rect1.right < rect2.left ||
          rect2.right < rect1.left ||
          rect1.bottom < rect2.top ||
          rect2.bottom < rect1.top
        )
      ) {
        overlaps.push({
          node1: node1.id,
          node2: node2.id,
          severity: calculateOverlapSeverity(rect1, rect2)
        });
      }
    }
  }

  return overlaps;
};

/**
 * 計算重疊嚴重程度
 * @param {Object} rect1 - 第一個矩形
 * @param {Object} rect2 - 第二個矩形
 * @returns {number} - 重疊面積
 */
const calculateOverlapSeverity = (rect1, rect2) => {
  const overlapWidth =
    Math.min(rect1.right, rect2.right) - Math.max(rect1.left, rect2.left);
  const overlapHeight =
    Math.min(rect1.bottom, rect2.bottom) - Math.max(rect1.top, rect2.top);
  return overlapWidth * overlapHeight;
};

/**
 * 分析連線複雜度並建議最佳排版方向
 * @param {Array} nodes - 節點數組
 * @param {Array} edges - 邊緣數組
 * @returns {Object} - 分析結果和建議
 */
const analyzeConnectionComplexity = (nodes, edges) => {
  const analysis = {
    nodeCount: nodes.length,
    edgeCount: edges.length,
    crossingPotential: {
      TB: 0,
      LR: 0,
      BT: 0,
      RL: 0
    },
    recommendations: []
  };

  // 檢查是否有大尺寸節點
  const hasLargeNodes = nodes.some((node) => {
    const dimensions = calculateNodeDimensions(node);
    return dimensions.width > 300 || dimensions.height > 300;
  });

  // 檢查是否有 QOCA AIM 節點
  const hasQocaAimNodes = nodes.some((node) => node.type === 'qocaAim');

  const hasScheduleNodes = nodes.some(
    (node) => node.type === 'schedule_trigger' || node.type === 'schedule_node'
  );

  // 計算每個方向的潛在交叉數量
  const directions = ['TB', 'LR', 'BT', 'RL'];

  directions.forEach((direction) => {
    let crossingScore = 0;

    // 簡化的交叉預測算法
    edges.forEach((edge1, i) => {
      edges.forEach((edge2, j) => {
        if (i >= j) return;

        const source1 = nodes.find((n) => n.id === edge1.source);
        const target1 = nodes.find((n) => n.id === edge1.target);
        const source2 = nodes.find((n) => n.id === edge2.source);
        const target2 = nodes.find((n) => n.id === edge2.target);

        if (!source1 || !target1 || !source2 || !target2) return;

        // 根據方向計算潛在交叉
        if (direction === 'TB' || direction === 'BT') {
          // 垂直排列時，檢查水平位置關係
          const horizontalCrossing =
            (source1.position?.x < source2.position?.x &&
              target1.position?.x > target2.position?.x) ||
            (source1.position?.x > source2.position?.x &&
              target1.position?.x < target2.position?.x);
          if (horizontalCrossing) crossingScore += 1;
        } else {
          // 水平排列時，檢查垂直位置關係
          const verticalCrossing =
            (source1.position?.y < source2.position?.y &&
              target1.position?.y > target2.position?.y) ||
            (source1.position?.y > source2.position?.y &&
              target1.position?.y < target2.position?.y);
          if (verticalCrossing) crossingScore += 1;
        }
      });
    });

    analysis.crossingPotential[direction] = crossingScore;
  });

  // 生成建議
  const bestDirection = Object.keys(analysis.crossingPotential).reduce((a, b) =>
    analysis.crossingPotential[a] < analysis.crossingPotential[b] ? a : b
  );

  analysis.recommendedDirection = bestDirection;

  // 添加具體建議
  if (analysis.edgeCount > analysis.nodeCount * 1.5) {
    analysis.recommendations.push('複雜連線：建議使用樹狀排列減少交叉');
  }

  if (analysis.nodeCount > 10) {
    analysis.recommendations.push('大型流程：建議分階段排版或使用分層佈局');
  }

  // 針對大尺寸節點和 QOCA AIM 節點的特殊建議
  if (hasLargeNodes || hasQocaAimNodes || hasScheduleNodes) {
    analysis.recommendations.push(
      '包含大尺寸節點：建議使用 TB 或 BT 方向以獲得最佳顯示效果'
    );

    // 如果有大尺寸節點或 QOCA AIM 節點，稍微傾向於垂直佈局
    if (
      analysis.crossingPotential['TB'] <=
      analysis.crossingPotential['LR'] + 1
    ) {
      analysis.recommendedDirection = 'TB';
    }
  }

  // 針對 QOCA AIM 節點的特殊建議
  if (hasQocaAimNodes) {
    analysis.recommendations.push(
      'QOCA AIM 節點：動態尺寸節點，建議預留額外空間'
    );
  }
  // 針對 Schedule 節點的特殊建議
  if (hasScheduleNodes) {
    analysis.recommendations.push(
      'Schedule 節點：包含日期時間選擇器，建議使用垂直佈局並預留額外空間'
    );
  }

  const maxCrossing = Math.max(...Object.values(analysis.crossingPotential));
  if (maxCrossing > 5) {
    analysis.recommendations.push('高交叉風險：考慮重構流程或手動調整');
  }

  return analysis;
};

/**
 * 優化的排版配置，根據連線複雜度動態調整
 * @param {string} direction - 排版方向
 * @param {Object} complexity - 連線複雜度分析結果
 * @returns {Object} - 優化的 dagre 配置
 */
const getOptimizedLayoutConfig = (direction, complexity) => {
  const baseConfig = getLayoutConfig(direction);

  // 根據複雜度調整配置
  if (complexity.edgeCount > complexity.nodeCount * 2) {
    // 高密度連線：增加間距
    baseConfig.nodesep = Math.round(baseConfig.nodesep * 1.3);
    baseConfig.ranksep = Math.round(baseConfig.ranksep * 1.2);
    baseConfig.edgesep = Math.round(baseConfig.edgesep * 1.5);
  }

  if (complexity.crossingPotential[direction] > 3) {
    // 高交叉風險：進一步增加間距
    baseConfig.nodesep = Math.round(baseConfig.nodesep * 1.2);
    baseConfig.ranksep = Math.round(baseConfig.ranksep * 1.3);

    // 使用更嚴格的對齊
    if (direction === 'TB') baseConfig.align = 'UL';
    if (direction === 'LR') baseConfig.align = 'UL';
    if (direction === 'BT') baseConfig.align = 'DL';
    if (direction === 'RL') baseConfig.align = 'UR';
  }

  // 如果節點數量很多，增加邊距
  if (complexity.nodeCount > 15) {
    baseConfig.marginx = Math.round(baseConfig.marginx * 1.4);
    baseConfig.marginy = Math.round(baseConfig.marginy * 1.4);
  }

  // 如果有很多交叉，使用更保守的排版策略
  const totalCrossings = Object.values(complexity.crossingPotential).reduce(
    (a, b) => a + b,
    0
  );
  if (totalCrossings > 10) {
    baseConfig.ranker = 'longest-path'; // 使用最長路徑算法
    baseConfig.nodesep = Math.round(baseConfig.nodesep * 1.5);
    baseConfig.ranksep = Math.round(baseConfig.ranksep * 1.4);
  }

  return baseConfig;
};

/**
 * 驗證排版質量
 * @param {Array} nodes - 排版後的節點數組
 * @param {string} direction - 排版方向
 * @returns {Object} - 質量報告
 */
const validateLayoutQuality = (nodes, direction) => {
  const overlaps = detectNodeOverlaps(nodes);
  const canvasSize = estimateLayoutCanvasSize(nodes, direction);

  return {
    hasOverlaps: overlaps.length > 0,
    overlapCount: overlaps.length,
    overlaps: overlaps,
    canvasSize: canvasSize,
    nodeCount: nodes.length,
    quality:
      overlaps.length === 0
        ? 'excellent'
        : overlaps.length <= 2
        ? 'good'
        : overlaps.length <= 5
        ? 'acceptable'
        : 'poor'
  };
};

const {useRef: useRef$j,useCallback: useCallback$m,useEffect: useEffect$n} = await importShared('react');
function useFlowNodes() {
  const [nodes, setNodes] = useNodesState([]);
  const [edges, setEdges] = useEdgesState([]);
  const undoStack = useRef$j([]);
  const redoStack = useRef$j([]);
  const nodeCallbacks = useRef$j({});
  const isUpdatingNodes = useRef$j(false);
  const isLoadingWorkflow = useRef$j(false);
  const handleAutoLayout = useCallback$m(
    async (direction = "TB") => {
      console.log(`開始執行自動排版，方向: ${direction}`);
      if (nodes.length === 0) {
        console.log("沒有節點，跳過自動排版");
        return;
      }
      try {
        const complexityAnalysis = analyzeConnectionComplexity(nodes, edges);
        console.log("連線複雜度分析:", complexityAnalysis);
        const dagreGraph = new dagre.graphlib.Graph();
        dagreGraph.setDefaultEdgeLabel(() => ({}));
        const layoutConfig = getOptimizedLayoutConfig(
          direction,
          complexityAnalysis
        );
        dagreGraph.setGraph(layoutConfig);
        console.log("優化的 Dagre 配置:", layoutConfig);
        console.log("複雜度建議:", complexityAnalysis.recommendations);
        nodes.forEach((node) => {
          const dimensions = calculateNodeDimensions(node);
          console.log(
            `節點 ${node.id} (${node.type}): ${dimensions.width}x${dimensions.height}`
          );
          dagreGraph.setNode(node.id, {
            width: dimensions.width,
            height: dimensions.height
          });
        });
        edges.forEach((edge) => {
          dagreGraph.setEdge(edge.source, edge.target);
          console.log(`邊緣: ${edge.source} -> ${edge.target}`);
        });
        dagre.layout(dagreGraph);
        const updatedNodes = nodes.map((node) => {
          const nodeWithPosition = dagreGraph.node(node.id);
          if (nodeWithPosition) {
            const dimensions = calculateNodeDimensions(node);
            const newX = Math.round(nodeWithPosition.x - dimensions.width / 2);
            const newY = Math.round(nodeWithPosition.y - dimensions.height / 2);
            return {
              ...node,
              position: {
                x: newX,
                y: newY
              }
            };
          }
          return node;
        });
        setNodes(updatedNodes);
        const qualityReport = validateLayoutQuality(updatedNodes, direction);
        const canvasSize = estimateLayoutCanvasSize(updatedNodes, direction);
        setTimeout(() => {
          console.log("觸發視圖縮放");
          const event = new CustomEvent("autoLayoutComplete", {
            detail: {
              direction,
              nodeCount: nodes.length,
              canvasSize,
              qualityReport,
              complexityAnalysis
            }
          });
          window.dispatchEvent(event);
        }, 300);
      } catch (error) {
        console.error("自動排版失敗:", error);
        throw error;
      }
    },
    [nodes, edges, setNodes]
  );
  const handleNodesChange = useCallback$m(
    (changes) => {
      setNodes((nds) => applyNodeChanges(changes, nds));
    },
    [setNodes]
  );
  const handleEdgesChange = useCallback$m(
    (changes) => {
      setEdges((eds) => applyEdgeChanges(changes, eds));
    },
    [setEdges]
  );
  const pushToUndoStack = useCallback$m(() => {
    undoStack.current.push({
      nodes: JSON.parse(JSON.stringify(nodes)),
      edges: JSON.parse(JSON.stringify(edges))
    });
    redoStack.current = [];
  }, [nodes, edges]);
  const safeSetNodes = useCallback$m(
    (updater) => {
      pushToUndoStack();
      setNodes(updater);
    },
    [pushToUndoStack, setNodes]
  );
  const safeSetEdges = useCallback$m(
    (updater) => {
      pushToUndoStack();
      setEdges(updater);
    },
    [pushToUndoStack, setEdges]
  );
  const handleNodeSelection = useCallback$m(
    (nodeId) => {
      if (isUpdatingNodes.current) return;
      isUpdatingNodes.current = true;
      setNodes((nds) => {
        const updatedNodes = nds.map((node) => ({
          ...node,
          selected: node.id === nodeId
        }));
        requestAnimationFrame(() => {
          isUpdatingNodes.current = false;
        });
        return updatedNodes;
      });
    },
    [setNodes]
  );
  const getNodeCallbacks = useCallback$m(
    (nodeId, nodeType) => {
      if (nodeCallbacks.current[nodeId]) {
        return nodeCallbacks.current[nodeId];
      }
      const callbacks = {};
      callbacks.onSelect = () => {
        handleNodeSelection(nodeId);
      };
      switch (nodeType) {
        case "router_switch":
          callbacks.updateNodeData = (key, value) => {
            console.log(
              `更新 Router Switch 節點 ${nodeId} 的 ${key} 資料:`,
              value
            );
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  return {
                    ...node,
                    data: {
                      ...node.data,
                      [key]: value
                    }
                  };
                }
                return node;
              })
            );
          };
          break;
        case "combine_text": {
          callbacks.updateNodeData = (key, value) => {
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  const updatedNode = {
                    ...node,
                    data: {
                      ...node.data,
                      [key]: value
                    }
                  };
                  return updatedNode;
                }
                return node;
              })
            );
          };
          break;
        }
        case "schedule_trigger":
          callbacks.updateNodeData = (key, value) => {
            console.log(
              `更新 Schedule Trigger 節點 ${nodeId} 的 ${key} 資料:`,
              value
            );
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  return {
                    ...node,
                    data: {
                      ...node.data,
                      [key]: value
                    }
                  };
                }
                return node;
              })
            );
          };
          break;
        case "extractData":
        case "extract_data":
          callbacks.updateNodeData = (key, value) => {
            console.log(
              `更新 Extract Data 節點 ${nodeId} 的 ${key} 資料:`,
              value
            );
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  return {
                    ...node,
                    data: {
                      ...node.data,
                      [key]: value
                    }
                  };
                }
                return node;
              })
            );
          };
          break;
        case "customInput":
          callbacks.addField = () => {
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  const fields = Array.isArray(node.data.fields) ? [...node.data.fields] : [];
                  return {
                    ...node,
                    data: {
                      ...node.data,
                      fields: [
                        ...fields,
                        {
                          inputName: "New Input",
                          defaultValue: "Default value"
                        }
                      ]
                    }
                  };
                }
                return node;
              })
            );
          };
          callbacks.updateFieldInputName = (index, value) => {
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  const fields = node.data.fields || [];
                  if (index >= 0 && index < fields.length) {
                    const updatedFields = [...fields];
                    updatedFields[index] = {
                      ...updatedFields[index],
                      inputName: value
                    };
                    return {
                      ...node,
                      data: {
                        ...node.data,
                        fields: updatedFields
                      }
                    };
                  }
                }
                return node;
              })
            );
          };
          callbacks.updateFieldDefaultValue = (index, value) => {
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  const fields = node.data.fields || [];
                  if (index >= 0 && index < fields.length) {
                    const updatedFields = [...fields];
                    updatedFields[index] = {
                      ...updatedFields[index],
                      defaultValue: value
                    };
                    return {
                      ...node,
                      data: {
                        ...node.data,
                        fields: updatedFields
                      }
                    };
                  }
                }
                return node;
              })
            );
          };
          break;
        case "browserExtensionInput":
          callbacks.addItem = () => {
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  const currentItems = node.data.items || [];
                  const newItemId = `a${currentItems.length + 1}`;
                  return {
                    ...node,
                    data: {
                      ...node.data,
                      items: [
                        ...currentItems,
                        { id: newItemId, name: "", icon: "document" }
                      ]
                    }
                  };
                }
                return node;
              })
            );
          };
          callbacks.updateItemName = (index, name) => {
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  const updatedItems = [...node.data.items];
                  updatedItems[index] = {
                    ...updatedItems[index],
                    name
                  };
                  return {
                    ...node,
                    data: {
                      ...node.data,
                      items: updatedItems
                    }
                  };
                }
                return node;
              })
            );
          };
          callbacks.deleteItem = (index) => {
            if (index === -1) {
              console.log(`deleteItem 回調收到已處理標記，跳過重複處理`);
              return;
            }
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  const currentItems = node.data.items || [];
                  if (currentItems.length <= 1) {
                    console.warn("不能刪除最後一個項目");
                    return node;
                  }
                  const itemToDelete = currentItems[index];
                  const itemOutputKey = itemToDelete.id || `a${index + 1}`;
                  if (typeof window !== "undefined" && window.deleteEdgesBySourceHandle) {
                    window.deleteEdgesBySourceHandle(nodeId, itemOutputKey);
                  }
                  const updatedItems = currentItems.filter(
                    (_, idx) => idx !== index
                  );
                  console.log(`節點 ${nodeId} 刪除項目後的列表:`, updatedItems);
                  return {
                    ...node,
                    data: {
                      ...node.data,
                      items: updatedItems
                    }
                  };
                }
                return node;
              })
            );
          };
          break;
        case "browserExtensionOutput":
          callbacks.updateEdgeLabels = (edgeIds, newLabel) => {
            safeSetEdges(
              (eds) => eds.map((edge) => {
                if (Array.isArray(edgeIds) && edgeIds.includes(edge.id)) {
                  return {
                    ...edge,
                    label: newLabel
                  };
                } else if (edge.id === edgeIds) {
                  return {
                    ...edge,
                    label: newLabel
                  };
                }
                return edge;
              })
            );
          };
          if (!callbacks.updateNodeData) {
            callbacks.updateNodeData = (key, value) => {
              console.log(`更新節點 ${nodeId} 的 ${key} 資料:`, value);
              safeSetNodes(
                (nds) => nds.map((node) => {
                  if (node.id === nodeId) {
                    return {
                      ...node,
                      data: {
                        ...node.data,
                        [key]: value
                      }
                    };
                  }
                  return node;
                })
              );
            };
          }
          break;
        default:
          callbacks.updateNodeData = (key, value) => {
            safeSetNodes(
              (nds) => nds.map((node) => {
                if (node.id === nodeId) {
                  return {
                    ...node,
                    data: {
                      ...node.data,
                      [key]: value
                    }
                  };
                }
                return node;
              })
            );
          };
          break;
      }
      if (!callbacks.updateNodeData) {
        callbacks.updateNodeData = (key, value) => {
          safeSetNodes(
            (nds) => nds.map((node) => {
              if (node.id === nodeId) {
                return {
                  ...node,
                  data: {
                    ...node.data,
                    [key]: value
                  }
                };
              }
              return node;
            })
          );
        };
      }
      nodeCallbacks.current[nodeId] = callbacks;
      return callbacks;
    },
    [handleNodeSelection, safeSetNodes, safeSetEdges]
  );
  const onNodesDelete = useCallback$m(
    (nodesToDelete) => {
      if (!nodesToDelete || nodesToDelete.length === 0) return;
      const nodeIdsToDelete = nodesToDelete.map((node) => node.id);
      nodesToDelete.forEach((nodeToDelete) => {
        const connectedEdges = getConnectedEdges([nodeToDelete], edges);
        const incomers = getIncomers(nodeToDelete, nodes, edges);
        const outgoers = getOutgoers(nodeToDelete, nodes, edges);
        incomers.forEach((incomer) => {
          outgoers.forEach((outgoer) => {
            const incomerEdge = connectedEdges.find(
              (edge) => edge.source === incomer.id && edge.target === nodeToDelete.id
            );
            const outgoerEdge = connectedEdges.find(
              (edge) => edge.source === nodeToDelete.id && edge.target === outgoer.id
            );
            if (incomerEdge && outgoerEdge) {
              const isAIOutgoer = outgoer.type === "aiCustomInput" || outgoer.type === "ai";
              if (isAIOutgoer) {
                const existingEdges = edges.filter(
                  (edge) => edge.source !== nodeToDelete.id && // 不計算將被刪除的節點
                  edge.target === outgoer.id && edge.targetHandle === outgoerEdge.targetHandle
                );
                if (existingEdges.length > 0) {
                  console.log(
                    `AI節點 ${outgoer.id} 的 ${outgoerEdge.targetHandle} 已有其他連線，不建立新連接`
                  );
                  return;
                }
              }
              if (outgoer.type === "browserExtensionOutput") {
                console.log(
                  `處理刪除後的連接重建: ${incomer.id} -> ${outgoer.id}:${outgoerEdge.targetHandle}`
                );
                const newEdgeId = `${incomer.id}-${outgoer.id}-${outgoerEdge.targetHandle}-${incomerEdge.sourceHandle || "output"}`;
                const newEdge = {
                  id: newEdgeId,
                  source: incomer.id,
                  target: outgoer.id,
                  sourceHandle: incomerEdge.sourceHandle || "output",
                  targetHandle: outgoerEdge.targetHandle,
                  type: outgoerEdge.type || "custom-edge"
                };
                safeSetEdges((eds) => [...eds, newEdge]);
              } else {
                const newEdge = {
                  id: `${incomer.id}-${outgoer.id}`,
                  source: incomer.id,
                  target: outgoer.id,
                  sourceHandle: incomerEdge.sourceHandle || "output",
                  targetHandle: outgoerEdge.targetHandle || "input",
                  type: outgoerEdge.type || "custom-edge"
                };
                safeSetEdges((eds) => [...eds, newEdge]);
              }
            }
          });
        });
      });
      safeSetEdges(
        (eds) => eds.filter(
          (edge) => !nodeIdsToDelete.includes(edge.source) && !nodeIdsToDelete.includes(edge.target)
        )
      );
      nodeIdsToDelete.forEach((nodeId) => {
        delete nodeCallbacks.current[nodeId];
      });
      safeSetNodes(
        (nds) => nds.filter((node) => !nodeIdsToDelete.includes(node.id))
      );
    },
    [nodes, edges, safeSetEdges, safeSetNodes]
  );
  const deleteSelectedNodes = useCallback$m(
    (selectedNodes) => {
      if (!selectedNodes || selectedNodes.length === 0) return;
      onNodesDelete(selectedNodes);
    },
    [onNodesDelete]
  );
  const handleAddInputNode = useCallback$m(
    (position) => {
      const id = `input_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "customInput");
      const newNode = {
        id,
        type: "customInput",
        position: position || { x: 250, y: 25 },
        data: {
          // 初始化一個默認字段
          fields: [
            {
              inputName: "input_name",
              defaultValue: "Summary the input text"
            }
          ],
          // 添加所有回調
          ...nodeCallbacksObject
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddAINode = useCallback$m(
    (position) => {
      const id = `ai_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "aiCustomInput");
      const newNode = {
        id,
        type: "aiCustomInput",
        data: {
          model: "O3-mini",
          selectedOption: "prompt",
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddBrowserExtensionOutput = useCallback$m(
    (position) => {
      const id = `browserExtOut_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(
        id,
        "browserExtensionOutput"
      );
      const newNode = {
        id,
        type: "browserExtensionOutput",
        data: {
          // 確保默認有一個 input handle，並且使用新的命名方式
          inputHandles: [{ id: "output0" }],
          // 儲存節點輸入連接關聯
          node_input: {
            // 🔧 修復：使用 output0 作為預設 handle，而不是 input
            output0: {
              node_id: "",
              output_name: "",
              type: "string",
              data: "",
              is_empty: true,
              return_name: ""
            }
          },
          // 新增一個通用的 onAddOutput 方法
          onAddOutput: (newInputHandles) => {
            console.log(`更新節點 ${id} 的 handle：`, newInputHandles);
            setNodes((prevNodes) => {
              const nodeIndex = prevNodes.findIndex((node) => node.id === id);
              if (nodeIndex === -1) {
                console.warn(`找不到節點 ${id}`);
                return prevNodes;
              }
              const updatedNodes = [...prevNodes];
              const currentNode = updatedNodes[nodeIndex];
              const existingNodeInput = { ...currentNode.data.node_input };
              newInputHandles.forEach((handle) => {
                if (!existingNodeInput[handle.id]) {
                  existingNodeInput[handle.id] = {
                    node_id: "",
                    output_name: "",
                    type: "string",
                    data: "",
                    is_empty: true,
                    return_name: ""
                  };
                }
              });
              updatedNodes[nodeIndex] = {
                ...currentNode,
                data: {
                  ...currentNode.data,
                  inputHandles: newInputHandles,
                  node_input: existingNodeInput
                }
              };
              console.log(`節點 ${id} 更新後的數據:`, {
                inputHandles: newInputHandles,
                node_input: existingNodeInput
              });
              return updatedNodes;
            });
          },
          // 新增 onRemoveHandle 方法
          onRemoveHandle: (handleId) => {
            if (handleId === "output0") {
              console.log("不能移除默認 output0 handle");
              return;
            }
            setNodes((prevNodes) => {
              const nodeIndex = prevNodes.findIndex((node) => node.id === id);
              if (nodeIndex === -1) {
                console.warn(`找不到節點 ${id}`);
                return prevNodes;
              }
              const updatedNodes = [...prevNodes];
              const currentNode = updatedNodes[nodeIndex];
              const filteredHandles = currentNode.data.inputHandles.filter(
                (handle) => handle.id !== handleId
              );
              const updatedNodeInput = { ...currentNode.data.node_input };
              delete updatedNodeInput[handleId];
              updatedNodes[nodeIndex] = {
                ...currentNode,
                data: {
                  ...currentNode.data,
                  inputHandles: filteredHandles,
                  node_input: updatedNodeInput
                }
              };
              console.log(`節點 ${id} 移除 handle ${handleId} 後的數據:`, {
                inputHandles: filteredHandles,
                node_input: updatedNodeInput
              });
              return updatedNodes;
            });
          },
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks, setNodes]
  );
  const handleAddBrowserExtensionInput = useCallback$m(
    (position) => {
      const id = `browserExtIn_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "browserExtensionInput");
      const newNode = {
        id,
        type: "browserExtensionInput",
        data: {
          // 初始化時為每個項目添加對應的ID
          items: [{ id: "a1", name: "", icon: "upload" }],
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddNode = useCallback$m(
    (position) => {
      const id = `default_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "default");
      const newNode = {
        id,
        type: "default",
        data: {
          label: "新節點",
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddIfElseNode = useCallback$m(
    (position) => {
      const id = `ifelse_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "ifElse");
      const newNode = {
        id,
        type: "ifElse",
        data: {
          variableName: "formate_value",
          operator: "equals",
          compareValue: "Hello",
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddHttpRequestNode = useCallback$m(
    (position) => {
      const id = `httpRequest_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "httpRequest");
      const newNode = {
        id,
        type: "httpRequest",
        data: {
          url: "",
          // 預設 URL
          method: "GET",
          // 預設方法
          headers: [
            { key: "Accept", value: "application/json" },
            { key: "Content-Type", value: "application/json" }
          ],
          // 預設 headers
          body: "",
          // 預設空 body
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddLineNode = useCallback$m(
    (position) => {
      const id = `line_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "line");
      const existingLineNodes = nodes.filter(
        (node) => node.type === "line_webhook_input"
      );
      if (existingLineNodes.length > 0) {
        if (typeof window !== "undefined" && window.notify) {
          window.notify({
            message: "每個 Flow 只能有一個 Line Webhook 節點",
            type: "warning",
            duration: 4e3
          });
        }
        console.warn(
          "嘗試添加第二個 Line 節點被阻止，現有 Line 節點:",
          existingLineNodes.map((n) => n.id)
        );
        return;
      }
      const newNode = {
        id,
        type: "line_webhook_input",
        data: {
          external_service_config_id: "",
          // 初始為空，讓用戶選擇
          webhook_url: "",
          // 初始為空，需要創建後才有
          output_handles: ["text", "image"],
          // 固定的輸出類型
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks, nodes]
  );
  const handleAddLineMessageNode = useCallback$m(
    (position) => {
      const id = `message_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "message");
      const newNode = {
        id,
        type: "line_send_message",
        data: {
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddScheduleTriggerNode = useCallback$m(
    (position) => {
      const id = `schedule_node_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "schedule_trigger");
      const newNode = {
        id,
        type: "schedule_trigger",
        data: {
          schedule_type: "cron",
          // 預設為週期性
          cron_expression: "",
          // 預設工作日早上9點
          execute_at: null,
          // 一次性執行時間
          timezone: "Asia/Taipei",
          // 預設時區
          enabled: true,
          // 預設啟用
          description: "",
          // 預設描述
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddRouterSwitchNode = useCallback$m(
    (position) => {
      const id = `router_switch_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "router_switch");
      const defaultRouters = [
        {
          router_id: "router0",
          router_name: "Router",
          ai_condition: "",
          connection_id: `router_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        },
        {
          router_id: "default_router",
          router_name: "Other",
          ai_condition: "",
          connection_id: `router_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        }
      ];
      const newNode = {
        id,
        type: "router_switch",
        data: {
          llm_id: "1",
          // 預設模型 ID
          routers: defaultRouters,
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddCombineTextNode = useCallback$m(
    (position) => {
      const id = `combine_text_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "combine_text");
      const getCurrentFlowId = () => {
        const urlParams = new URLSearchParams(window.location.search);
        const urlFlowId = urlParams.get("flowId") || urlParams.get("flow_id");
        if (urlFlowId) return urlFlowId;
        const pathMatch = window.location.pathname.match(/\/flow\/([^\/]+)/);
        if (pathMatch) return pathMatch[1];
        if (typeof window !== "undefined" && window.currentFlowId) {
          return window.currentFlowId;
        }
        return "";
      };
      const newNode = {
        id,
        type: "combine_text",
        data: {
          textToCombine: "",
          editorHtmlContent: "",
          // 初始化編輯器HTML內容
          activeTab: "editor",
          // 初始化當前tab
          inputHandles: [{ id: "text" }],
          flowId: getCurrentFlowId(),
          // 添加 flow_id 到節點數據中
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      console.log(`創建 combine_text 節點:`, newNode);
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddWebhookOutputNode = useCallback$m(
    (position) => {
      const id = `webhook_output_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "webhook_output");
      const newNode = {
        id,
        type: "webhook_output",
        data: {
          webhookUrl: "",
          // 默認空 URL
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddWebhookInputNode = useCallback$m(
    (position) => {
      const id = `webhook_input_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "webhook_input");
      const existingWebhookInputNodes = nodes.filter(
        (node) => node.type === "webhook_input"
      );
      if (existingWebhookInputNodes.length > 0) {
        if (typeof window !== "undefined" && window.notify) {
          window.notify({
            message: "每個 Flow 只能有一個 Webhook Input 節點",
            type: "warning",
            duration: 4e3
          });
        }
        console.warn(
          "嘗試添加第二個 Webhook Input 節點被阻止，現有節點:",
          existingWebhookInputNodes.map((n) => n.id)
        );
        return;
      }
      const newNode = {
        id,
        type: "webhook_input",
        data: {
          curl_example: "",
          webhook_url: "",
          "X-QOCA-Agent-Api-Key": "",
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddQOCAAimNode = useCallback$m(
    (position) => {
      const id = `aim_ml_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "aim_ml");
      const newNode = {
        id,
        type: "aim_ml",
        data: {
          aim: "",
          // 默認空 AIM
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddExtractDataNode = useCallback$m(
    (position) => {
      const id = `extract_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "extractData");
      const newNode = {
        id,
        type: "extract_data",
        data: {
          model: "1",
          // 預設模型 ID
          columns: [
            {
              name: "",
              type: "text",
              description: ""
            }
          ],
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddKnowledgeRetrievalNode = useCallback$m(
    (position) => {
      const id = `knowledge_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "knowledgeRetrieval");
      const newNode = {
        id,
        type: "knowledgeRetrieval",
        data: {
          availableFiles: [
            { id: "icdcode", name: "ICDCode.csv" },
            { id: "cardiology", name: "Cardiology_Diagnoses.csv" }
          ],
          selectedFile: "",
          // 默認不選擇
          topK: 5,
          // 添加默認的 top_k 值
          threshold: 0.7,
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddEndNode = useCallback$m(
    (position) => {
      const id = `end_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "end");
      const newNode = {
        id,
        type: "end",
        data: {
          outputText: "",
          // 默認空輸出文字
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddWebhookNode = useCallback$m(
    (position) => {
      const id = `webhook_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "webhook");
      const newNode = {
        id,
        type: "webhook",
        data: {
          webhookUrl: "",
          // 默認空 URL
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddTimerNode = useCallback$m(
    (position) => {
      const id = `timer_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "timer");
      const newNode = {
        id,
        type: "timer",
        data: {
          hours: 0,
          minutes: 0,
          seconds: 0,
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const handleAddEventNode = useCallback$m(
    (position) => {
      const id = `event_${Date.now()}`;
      const nodeCallbacksObject = getNodeCallbacks(id, "event");
      const newNode = {
        id,
        type: "event",
        data: {
          hours: 0,
          minutes: 0,
          seconds: 0,
          ...nodeCallbacksObject
        },
        position: position || {
          x: Math.random() * 400,
          y: Math.random() * 400
        }
      };
      safeSetNodes((nds) => [...nds, newNode]);
    },
    [safeSetNodes, getNodeCallbacks]
  );
  const onConnect = useCallback$m(
    (params) => {
      const sourceHandle = params.sourceHandle || "output";
      const targetNodeId = params.target;
      let targetHandle = params.targetHandle;
      console.log(
        `嘗試連接: 從 ${params.source}:${sourceHandle} 到 ${targetNodeId}:${targetHandle}`
      );
      const targetNode = nodes.find((node) => node.id === targetNodeId);
      const isBrowserExtensionOutput = targetNode && targetNode.type === "browserExtensionOutput";
      const isWebhookOutput = targetNode && targetNode.type === "webhook_output";
      const isAINode = targetNode && (targetNode.type === "aiCustomInput" || targetNode.type === "ai");
      const isExtractDataNode = targetNode && targetNode.type === "extract_data";
      const sourceNode = nodes.find((node) => node.id === params.source);
      const isBrowserExtensionInput = sourceNode && sourceNode.type === "browserExtensionInput";
      const isCustomInputNode = sourceNode && sourceNode.type === "customInput";
      if (isCustomInputNode) {
        console.log("源節點是CustomInputNode，檢查連線限制");
        const existingEdges = edges.filter(
          (edge) => edge.source === params.source && edge.sourceHandle === sourceHandle
        );
        if (existingEdges.length > 0) {
          console.log(`Input的輸出已有連線，拒絕新連線`);
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `Input已有連線，請先刪除現有連線`,
              type: "error",
              duration: 3e3
            });
          }
          return;
        }
      }
      if (targetNode && targetNode.type === "aim_ml") {
        console.log("目標是 QOCA AIM 節點，檢查連線限制");
        const existingEdges = edges.filter((edge) => {
          return edge.target === targetNodeId && edge.targetHandle === "input";
        });
        if (existingEdges.length > 0) {
          console.log(`QOCA AIM 節點已有輸入連線，拒絕新連線`);
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `QOCA AIM 節點只能有一個輸入連線，請先刪除現有連線`,
              type: "error",
              duration: 3e3
            });
          }
          return;
        }
      }
      if (targetNode && targetNode.type === "httpRequest") {
        console.log("目標是 HTTP Request 節點，檢查連線限制");
        const existingEdges = edges.filter(
          (edge) => edge.target === targetNodeId && edge.targetHandle === "input"
        );
        if (existingEdges.length > 0) {
          console.log(`HTTP Request 節點已有輸入連線，拒絕新連線`);
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `HTTP Request 節點只能有一個輸入連線，請先刪除現有連線`,
              type: "error",
              duration: 3e3
            });
          }
          return;
        }
      }
      if (targetNode && targetNode.type === "knowledgeRetrieval") {
        console.log("目標是知識檢索節點，檢查連線限制");
        const existingEdges = edges.filter(
          (edge) => edge.target === targetNodeId && edge.targetHandle === "passage"
        );
        if (existingEdges.length > 0) {
          console.log(`知識檢索節點已有輸入連線，拒絕新連線`);
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `知識檢索節點只能有一個輸入連線，請先刪除現有連線`,
              type: "error",
              duration: 3e3
            });
          }
          return;
        }
      }
      if (sourceNode && sourceNode.type === "knowledgeRetrieval") {
        console.log("源節點是知識檢索節點，檢查連線限制");
      }
      if (targetNode && targetNode.type === "router_switch") {
        console.log("目標是 Router Switch 節點，檢查連線限制");
        const existingEdges = edges.filter(
          (edge) => edge.target === targetNodeId && edge.targetHandle === "input"
        );
        if (existingEdges.length > 0) {
          console.log(`Router Switch 節點已有輸入連線，拒絕新連線`);
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `Router Switch 節點只能有一個輸入連線，請先刪除現有連線`,
              type: "error",
              duration: 3e3
            });
          }
          return;
        }
      }
      if (sourceNode && sourceNode.type === "httpRequest") {
        console.log("源節點是 HTTP Request 節點，檢查連線限制");
        const existingEdges = edges.filter(
          (edge) => edge.source === params.source && edge.sourceHandle === "output"
        );
        if (existingEdges.length > 0) {
          console.log(`HTTP Request 節點已有輸出連線，拒絕新連線`);
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `HTTP Request 節點只能有一個輸出連線，請先刪除現有連線`,
              type: "error",
              duration: 3e3
            });
          }
          return;
        }
      }
      if (isAINode) {
        console.log("目標是AI節點，檢查連線限制");
        if (targetHandle === "prompt-input") {
          const existingEdges = edges.filter(
            (edge) => edge.target === targetNodeId && edge.targetHandle === "prompt-input"
          );
          if (existingEdges.length > 0) {
            console.log(`AI節點的 Prompt 已有連線，拒絕新連線`);
            if (typeof window !== "undefined" && window.notify) {
              window.notify({
                message: `AI節點的 Prompt 已有連線，請先刪除現有連線`,
                type: "error",
                duration: 3e3
              });
            }
            return;
          }
        }
      }
      if (isExtractDataNode) {
        console.log("目標是Extract Data節點，檢查連線限制");
        const existingEdges = edges.filter(
          (edge) => edge.target === targetNodeId && edge.targetHandle === "context-input"
        );
        console.log(existingEdges);
        if (existingEdges.length > 0) {
          console.log(`Extract Data節點已有輸入連線，拒絕新連線`);
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `Extract Data節點只能有一個輸入連線，請先刪除現有連線`,
              type: "error",
              duration: 3e3
            });
          }
          return;
        }
      }
      if (isBrowserExtensionOutput) {
        console.log("目標是瀏覽器擴展輸出節點");
        if (targetHandle === "new-connection" || !targetHandle) {
          const currentHandles = targetNode.data.inputHandles || [];
          let maxIndex = -1;
          currentHandles.forEach((handle) => {
            if (handle.id && handle.id.startsWith("output")) {
              const indexStr = handle.id.substring(6);
              const index = parseInt(indexStr, 10);
              if (!isNaN(index) && index > maxIndex) {
                maxIndex = index;
              }
            }
          });
          const newIndex = maxIndex + 1;
          targetHandle = `output${newIndex}`;
          console.log(`創建新的 handle: ${targetHandle}`);
          safeSetNodes(
            (nds) => nds.map((node) => {
              if (node.id === targetNodeId) {
                const newHandles = [...currentHandles, { id: targetHandle }];
                console.log(`更新節點 ${targetNodeId} 的 handles:`, newHandles);
                return {
                  ...node,
                  data: {
                    ...node.data,
                    inputHandles: newHandles
                  }
                };
              }
              return node;
            })
          );
        }
        const connectionExists = edges.some(
          (edge) => edge.source === params.source && edge.target === targetNodeId && edge.targetHandle === targetHandle && edge.sourceHandle === sourceHandle
        );
        if (connectionExists) {
          console.log(`連接已存在，不重複創建`);
          return;
        }
        const edgeId = `${params.source}-${targetNodeId}-${targetHandle}-${sourceHandle}-${Date.now()}`;
        const newEdge = {
          id: edgeId,
          source: params.source,
          target: targetNodeId,
          sourceHandle,
          targetHandle,
          type: "custom-edge"
        };
        console.log(`創建新連接:`, newEdge);
        setEdges((currentEdges) => {
          const exists = currentEdges.some(
            (edge) => edge.source === params.source && edge.target === targetNodeId && edge.targetHandle === targetHandle && edge.sourceHandle === sourceHandle
          );
          if (exists) {
            console.log(`在 setEdges 中發現連接已存在，跳過`);
            return currentEdges;
          }
          return [...currentEdges, newEdge];
        });
        setTimeout(() => {
          try {
            const event = new CustomEvent("nodeInternalsChanged", {
              detail: { id: targetNodeId }
            });
            window.dispatchEvent(event);
          } catch (error) {
            console.error("無法刷新節點:", error);
          }
        }, 10);
        return;
      }
      if (isWebhookOutput) {
        console.log("目標是 Webhook Output 節點，檢查單一連線限制");
        const existingConnections = edges.filter(
          (edge) => edge.target === targetNodeId && edge.targetHandle === targetHandle
        );
        if (existingConnections.length > 0) {
          console.log(
            `Webhook Output 節點的 ${targetHandle} 已有連線，拒絕新連線`
          );
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `${targetHandle} 已有連線，請先刪除現有連線`,
              type: "error",
              duration: 3e3
            });
          }
          return;
        }
        if (targetHandle === "new-connection" || !targetHandle) {
          const currentHandles = targetNode.data.inputHandles || [];
          let maxIndex = -1;
          currentHandles.forEach((handle) => {
            if (handle.id && handle.id.startsWith("text")) {
              const indexStr = handle.id.substring(4);
              const index = parseInt(indexStr, 10);
              if (!isNaN(index) && index > maxIndex) {
                maxIndex = index;
              }
            }
          });
          const newIndex = maxIndex + 1;
          targetHandle = `text${newIndex}`;
          console.log(`創建新的 handle: ${targetHandle}`);
          safeSetNodes(
            (nds) => nds.map((node) => {
              if (node.id === targetNodeId) {
                const newHandles = [...currentHandles, { id: targetHandle }];
                console.log(`更新節點 ${targetNodeId} 的 handles:`, newHandles);
                return {
                  ...node,
                  data: {
                    ...node.data,
                    inputHandles: newHandles
                  }
                };
              }
              return node;
            })
          );
        }
        const connectionExists = edges.some(
          (edge) => edge.source === params.source && edge.target === targetNodeId && edge.targetHandle === targetHandle && edge.sourceHandle === sourceHandle
        );
        if (connectionExists) {
          console.log(`連接已存在，不重複創建`);
          return;
        }
        const edgeId = `${params.source}-${targetNodeId}-${targetHandle}-${sourceHandle}-${Date.now()}`;
        const newEdge = {
          id: edgeId,
          source: params.source,
          target: targetNodeId,
          sourceHandle,
          targetHandle,
          type: "custom-edge"
        };
        console.log(`創建新連接:`, newEdge);
        setEdges((currentEdges) => {
          const exists = currentEdges.some(
            (edge) => edge.source === params.source && edge.target === targetNodeId && edge.targetHandle === targetHandle && edge.sourceHandle === sourceHandle
          );
          if (exists) {
            console.log(`在 setEdges 中發現連接已存在，跳過`);
            return currentEdges;
          }
          return [...currentEdges, newEdge];
        });
        setTimeout(() => {
          try {
            const event = new CustomEvent("nodeInternalsChanged", {
              detail: { id: targetNodeId }
            });
            window.dispatchEvent(event);
          } catch (error) {
            console.error("無法刷新節點:", error);
          }
        }, 10);
        return;
      }
      try {
        const edgeId = `${params.source}-${targetNodeId}-${targetHandle || "input"}-${sourceHandle}-${Date.now()}`;
        let edgeConfig = {
          ...params,
          id: edgeId,
          type: "custom-edge"
        };
        if (isBrowserExtensionInput && sourceNode?.data?.items) {
          const itemIndex = sourceNode.data.items.findIndex((item, idx) => {
            const outputKey = item.id || `a${idx + 1}`;
            return outputKey === sourceHandle;
          });
          if (itemIndex !== -1 && sourceNode.data.items[itemIndex]) {
            edgeConfig.label = sourceNode.data.items[itemIndex].name || "";
            console.log(`設置連接標籤為項目名稱: ${edgeConfig.label}`);
          }
        }
        safeSetEdges((currentEdges) => {
          return addEdge(edgeConfig, currentEdges);
        });
      } catch (error) {
        console.error("在使用 addEdge 時出錯:", error);
        safeSetEdges((eds) => {
          const edgeId = `${params.source}-${targetNodeId}-${targetHandle || "input"}-${sourceHandle}-${Date.now()}`;
          const newEdge = {
            id: edgeId,
            source: params.source,
            target: targetNodeId,
            sourceHandle,
            targetHandle: targetHandle || "input",
            type: "custom-edge"
          };
          return [...eds, newEdge];
        });
      }
    },
    [nodes, edges, safeSetNodes, safeSetEdges]
  );
  const undo = useCallback$m(() => {
    if (undoStack.current.length === 0) return;
    redoStack.current.push({
      nodes: JSON.parse(JSON.stringify(nodes)),
      edges: JSON.parse(JSON.stringify(edges))
    });
    const prev = undoStack.current.pop();
    setNodes(prev.nodes);
    setEdges(prev.edges);
  }, [nodes, edges, setNodes, setEdges]);
  const redo = useCallback$m(() => {
    if (redoStack.current.length === 0) return;
    undoStack.current.push({
      nodes: JSON.parse(JSON.stringify(nodes)),
      edges: JSON.parse(JSON.stringify(edges))
    });
    const next = redoStack.current.pop();
    setNodes(next.nodes);
    setEdges(next.edges);
  }, [nodes, edges, setNodes, setEdges]);
  const updateNodeLabel = useCallback$m(
    (id, label) => {
      safeSetNodes(
        (nds) => nds.map((n) => n.id === id ? { ...n, data: { ...n.data, label } } : n)
      );
    },
    [safeSetNodes]
  );
  const updateNodeFunctions = useCallback$m(() => {
    const updatedNodes = [...nodes];
    let hasChanges = false;
    console.log("開始檢查並更新所有節點的回調函數...");
    nodes.forEach((node, index) => {
      const nodeId = node.id;
      const nodeType = node.type;
      let missingCallbacks = false;
      switch (nodeType) {
        case "customInput":
          missingCallbacks = !node.data.addField || !node.data.updateFieldInputName || !node.data.updateFieldDefaultValue || !node.data.onSelect;
          break;
        case "browserExtensionInput":
          missingCallbacks = !node.data.addItem || !node.data.updateItemName || !node.data.onSelect;
          break;
        case "line_webhook_input":
          missingCallbacks = !node.data.updateNodeData || !node.data.onSelect;
          console.log(`Line 節點 ${nodeId} 回調檢查:`, {
            hasUpdateNodeData: !!node.data.updateNodeData,
            hasOnSelect: !!node.data.onSelect,
            missingCallbacks
          });
          break;
        case "line_send_message":
          missingCallbacks = !node.data.updateNodeData || !node.data.onSelect;
          break;
        default:
          missingCallbacks = !node.data.onSelect || !node.data.updateNodeData;
          break;
      }
      if (missingCallbacks) {
        console.log(
          `節點 ${nodeId} (類型: ${nodeType}) 缺少必要回調，正在更新...`
        );
        const callbacks = getNodeCallbacks(nodeId, nodeType);
        updatedNodes[index] = {
          ...updatedNodes[index],
          data: {
            ...updatedNodes[index].data,
            ...callbacks
          }
        };
        hasChanges = true;
      }
    });
    if (hasChanges) {
      console.log("有節點回調函數需要更新，正在應用變更...");
      setNodes(updatedNodes);
    } else {
      console.log("所有節點回調函數已經是最新，無需更新。");
    }
  }, [nodes, getNodeCallbacks, setNodes]);
  const deleteEdgesBySourceHandle = useCallback$m(
    (nodeId, sourceHandle) => {
      console.log(
        `刪除與節點 ${nodeId} sourceHandle ${sourceHandle} 相關的所有邊緣`
      );
      const edgesToDelete = edges.filter((edge) => {
        const isSourceMatch = edge.source === nodeId && edge.sourceHandle === sourceHandle;
        return isSourceMatch;
      });
      if (edgesToDelete.length > 0) {
        console.log(
          `找到 ${edgesToDelete.length} 個要刪除的邊緣:`,
          edgesToDelete.map((e) => e.id)
        );
        safeSetEdges(
          (currentEdges) => currentEdges.filter(
            (edge) => !edgesToDelete.some((toDelete) => toDelete.id === edge.id)
          )
        );
      } else {
        console.log(`沒有找到與 ${nodeId}:${sourceHandle} 相關的邊緣`);
      }
    },
    [edges, safeSetEdges]
  );
  const deleteEdgesByHandle = useCallback$m(
    (nodeId, handleId) => {
      console.log(`刪除與節點 ${nodeId} handle ${handleId} 相關的所有邊緣`);
      const edgesToDelete = edges.filter((edge) => {
        const isTargetMatch = edge.target === nodeId && edge.targetHandle === handleId;
        const isMultiConnectionMatch = edge.target === nodeId && edge.targetHandle && edge.targetHandle.startsWith(handleId + "_");
        return isTargetMatch || isMultiConnectionMatch;
      });
      if (edgesToDelete.length > 0) {
        console.log(
          `找到 ${edgesToDelete.length} 個要刪除的邊緣:`,
          edgesToDelete.map((e) => e.id)
        );
        safeSetEdges(
          (currentEdges) => currentEdges.filter(
            (edge) => !edgesToDelete.some((toDelete) => toDelete.id === edge.id)
          )
        );
      } else {
        console.log(`沒有找到與 ${nodeId}:${handleId} 相關的邊緣`);
      }
    },
    [edges, safeSetEdges]
  );
  useEffect$n(() => {
    if (typeof window !== "undefined") {
      window.deleteEdgesByHandle = deleteEdgesByHandle;
      window.deleteEdgesBySourceHandle = deleteEdgesBySourceHandle;
    }
    return () => {
      if (typeof window !== "undefined") {
        delete window.deleteEdgesByHandle;
        delete window.deleteEdgesBySourceHandle;
      }
    };
  }, [deleteEdgesByHandle, deleteEdgesBySourceHandle]);
  const cleanupInvalidEdges = useCallback$m(() => {
    setEdges((currentEdges) => {
      const validEdges = currentEdges.filter((edge) => {
        const sourceNode = nodes.find((node) => node.id === edge.source);
        const targetNode = nodes.find((node) => node.id === edge.target);
        if (!sourceNode || !targetNode) {
          console.log(`移除無效邊緣 ${edge.id}: 源節點或目標節點不存在`);
          return false;
        }
        if (sourceNode.type === "router_switch") {
          const routers = sourceNode.data?.routers || [];
          const isValidSourceHandle = routers.some(
            (router) => router.connection_id === edge.sourceHandle || router.router_id === edge.sourceHandle
          );
          if (!isValidSourceHandle && edge.sourceHandle !== "default_router") {
            console.log(
              `移除無效邊緣 ${edge.id}: router_switch 的 sourceHandle ${edge.sourceHandle} 已不存在`
            );
            return false;
          }
        }
        if (targetNode.type === "browserExtensionOutput") {
          const inputHandles = targetNode.data?.inputHandles || [];
          const baseTargetHandle = edge.targetHandle?.split("_")[0];
          const isValidTargetHandle = inputHandles.some(
            (handle) => handle.id === baseTargetHandle
          );
          if (!isValidTargetHandle) {
            console.log(
              `移除無效邊緣 ${edge.id}: browserExtensionOutput 的 targetHandle ${edge.targetHandle} 已不存在`
            );
            return false;
          }
        }
        return true;
      });
      if (validEdges.length !== currentEdges.length) {
        console.log(
          `清理了 ${currentEdges.length - validEdges.length} 個無效邊緣`
        );
      }
      return validEdges;
    });
  }, [nodes, setEdges]);
  const cleanupNodeInputs = useCallback$m(() => {
    setNodes((currentNodes) => {
      return currentNodes.map((node) => {
        if (!node.data?.node_input) return node;
        const nodeInput = { ...node.data.node_input };
        const connectedSources = /* @__PURE__ */ new Set();
        edges.filter((edge) => edge.target === node.id).forEach((edge) => {
          connectedSources.add(
            `${edge.source}:${edge.sourceHandle || "output"}`
          );
        });
        let hasChanges = false;
        const cleanedNodeInput = {};
        Object.entries(nodeInput).forEach(([key, value]) => {
          if (value.is_empty || !value.node_id) {
            cleanedNodeInput[key] = value;
          } else {
            const sourceKey = `${value.node_id}:${value.output_name || "output"}`;
            if (connectedSources.has(sourceKey)) {
              cleanedNodeInput[key] = value;
            } else {
              console.log(`移除節點 ${node.id} 的孤兒 node_input 項目: ${key}`);
              hasChanges = true;
            }
          }
        });
        if (hasChanges) {
          console.log(`清理節點 ${node.id} 的 node_input，移除了孤兒項目`);
          return {
            ...node,
            data: {
              ...node.data,
              node_input: cleanedNodeInput
            }
          };
        }
        return node;
      });
    });
  }, [nodes, edges, setNodes]);
  useEffect$n(() => {
    if (isLoadingWorkflow.current) {
      return;
    }
    const timeoutId = setTimeout(() => {
      cleanupInvalidEdges();
      cleanupNodeInputs();
    }, 1e3);
    return () => clearTimeout(timeoutId);
  }, [nodes.length, edges.length]);
  const startWorkflowLoading = useCallback$m(() => {
    isLoadingWorkflow.current = true;
  }, []);
  const finishWorkflowLoading = useCallback$m(() => {
    setTimeout(() => {
      isLoadingWorkflow.current = false;
    }, 2e3);
  }, []);
  useEffect$n(() => {
    if (typeof window !== "undefined") {
      window.startWorkflowLoading = startWorkflowLoading;
      window.finishWorkflowLoading = finishWorkflowLoading;
    }
    return () => {
      if (typeof window !== "undefined") {
        delete window.startWorkflowLoading;
        delete window.finishWorkflowLoading;
      }
    };
  }, [startWorkflowLoading, finishWorkflowLoading]);
  useEffect$n(() => {
    if (typeof window !== "undefined") {
      window.cleanupInvalidEdges = cleanupInvalidEdges;
      window.cleanupNodeInputs = cleanupNodeInputs;
      window.currentEdges = edges;
    }
    return () => {
      if (typeof window !== "undefined") {
        delete window.cleanupInvalidEdges;
        delete window.cleanupNodeInputs;
        delete window.currentEdges;
      }
    };
  }, [cleanupInvalidEdges, cleanupNodeInputs, edges]);
  return {
    nodes,
    setNodes: safeSetNodes,
    edges,
    setEdges: safeSetEdges,
    onNodesChange: handleNodesChange,
    onEdgesChange: handleEdgesChange,
    onConnect,
    onNodesDelete,
    handleAddNode,
    handleAddInputNode,
    handleAddAINode,
    handleAddBrowserExtensionInput,
    handleAddBrowserExtensionOutput,
    updateNodeLabel,
    deleteSelectedNodes,
    handleAddIfElseNode,
    handleAddKnowledgeRetrievalNode,
    handleAddWebhookNode,
    handleAddHttpRequestNode,
    handleAddLineNode,
    handleAddLineMessageNode,
    handleAddEventNode,
    updateNodeFunctions,
    handleAddEndNode,
    handleAddTimerNode,
    handleNodeSelection,
    handleAddExtractDataNode,
    handleAddQOCAAimNode,
    handleAddScheduleTriggerNode,
    handleAddWebhookInputNode,
    handleAddWebhookOutputNode,
    handleAddCombineTextNode,
    handleAddRouterSwitchNode,
    undo,
    redo,
    getNodeCallbacks,
    handleAutoLayout,
    // 新增的自動排版函數
    deleteEdgesByHandle,
    deleteEdgesBySourceHandle,
    startWorkflowLoading,
    finishWorkflowLoading
  };
}

const __vite_import_meta_env__ = {"BASE_URL": "/agent-editor/", "DEV": false, "MODE": "production", "PROD": true, "SSR": false, "VITE_APP_BUILD_ID": "81b35a7368b61638c15bd38bf3874dfb332d06ee", "VITE_APP_BUILD_TIME": "2025-08-18T02:14:44.868Z", "VITE_APP_GIT_BRANCH": "main", "VITE_APP_VERSION": "0.1.51.7"};
function getEnvVar(name, defaultValue) {
  if (typeof window !== "undefined" && window.ENV && window.ENV[name]) {
    return window.ENV[name];
  }
  if (typeof import.meta !== "undefined" && __vite_import_meta_env__ && __vite_import_meta_env__[name]) {
    return __vite_import_meta_env__[name];
  }
  return defaultValue;
}
class VersionService {
  constructor() {
    this.version = getEnvVar("VITE_APP_VERSION", "0.0.0");
    this.buildTime = getEnvVar("VITE_APP_BUILD_TIME", (/* @__PURE__ */ new Date()).toISOString());
    this.buildId = getEnvVar("VITE_APP_BUILD_ID", "development");
    this.environment = getEnvVar("MODE", "development");
  }
  /**
   * 獲取完整的版本信息
   * @returns {Object} 版本信息
   */
  getVersionInfo() {
    return {
      version: this.version,
      buildTime: this.buildTime,
      buildId: this.buildId,
      environment: this.environment
    };
  }
  /**
   * 獲取版本號
   * @param {string} version 版本號
   */
  getVersion() {
    return this.version;
  }
  /**
   * 獲取格式化的版本字串
   * @returns {string} 格式化的版本字串
   */
  getFormattedVersion() {
    return `v${this.version}`;
  }
}
const versionService = new VersionService();

await importShared('react');
const VersionDisplay = ({ className = "" }) => {
  const versionInfo = versionService.getVersionInfo();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `version-display text-xs text-gray-500 ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "version-number", children: versionService.getFormattedVersion() }),
    versionInfo.environment !== "production" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "version-environment ml-1", children: [
      "(",
      versionInfo.environment,
      ")"
    ] })
  ] });
};

const iconInputNode = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%206a6%206%200%200%201%206-6h20a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6z'%20fill='%23DBEAFE'/%3e%3cpath%20d='M6%208h20v16H6V8z'%20stroke='%23E5E7EB'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M15.356%209.478c-3.82%200-6.915%203.144-6.915%207.022s3.096%207.022%206.915%207.022c3.82%200%206.915-3.144%206.915-7.022s-3.096-7.022-6.915-7.022zM6%2016.5C6%2011.253%2010.189%207%2015.356%207s9.356%204.253%209.356%209.5-4.189%209.5-9.356%209.5S6%2021.747%206%2016.5z'%20fill='%230075FF'/%3e%3cpath%20d='M18.61%2016.5c0%201.825-1.457%203.304-3.254%203.304s-3.254-1.479-3.254-3.304c0-1.825%201.457-3.304%203.254-3.304s3.254%201.48%203.254%203.304z'%20fill='%230075FF'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M14.136%2016.5c0-.684.546-1.24%201.22-1.24H28.78c.673%200%201.22.556%201.22%201.24a1.23%201.23%200%200%201-1.22%201.24H15.356a1.23%201.23%200%200%201-1.22-1.24z'%20fill='%230075FF'/%3e%3c/svg%3e";

const iconAINode = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%206a6%206%200%200%201%206-6h20a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6z'%20fill='%23FEF3C7'/%3e%3cpath%20d='M0%206a6%206%200%200%201%206-6h20a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6z'%20stroke='%23FFEDD5'/%3e%3cpath%20d='M16%204a12%2012%200%200%200%2012%2012%2012%2012%200%200%200-12%2012A12%2012%200%200%200%204%2016%2012%2012%200%200%200%2016%204z'%20fill='%23FFAA1E'/%3e%3cpath%20d='m9.798%209.798-3.46-3.459M9.798%2020.413l-3.46%203.459M22.458%209.798l3.459-3.459M22.458%2020.413l3.459%203.459'%20stroke='%23FFAA1E'%20stroke-linecap='round'/%3e%3c/svg%3e";

const browserNode = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%206a6%206%200%200%201%206-6h20a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6z'%20fill='%231FC2D8'/%3e%3cpath%20d='M15.348%206.375c1.524.026%202.765%201.306%202.765%202.85v.587h2.717a2.333%202.333%200%200%201%202.358%202.357v2.718h.586c1.572%200%202.851%201.246%202.851%202.778%200%201.573-1.263%202.853-2.815%202.853h-.622v2.717c0%201.318-1.058%202.39-2.358%202.39H17V23.66a1.345%201.345%200%200%200-.412-.973c-.33-.325-.81-.508-1.314-.5a1.908%201.908%200%200%200-1.222.458%201.38%201.38%200%200%200-.49%201.049v1.93H9.765a2.392%202.392%200%200%201-2.39-2.39v-3.798h1.964c.393%200%20.776-.168%201.078-.473a1.806%201.806%200%200%200%20.524-1.285c-.013-.91-.762-1.68-1.636-1.68h-1.93v-3.838a2.31%202.31%200%200%201%20.71-1.676%202.402%202.402%200%200%201%201.68-.673h2.717V9.19a2.817%202.817%200%200%201%202.866-2.815zM19.5%2011a2.502%202.502%200%200%201-2.5%202.5%202.5%202.5%200%200%201%202.5%202.5%202.5%202.5%200%200%201%202.5-2.5%202.5%202.5%200%200%201-2.5-2.5z'%20fill='url(%232gd0aibcla)'/%3e%3cdefs%3e%3clinearGradient%20id='2gd0aibcla'%20x1='17'%20y1='6.374'%20x2='17'%20y2='25.625'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23AAF2EA'/%3e%3cstop%20offset='1'%20stop-color='%23FEF3C7'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e";

const knowledgeNode = "/agent-editor/assets/icn-knowledge-BSj19GCR.svg";

const lineWebhookNode = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%206a6%206%200%200%201%206-6h20a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6z'%20fill='%23F5F5F5'/%3e%3cg%20clip-path='url(%23eoinu5f72a)'%3e%3cpath%20d='M29%2016c0-7.18-5.82-13-13-13S3%208.82%203%2016s5.82%2013%2013%2013%2013-5.82%2013-13z'%20fill='%2306C755'/%3e%3cpath%20d='M24.521%2014.658c0-3.871-3.877-7.02-8.643-7.02-4.766%200-8.643%203.149-8.643%207.02%200%203.47%203.078%206.378%207.228%206.926.282.061.665.186.761.427.068.255.078.523.029.783l-.124.74c-.038.219-.174.855.748.467.922-.389%204.977-2.934%206.79-5.024%201.254-1.375%201.854-2.773%201.854-4.319z'%20fill='%23fff'/%3e%3cpath%20d='M21.599%2016.855h-2.385a.159.159%200%200%201-.159-.159v-3.699a.159.159%200%200%201%20.16-.159h2.384a.159.159%200%200%201%20.159.16v.6a.16.16%200%200%201-.16.16h-1.62v.624h1.619a.159.159%200%200%201%20.159.159v.607a.159.159%200%200%201-.159.16h-1.62v.624h1.62a.159.159%200%200%201%20.159.159v.602a.159.159%200%200%201-.159.164l.002-.002zM12.66%2016.858a.159.159%200%200%200%20.16-.16v-.6a.16.16%200%200%200-.16-.16h-1.618v-2.94a.159.159%200%200%200-.16-.159h-.603a.16.16%200%200%200-.113.047.159.159%200%200%200-.046.112v3.697a.159.159%200%200%200%20.159.16h2.384l-.002.003zM13.83%2012.831a.462.462%200%200%200-.463.463v3.1a.463.463%200%201%200%20.925%200v-3.1a.462.462%200%200%200-.463-.463zM18.263%2012.831h-.601a.159.159%200%200%200-.16.16v2.197L15.81%2012.9a.099.099%200%200%200-.014-.016l-.01-.01-.008-.007h-.005l-.009-.006h-.004l-.01-.005h-.673a.158.158%200%200%200-.159.159v3.701a.159.159%200%200%200%20.16.159h.601a.159.159%200%200%200%20.159-.159v-2.22l1.695%202.29c.011.015.025.03.042.04l.01.007h.004l.008.004h.024a.193.193%200%200%200%20.043.005h.598a.159.159%200%200%200%20.159-.159v-3.69a.158.158%200%200%200-.159-.162z'%20fill='%2306C755'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='eoinu5f72a'%3e%3cpath%20fill='%23fff'%20transform='translate(3%203)'%20d='M0%200h26v26H0z'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";

const aimNode = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%206a6%206%200%200%201%206-6h20a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6z'%20fill='%23098D7F'/%3e%3cpath%20d='M21.75%209a1.75%201.75%200%200%201%20.75%203.332v.168a2.252%202.252%200%200%201-2.25%202.25h-1.5a.75.75%200%200%201%200-1.5h1.5a.75.75%200%200%200%20.75-.75v-.168A1.75%201.75%200%200%201%2021.75%209zm0%201a.75.75%200%201%200%200%201.5.75.75%200%200%200%200-1.5zM21.25%2017a2.252%202.252%200%200%201%202.25%202.25v.418a1.75%201.75%200%201%201-1.5%200v-.418a.75.75%200%200%200-.75-.75h-2.5a.75.75%200%200%201%200-1.5h2.5zm1.5%203.5a.75.75%200%201%200%200%201.5.75.75%200%200%200%200-1.5z'%20fill='%23fff'/%3e%3cpath%20d='M14.5%207a2.982%202.982%200%200%201%201.342.324%202.088%202.088%200%200%200%201.816%200A2.922%202.922%200%200%201%2019%207h.75a.75.75%200%200%201%200%201.5H19a1.501%201.501%200%200%200-1.5%201.5v12a1.501%201.501%200%200%200%201.5%201.5h.75a.75.75%200%200%201%200%201.5H19a2.982%202.982%200%200%201-1.342-.324%202.088%202.088%200%200%200-1.816%200A2.94%202.94%200%200%201%2014.5%2025h-.75A6.758%206.758%200%200%201%207%2018.25v-4.5A6.758%206.758%200%200%201%2013.75%207h.75zm-.75%201.5a5.254%205.254%200%200%200-4.9%203.384c-.217.57.256%201.116.865%201.116h1.035a.75.75%200%200%200%20.75-.75v-.002a1.25%201.25%200%201%201%201.5%200v.002a2.252%202.252%200%200%201-2.25%202.25H9.5a1%201%200%200%200-1%201v1.25c0%20.414.336.75.75.75h.001a1.25%201.25%200%201%201%20.004%201.504c-.369.042-.638.384-.528.749A5.254%205.254%200%200%200%2013.75%2023.5h.75A1.501%201.501%200%200%200%2016%2022v-2a1%201%200%200%200-1-1h-.5a.75.75%200%200%200-.75.75v.09a1%201%200%201%201-1.5%200v-.09a2.252%202.252%200%200%201%202.25-2.25h.5a1%201%200%200%200%201-1v-1.25a.748.748%200%200%200-.267-.573%201%201%200%201%201-.601-1.667l.041-.006.154-.008A.75.75%200%200%200%2016%2012.25V10a1.501%201.501%200%200%200-1.5-1.5h-.75z'%20fill='%23fff'/%3e%3c/svg%3e";

const httpNode = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%206C0%202.68629%202.68629%200%206%200H26C29.3137%200%2032%202.68629%2032%206V26C32%2029.3137%2029.3137%2032%2026%2032H6C2.68629%2032%200%2029.3137%200%2026V6Z'%20fill='%23F8D7DA'/%3e%3cpath%20d='M8.49787%2014.6875V12H10.2036V20H8.49787V16.6875H6.20576V20H4.5V12H6.20576V14.6875H8.49787ZM11.323%2014V12H16.4403V14H14.7345V20H13.0288V14H11.323ZM17.5597%2014V12H22.677V14H20.9712V20H19.2655V14H17.5597ZM27.7942%2012C28.2562%2012%2028.656%2012.1979%2028.9936%2012.5938C29.3312%2012.9896%2029.5%2013.4583%2029.5%2014V15.3125C29.5%2015.8542%2029.3312%2016.3229%2028.9936%2016.7188C28.656%2017.1146%2028.2562%2017.3125%2027.7942%2017.3125H25.5554V20H23.8497V12H27.7942ZM27.7942%2015.3125V14H25.5554V15.3125H27.7942Z'%20fill='%23FC6165'/%3e%3c/svg%3e";

const promptIcon = "data:image/svg+xml,%3csvg%20width='60'%20height='61'%20viewBox='0%200%2060%2061'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20width='60'%20height='61'%20rx='12'%20fill='url(%23eqyxrzf2ja)'/%3e%3cpath%20d='M27.647%2030.324a1.576%201.576%200%200%201%202.248%200l.547.553c.62.63.62%201.649%200%202.277L15.919%2047.861a1.576%201.576%200%200%201-2.248%200l-.547-.553a1.625%201.625%200%200%201%200-2.277l14.523-14.707zM36.141%2017.204c0%20.663-.53%201.201-1.186%201.201a1.194%201.194%200%200%201-1.186-1.2V13.2c0-.663.531-1.201%201.186-1.201.655%200%201.186.538%201.186%201.201v4.003zM30.384%2018.785c.463.47.463%201.23%200%201.699a1.175%201.175%200%200%201-1.677%200l-2.796-2.831a1.212%201.212%200%200%201%200-1.698%201.175%201.175%200%200%201%201.677%200l2.796%202.83zM27.05%2024.81c.654%200%201.185.538%201.185%201.201s-.53%201.201-1.186%201.201h-3.953a1.193%201.193%200%200%201-1.186-1.2c0-.664.531-1.202%201.186-1.202h3.953zM46.814%2024.81c.655%200%201.186.538%201.186%201.201s-.53%201.201-1.186%201.201h-3.953a1.193%201.193%200%200%201-1.186-1.2c0-.664.531-1.202%201.186-1.202h3.953zM42.841%2015.955a1.175%201.175%200%200%201%201.677%200c.463.469.463%201.229%200%201.698l-2.795%202.83a1.175%201.175%200%200%201-1.677%200%201.212%201.212%200%200%201%200-1.698l2.795-2.83zM43.824%2033.197c.463.469.463%201.23%200%201.698a1.175%201.175%200%200%201-1.677%200l-2.796-2.83a1.212%201.212%200%200%201%200-1.699%201.175%201.175%200%200%201%201.678%200l2.795%202.83zM36.141%2038.02c0%20.664-.53%201.202-1.186%201.202a1.194%201.194%200%200%201-1.186-1.201v-4.004c0-.663.531-1.2%201.186-1.2.655%200%201.186.537%201.186%201.2v4.004zM34.745%2021.223a.236.236%200%200%201%20.421%200l1.499%202.953c.022.045.058.081.102.104l2.917%201.517a.242.242%200%200%201%200%20.428l-2.917%201.517a.238.238%200%200%200-.102.104l-1.499%202.953a.236.236%200%200%201-.421%200l-1.499-2.953a.24.24%200%200%200-.102-.104l-2.917-1.517a.242.242%200%200%201%200-.428l2.917-1.517a.24.24%200%200%200%20.102-.104l1.498-2.953z'%20fill='%23fff'/%3e%3cdefs%3e%3clinearGradient%20id='eqyxrzf2ja'%20x1='0'%20y1='61'%20x2='60.992'%20y2='1.008'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%2300CED1'/%3e%3cstop%20offset='1'%20stop-color='%2387CEEB'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e";

const scheduleNode = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%208a8%208%200%200%201%208-8h16a8%208%200%200%201%208%208v16a8%208%200%200%201-8%208H8a8%208%200%200%201-8-8V8z'%20fill='%23EDE9FE'/%3e%3cpath%20d='M0%208a8%208%200%200%201%208-8h16a8%208%200%200%201%208%208v16a8%208%200%200%201-8%208H8a8%208%200%200%201-8-8V8z'%20stroke='%23E5E7EB'/%3e%3cg%20clip-path='url(%23hvwejly0za)'%3e%3cpath%20d='M16%208a8%208%200%201%201%200%2016%208%208%200%200%201%200-16zm-.75%203.75V16c0%20.25.125.484.334.625l3%202a.748.748%200%200%200%201.041-.21.748.748%200%200%200-.21-1.04L16.75%2015.6v-3.85A.748.748%200%200%200%2016%2011a.748.748%200%200%200-.75.75z'%20fill='%237C3AED'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='hvwejly0za'%3e%3cpath%20d='M8%208h16v16H8V8z'%20fill='%23fff'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";

const webhookOutputNode = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%206a6%206%200%200%201%206-6h20a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6z'%20fill='%23FEE2E2'/%3e%3cpath%20d='M21.657%2022.247a1.373%201.373%200%201%200%200-2.745%201.373%201.373%200%200%200%200%202.745zM16.167%2013.326a1.373%201.373%200%201%200%200-2.745%201.373%201.373%200%200%200%200%202.745zM10.677%2022.247a1.372%201.372%200%201%200%200-2.745%201.372%201.372%200%200%200%200%202.745z'%20fill='%23DC2626'/%3e%3cpath%20d='M8.481%2018.084a.915.915%200%200%201%20.183%201.281%202.516%202.516%200%201%200%204.53%201.51c0-.505.41-.915.914-.915h7.55a.915.915%200%200%201%200%201.83h-6.732a4.345%204.345%200%200%201-7.351%202.13%204.347%204.347%200%200%201-.375-5.653.915.915%200%200%201%201.281-.183z'%20fill='%23DC2626'/%3e%3cpath%20d='M15.107%207.742a4.346%204.346%200%200%201%205.043%202.472.915.915%200%201%201-1.676.734%202.517%202.517%200%201%200-3.627%203.15c.429.265.563.827.298%201.257l-3.688%206a.915.915%200%201%201-1.56-.96l3.262-5.303a4.347%204.347%200%200%201%201.948-7.35z'%20fill='%23DC2626'/%3e%3cpath%20d='M15.688%2011.174a.915.915%200%200%201%201.259.3l3.26%205.302a4.345%204.345%200%201%201%201.451%208.445.915.915%200%200%201-.001-1.83%202.516%202.516%200%201%200-1.322-4.66.915.915%200%200%201-1.258-.3l-3.69-5.998a.915.915%200%200%201%20.301-1.259z'%20fill='%23DC2626'/%3e%3c/svg%3e";

const CombineTextNode$2 = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M0%206a6%206%200%200%201%206-6h20a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6z'%20fill='%23E9F6FE'/%3e%3cpath%20d='M12.52%208c.074.008.14.06.165.134l.375%201.07a.202.202%200%200%201-.008.154.201.201%200%200%201-.115.102c-.49.167-.813.454-.99.86l-.002-.002c-.185.434-.279.939-.279%201.515v1.61c0%20.549-.12%201.054-.36%201.511l.002.001a2.452%202.452%200%200%201-.807.905c.349.241.619.541.805.903.241.453.36.963.36%201.523v1.594c0%20.387.04.74.12%201.061.081.318.215.588.398.813.181.217.43.385.755.5a.2.2%200%200%201%20.121.254l-.375%201.078a.2.2%200%200%201-.243.127c-.727-.209-1.315-.505-1.75-.895a3.232%203.232%200%200%201-.922-1.34%204.786%204.786%200%200%201-.262-1.598v-1.594c0-.34-.05-.622-.142-.847a1.028%201.028%200%200%200-.413-.507l-.005-.003c-.176-.118-.42-.185-.748-.185a.2.2%200%200%201-.2-.2v-1.367c0-.11.09-.2.2-.2.499%200%20.813-.144.996-.39.2-.266.312-.642.312-1.145v-1.609c0-.567.087-1.1.262-1.598a3.23%203.23%200%200%201%20.922-1.34c.436-.391%201.024-.684%201.751-.887L12.52%208z'%20fill='url(%23yuefy94lna)'/%3e%3cpath%20d='M19.549%208.008c.732.203%201.323.496%201.758.886l.156.146c.349.347.603.746.76%201.195.174.497.261%201.03.261%201.598v1.61c0%20.329.049.607.142.839.09.224.228.393.416.516h-.001c.183.114.43.178.758.178.11%200%20.2.09.2.2v1.368a.2.2%200%200%201-.2.2c-.49%200-.806.145-.996.396v.002c-.205.268-.319.642-.319%201.144v1.594c0%20.567-.087%201.1-.262%201.597-.178.514-.485.96-.915%201.341-.435.39-1.025.686-1.758.895a.2.2%200%200%201-.243-.127l-.375-1.078a.2.2%200%200%201%20.123-.254c.331-.115.579-.284.754-.5.183-.225.314-.494.391-.812v-.004a4.18%204.18%200%200%200%20.127-1.058v-1.594c0-.56.116-1.066.351-1.515l.001-.002c.199-.369.489-.67.864-.907a2.469%202.469%200%200%201-.864-.911l-.002-.003a3.225%203.225%200%200%201-.35-1.506v-1.61c0-.386-.04-.743-.12-1.07a1.967%201.967%200%200%200-.396-.81l-.002-.001c-.175-.216-.422-.381-.752-.491a.2.2%200%200%201-.125-.256l.375-1.07.038-.066a.2.2%200%200%201%20.205-.06z'%20fill='url(%23bldebrycdb)'/%3e%3cdefs%3e%3clinearGradient%20id='yuefy94lna'%20x1='10.536'%20y1='8'%20x2='10.536'%20y2='23.721'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%237C3AED'/%3e%3cstop%20offset='1'%20stop-color='%231FC1B1'/%3e%3c/linearGradient%3e%3clinearGradient%20id='bldebrycdb'%20x1='21.46'%20y1='8'%20x2='21.46'%20y2='23.72'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%237C3AED'/%3e%3cstop%20offset='1'%20stop-color='%231FC1B1'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e";

const RouterSwitchNode$2 = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M26%200a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6a6%206%200%200%201%206-6h20z'%20fill='%23D1FAE5'/%3e%3cpath%20d='M26%200a6%206%200%200%201%206%206v20a6%206%200%200%201-6%206H6a6%206%200%200%201-6-6V6a6%206%200%200%201%206-6h20z'%20stroke='%23E5E7EB'/%3e%3cg%20clip-path='url(%239xt5qgzx9a)'%3e%3cpath%20d='M20.75%2011.5a.75.75%200%201%200%201.5%200%20.75.75%200%200%200-1.5%200zm.75%202.5a2.495%202.495%200%200%201-2.29-1.5h-2.744c.34.588.534%201.272.534%202v3c0%201.103.897%202%202%202h.21a2.5%202.5%200%201%201%200%202H19a4%204%200%200%201-4-4v-3c0-1.103-.897-2-2-2h-.21a2.5%202.5%200%201%201%200-2h6.42A2.5%202.5%200%201%201%2021.5%2014zm0%207.25a.75.75%200%201%200%200-1.5.75.75%200%200%200%200%201.5zM9.75%2011.5a.75.75%200%201%200%201.5%200%20.75.75%200%200%200-1.5%200z'%20fill='%23059669'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='9xt5qgzx9a'%3e%3cpath%20d='M24%209v14H8V9h16z'%20fill='%23fff'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";

await importShared('react');
const iconMap = {
  input: {
    src: iconInputNode,
    alt: "Input Icon"
  },
  ai: {
    src: iconAINode,
    alt: "AI Icon"
  },
  browser: {
    src: browserNode,
    alt: "Browser Icon"
  },
  knowledge: {
    src: knowledgeNode,
    alt: "Knowledge Icon"
  },
  line: {
    src: lineWebhookNode,
    alt: "Line Icon"
  },
  aim: {
    src: aimNode,
    alt: "QOCA aim Icon"
  },
  http: {
    src: httpNode,
    alt: "HTTP Icon"
  },
  prompt: {
    src: promptIcon
  },
  schedule: {
    src: scheduleNode,
    alt: "Schedule Icon"
  },
  webhook_input: {
    src: webhookOutputNode,
    alt: "Webhook Input Icon"
  },
  webhook_output: {
    src: webhookOutputNode,
    alt: "Webhook Output Icon"
  },
  combine_text: {
    src: CombineTextNode$2,
    alt: "Combine Text Icon"
  },
  router_switch: {
    src: RouterSwitchNode$2,
    alt: "Router Switch Icon"
  }
};
const IconBase = ({ type, className = "" }) => {
  if (!iconMap[type]) {
    console.warn(`Icon type "${type}" not found`);
    return null;
  }
  const { src, alt } = iconMap[type];
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `flex items-center justify-center ${className}`,
      style: {
        width: "32px",
        height: "32px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src,
          alt,
          width: 32,
          height: 32,
          className: "max-w-full max-h-full object-contain",
          style: {
            maxWidth: "100%",
            maxHeight: "100%",
            objectFit: "contain"
          }
        }
      )
    }
  );
};

const dragIcon = "data:image/svg+xml,%3csvg%20width='12'%20height='20'%20viewBox='0%200%2012%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M2%204a2%202%200%201%200%200-4%202%202%200%200%200%200%204zM2%2020a2%202%200%201%200%200-4%202%202%200%200%200%200%204zM10%204a2%202%200%201%200%200-4%202%202%200%200%200%200%204zM10%2020a2%202%200%201%200%200-4%202%202%200%200%200%200%204zM10%2012a2%202%200%201%200%200-4%202%202%200%200%200%200%204zM2%2012a2%202%200%201%200%200-4%202%202%200%200%200%200%204z'%20fill='%23000'/%3e%3c/svg%3e";

const React$w = await importShared('react');
const {useState: useState$u} = React$w;
const NodeSidebar = ({
  handleButtonClick,
  onDragStart: customDragStart,
  nodes = [],
  isLocked = false
  // 新增 isLocked 參數
}) => {
  const [searchTerm, setSearchTerm] = useState$u("");
  const handleSearch = (e) => {
    setSearchTerm(e.target.value);
  };
  const filterNodes = (label) => {
    if (!searchTerm) return true;
    return label.toLowerCase().includes(searchTerm.toLowerCase());
  };
  const hasLineNode = nodes.some((node) => node.type === "line_webhook_input");
  const handleNodeClick = (nodeType) => {
    if (isLocked) {
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "工作流已鎖定，無法添加節點",
          type: "warning",
          duration: 3e3
        });
      }
      return;
    }
    if (nodeType === "line_webhook_input" && hasLineNode) {
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "每個 Flow 只能有一個 Line Webhook 節點",
          type: "warning",
          duration: 4e3
        });
      }
      return;
    }
    handleButtonClick(nodeType);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `w-64 bg-white p-4 shadow-md h-full overflow-y-auto ${isLocked ? "bg-gray-50" : ""}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative mb-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              placeholder: "Search nodes...",
              className: `w-full p-2 pl-3 pr-10 border rounded-md`,
              onChange: handleSearch,
              value: searchTerm
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "16",
              height: "16",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "circle",
                  {
                    cx: "11",
                    cy: "11",
                    r: "8"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "line",
                  {
                    x1: "21",
                    y1: "21",
                    x2: "16.65",
                    y2: "16.65"
                  }
                )
              ]
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
          filterNodes("Input") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "input" }) }),
              label: "Input",
              onClick: () => handleNodeClick("input"),
              nodeType: "input",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("AI") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "ai" }) }),
              label: "AI",
              onClick: () => handleNodeClick("ai"),
              nodeType: "ai",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("Browser Extension input") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "browser" }) }),
              label: "Browser Extension input",
              onClick: () => handleNodeClick("browser extension input"),
              nodeType: "browser extension input",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("Browser Extension output") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "browser" }) }),
              label: "Browser Extension output",
              onClick: () => handleNodeClick("browser extension output"),
              nodeType: "browser extension output",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("Knowledge Retrieval") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "knowledge" }) }),
              label: "Knowledge Retrieval",
              onClick: () => handleNodeClick("knowledge retrieval"),
              nodeType: "knowledge retrieval",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("line") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              color: "green",
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "line" }) }),
              label: "LINE",
              onClick: () => handleNodeClick("line_webhook_input"),
              nodeType: "line_webhook_input",
              onDragStart: customDragStart,
              disabled: hasLineNode || isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : hasLineNode ? "每個 Flow 只能有一個 Line Webhook 節點" : null
            }
          ),
          filterNodes("send message") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "line" }) }),
              label: "Send Message",
              onClick: () => handleNodeClick("line_send_message"),
              nodeType: "line_send_message",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("Extract Data Node") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "ai" }) }),
              label: "Extract Data",
              onClick: () => handleNodeClick("extract_data"),
              nodeType: "extract_data",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("HTTP") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "http" }) }),
              label: "HTTP",
              onClick: () => handleNodeClick("http_request"),
              nodeType: "http_request",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("schedule trigger") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "schedule" }) }),
              label: "Schedule",
              onClick: () => handleNodeClick("schedule_trigger"),
              nodeType: "schedule_trigger",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("webhook input") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "webhook_input" }) }),
              label: "Webhook",
              onClick: () => handleNodeClick("webhook_input"),
              nodeType: "webhook_input",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("webhook output") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "webhook_output" }) }),
              label: "Output",
              onClick: () => handleNodeClick("webhook_output"),
              nodeType: "webhook_output",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("Combine Text") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "combine_text" }) }),
              label: "Combine Text",
              onClick: () => handleNodeClick("combine_text"),
              nodeType: "combine_text",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          ),
          filterNodes("Router Switch") && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeItem,
            {
              icon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "router_switch" }) }),
              label: "Router Switch",
              onClick: () => handleNodeClick("router_switch"),
              nodeType: "router_switch",
              onDragStart: customDragStart,
              disabled: isLocked,
              disabledReason: isLocked ? "工作流已鎖定" : null
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(VersionDisplay, {})
      ]
    }
  );
};
const NodeItem = ({
  icon,
  label,
  onClick,
  nodeType,
  onDragStart,
  disabled = false,
  disabledReason = null
}) => {
  const handleDragStart = (event) => {
    if (disabled) {
      event.preventDefault();
      return;
    }
    event.dataTransfer.setData("application/reactflow", nodeType);
    event.dataTransfer.effectAllowed = "move";
    if (onDragStart) {
      onDragStart(event, nodeType);
    }
  };
  const handleDragEnd = (event) => {
    event.currentTarget.classList.remove("dragging");
  };
  const handleClick = () => {
    if (disabled) {
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: disabledReason || "此節點類型已被禁用",
          type: "warning",
          duration: 3e3
        });
      }
      return;
    }
    onClick();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `node-item border flex items-center justify-between p-2 rounded-lg transition-colors ${disabled ? "opacity-50 cursor-not-allowed bg-gray-100" : "cursor-grab hover:bg-gray-50"}`,
      onClick: handleClick,
      draggable: !disabled,
      onDragStart: handleDragStart,
      onDragEnd: handleDragEnd,
      "data-node-type": nodeType,
      title: disabled ? disabledReason : label,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 mr-3 flex-shrink-0 flex items-center justify-center", children: icon }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: `text-sm leading-none font-bold ${disabled ? "text-gray-400" : "text-gray-700"}`,
              children: label
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `ml-2 ${disabled ? "text-gray-300" : "text-gray-400 hover:text-gray-600"}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "flex items-center justify-center",
                style: {
                  width: "16px",
                  height: "16px",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: dragIcon,
                    width: 16,
                    height: 16,
                    className: "max-w-full max-h-full object-contain",
                    style: {
                      maxWidth: "100%",
                      maxHeight: "100%",
                      objectFit: "contain",
                      opacity: disabled ? 0.3 : 1
                      // 禁用時降低透明度
                    }
                  }
                )
              }
            )
          }
        )
      ]
    }
  );
};

const workflowIcon = "data:image/svg+xml,%3csvg%20width='18'%20height='18'%20viewBox='0%200%2018%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23nujox52vfa)'%20fill='%233F3F46'%3e%3cpath%20d='M5.143%205.143H0V0h5.143v5.143zM1.286%203.857h2.572V1.286H1.286v2.57zM18%2018h-5.143v-5.143H18V18zm-3.857-1.286h2.572v-2.572h-2.572v2.572zM11.571%2016.072H3.857a3.857%203.857%200%200%201%200-7.715v1.286a2.572%202.572%200%201%200%200%205.143h7.714v1.286zM14.143%209.643V8.357a2.572%202.572%200%200%200%200-5.143H6.43V1.928h7.714a3.857%203.857%200%200%201%200%207.715z'/%3e%3cpath%20d='M10.926%205.786H7.07L5.143%208.358l3.856%203.857%203.857-3.857-1.93-2.572z'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='nujox52vfa'%3e%3cpath%20fill='%23fff'%20d='M0%200h18v18H0z'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";

const pencilIcon = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill='%23fff'%20fill-opacity='.01'%20d='M0%200h16v16H0z'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M12.644%201.223a.533.533%200%200%200-.754%200L3.962%209.15c-.096.096-.173.21-.226.334l-1.56%203.64a.533.533%200%200%200%20.7.7l3.64-1.56c.124-.053.238-.13.334-.226l7.927-7.928a.533.533%200%200%200%200-.754l-2.133-2.133zM4.716%209.904l7.55-7.55%201.38%201.38-7.55%207.55-1.596.683-.467-.468.683-1.595z'%20fill='%231C2024'/%3e%3c/svg%3e";

const lockIcon = "data:image/svg+xml,%3csvg%20width='33'%20height='32'%20viewBox='0%200%2033%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M16.333%202.667a8%208%200%200%201%208%208v.435c0%20.526-.053%201.04-.15%201.538a6.626%206.626%200%200%201%203.966%204.576c.184.76.184%201.683.184%203.526%200%201.843%200%202.765-.184%203.525a6.638%206.638%200%200%201-4.926%204.884c-.767.183-1.697.183-3.557.183H13c-1.859%200-2.788%200-3.555-.183a6.639%206.639%200%200%201-4.927-4.884c-.184-.76-.184-1.682-.184-3.525s0-2.765.184-3.526a6.627%206.627%200%200%201%203.965-4.576%208.038%208.038%200%200%201-.149-1.538v-.436a8%208%200%200%201%208-8zm0%2015.431c-1.104%200-2%20.888-2%201.983v1.322c0%201.095.896%201.982%202%201.982%201.105%200%202-.888%202-1.982V20.08a1.992%201.992%200%200%200-2-1.983zm0-12.764A5.334%205.334%200%200%200%2011%2010.666v.436c0%20.364.036.719.106%201.062.507-.014%201.12-.013%201.894-.013h6.667c.774%200%201.387%200%201.894.013.07-.344.106-.698.106-1.062v-.436a5.333%205.333%200%200%200-5.333-5.333z'%20fill='%23FFAA1E'/%3e%3c/svg%3e";

const React$v = await importShared('react');
const {useState: useState$t} = React$v;
const APAAssistant = ({ title, onTitleChange, isLocked = false }) => {
  const [isEditing, setIsEditing] = useState$t(true);
  const handleEditClick = () => {
    if (isLocked) return;
    setIsEditing(true);
  };
  const handleSave = () => {
    if (isLocked) return;
  };
  const handleKeyDown = (e) => {
    if (isLocked) return;
    if (e.key === "Enter") {
      setIsEditing(false);
    }
  };
  const handleTitleChange = (value) => {
    if (isLocked) return;
    if (onTitleChange) {
      onTitleChange(value);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed top-4 left-1/2 transform -translate-x-1/2 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-full shadow-[0_3px_10px_rgb(0,0,0,0.1),0_6px_20px_rgb(0,0,0,0.05)]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `bg-white border border-gray-200 rounded-full px-4 py-2 flex items-center w-64 md:w-80 ${isLocked ? "bg-gray-50" : ""}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mr-2 text-gray-700 flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "flex items-center justify-center",
            style: {
              width: "16px",
              height: "16px",
              display: "flex",
              alignItems: "center",
              justifyContent: "center"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: workflowIcon,
                width: 16,
                height: 16,
                className: "max-w-full max-h-full object-contain",
                style: {
                  maxWidth: "100%",
                  maxHeight: "100%",
                  objectFit: "contain"
                }
              }
            )
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 relative min-w-0", children: isEditing && !isLocked ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            className: "w-full outline-none text-gray-800 bg-transparent",
            value: title || "",
            onChange: (e) => handleTitleChange(e.target.value),
            onBlur: handleSave,
            onKeyDown: handleKeyDown,
            autoFocus: true
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `w-full text-gray-800 truncate ${isLocked ? "text-gray-600 cursor-not-allowed" : "cursor-pointer hover:text-gray-600"}`,
            onClick: handleEditClick,
            title: isLocked ? "工作流已鎖定，無法編輯標題" : "點擊編輯標題",
            children: title || ""
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: `ml-2 flex-shrink-0 ${isLocked ? "text-orange-500" : "text-gray-500"}`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "flex items-center justify-center",
                style: {
                  width: "16px",
                  height: "16px",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center"
                },
                title: isLocked ? "工作流已鎖定" : "編輯標題",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: isLocked ? lockIcon : pencilIcon,
                    width: 16,
                    height: 16,
                    className: "max-w-full max-h-full object-contain",
                    style: {
                      maxWidth: "100%",
                      maxHeight: "100%",
                      objectFit: "contain"
                    }
                  }
                )
              }
            )
          }
        )
      ]
    }
  ) }) });
};

const React$u = await importShared('react');
const {memo: memo$k,useCallback: useCallback$l} = React$u;

const NodeWrapper = ({ children, selected, onClick }) => {
  const handleClick = useCallback$l(
    (e) => {
      e.stopPropagation();
      if (typeof onClick === "function") {
        onClick(e);
      }
    },
    [onClick]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `node-wrapper ${selected ? "selected-node" : ""}`,
      onClick: handleClick,
      style: {
        border: selected ? "1px solid #00CED1" : "none",
        borderRadius: "8px",
        boxShadow: selected ? "0 0 8px 1px rgba(0, 206, 209, 0.5), 0 0 12px 4px rgba(0, 206, 209, 0.1)" : "none",
        transition: "border 0.2s ease, box-shadow 0.3s ease",
        cursor: "pointer"
      },
      children
    }
  );
};
const NodeWrapper$1 = memo$k(NodeWrapper);

const React$t = await importShared('react');
const {memo: memo$j,useCallback: useCallback$k,useEffect: useEffect$m,useState: useState$s,useRef: useRef$i} = React$t;
const withNodeSelection = (WrappedComponent) => {
  const WithNodeSelection = (props) => {
    const { selected, data } = props;
    const nodeRef = useRef$i(null);
    const [isInputFocused, setIsInputFocused] = useState$s(false);
    const handleNodeClick = useCallback$k(
      (e) => {
        e.stopPropagation();
        if (data && typeof data.onSelect === "function") {
          data.onSelect();
        }
      },
      [data]
    );
    useEffect$m(() => {
      const handleFocus = (e) => {
        const isInput = e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable;
        if (isInput) {
          setIsInputFocused(true);
          const nodeElement = findReactFlowNode(e.target);
          if (nodeElement) {
            nodeElement._originalDraggable = nodeElement.draggable;
            nodeElement.draggable = false;
            nodeElement.classList.add("nodrag");
          }
        }
      };
      const handleBlur = (e) => {
        const isInput = e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable;
        if (isInput) {
          setIsInputFocused(false);
          const nodeElement = findReactFlowNode(e.target);
          if (nodeElement) {
            if (nodeElement._originalDraggable !== void 0) {
              nodeElement.draggable = nodeElement._originalDraggable;
              delete nodeElement._originalDraggable;
            }
            nodeElement.classList.remove("nodrag");
          }
        }
      };
      const handleMouseDown = (e) => {
        if (isInputFocused) {
          e.stopPropagation();
        }
      };
      document.addEventListener("focusin", handleFocus, true);
      document.addEventListener("focusout", handleBlur, true);
      if (nodeRef.current) {
        nodeRef.current.addEventListener("mousedown", handleMouseDown, true);
      }
      return () => {
        document.removeEventListener("focusin", handleFocus, true);
        document.removeEventListener("focusout", handleBlur, true);
        if (nodeRef.current) {
          nodeRef.current.removeEventListener(
            "mousedown",
            handleMouseDown,
            true
          );
        }
      };
    }, [isInputFocused]);
    function findReactFlowNode(element) {
      let current = element;
      while (current && !current.classList?.contains("react-flow__node")) {
        current = current.parentElement;
      }
      return current;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: nodeRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      NodeWrapper$1,
      {
        selected,
        onClick: handleNodeClick,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedComponent, { ...props })
      }
    ) });
  };
  WithNodeSelection.displayName = `withNodeSelection(${getDisplayName(
    WrappedComponent
  )})`;
  return memo$j(WithNodeSelection);
};
function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || "Component";
}

const React$s = await importShared('react');
const {useRef: useRef$h,useEffect: useEffect$l,useState: useState$r} = React$s;

const AutoResizeTextarea = ({
  value,
  onChange,
  onCompositionStart,
  onCompositionEnd,
  onKeyDown,
  placeholder,
  className,
  ...props
}) => {
  const textareaRef = useRef$h(null);
  const [isFocused, setIsFocused] = useState$r(false);
  useEffect$l(() => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    textarea.style.height = "auto";
    textarea.style.height = `${Math.max(textarea.scrollHeight, 60)}px`;
  }, [value]);
  useEffect$l(() => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    const handleFocus = () => {
      setIsFocused(true);
    };
    const handleBlur = () => {
      setIsFocused(false);
    };
    const handleMouseDown = (e) => {
      if (e.button === 1) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    textarea.addEventListener("focus", handleFocus);
    textarea.addEventListener("blur", handleBlur);
    textarea.addEventListener("mousedown", handleMouseDown);
    return () => {
      textarea.removeEventListener("focus", handleFocus);
      textarea.removeEventListener("blur", handleBlur);
      textarea.removeEventListener("mousedown", handleMouseDown);
    };
  }, []);
  useEffect$l(() => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    const handleWheelCapture = (e) => {
      if (isFocused && (e.target === textarea || textarea.contains(e.target))) {
        e.stopPropagation();
        const isAtTop = textarea.scrollTop <= 0;
        const isAtBottom = Math.abs(
          textarea.scrollTop + textarea.clientHeight - textarea.scrollHeight
        ) <= 1;
        if (isAtTop && e.deltaY < 0 || isAtBottom && e.deltaY > 0) {
          e.preventDefault();
        }
      }
    };
    const preventZoom = (e) => {
      if (isFocused && (e.ctrlKey || e.metaKey) && (e.target === textarea || textarea.contains(e.target))) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    document.addEventListener("wheel", handleWheelCapture, {
      passive: false,
      capture: true
    });
    document.addEventListener("wheel", preventZoom, {
      passive: false,
      capture: true
    });
    return () => {
      document.removeEventListener("wheel", handleWheelCapture, {
        passive: false,
        capture: true
      });
      document.removeEventListener("wheel", preventZoom, {
        passive: false,
        capture: true
      });
    };
  }, [isFocused]);
  useEffect$l(() => {
    if (isFocused) {
      const findReactFlowNode = (element) => {
        let current = element;
        while (current && !current.classList?.contains("react-flow__node")) {
          current = current.parentElement;
        }
        return current;
      };
      const reactFlowNode = findReactFlowNode(textareaRef.current);
      if (reactFlowNode) {
        reactFlowNode._originalClassName = reactFlowNode.className;
        reactFlowNode.classList.add("nodrag");
      }
      return () => {
        if (reactFlowNode && reactFlowNode._originalClassName) {
          reactFlowNode.className = reactFlowNode._originalClassName;
          delete reactFlowNode._originalClassName;
        }
      };
    }
  }, [isFocused]);
  const handleChange = (e) => {
    console.log(`AutoResizeTextarea onChange: "${e.target.value}"`);
    if (onChange) {
      onChange(e);
    }
  };
  const handleCompositionStart = (e) => {
    console.log("AutoResizeTextarea: composition start");
    if (onCompositionStart) {
      onCompositionStart(e);
    }
  };
  const handleCompositionEnd = (e) => {
    console.log("AutoResizeTextarea: composition end");
    if (onCompositionEnd) {
      onCompositionEnd(e);
    }
  };
  const handleKeyDown = (e) => {
    console.log(`AutoResizeTextarea keyDown: ${e.key}`);
    if (onKeyDown) {
      onKeyDown(e);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "textarea",
    {
      ref: textareaRef,
      value,
      onChange: handleChange,
      onCompositionStart: handleCompositionStart,
      onCompositionEnd: handleCompositionEnd,
      onKeyDown: handleKeyDown,
      placeholder,
      rows: 1,
      className: `
        w-full 
        border 
        border-gray-300 
        rounded 
        p-2 
        text-sm 
        resize-none 
        overflow-auto 
        min-h-[60px] 
        max-h-[200px]
        ${isFocused ? "z-50 shadow-md border-blue-400" : ""} 
        ${className}
      `,
      ...props
    }
  );
};

const React$r = await importShared('react');
const {memo: memo$i,useReducer,useCallback: useCallback$j,useState: useState$q,useEffect: useEffect$k,useRef: useRef$g} = React$r;
const CustomInputNode = ({ data, isConnectable, id }) => {
  const [localFields, setLocalFields] = useState$q([]);
  const [, forceUpdate] = useReducer((x) => x + 1, 0);
  const isComposingInputNameRef = useRef$g(false);
  const isComposingDefaultValueRef = useRef$g(false);
  const isUserInputInputNameRef = useRef$g(false);
  const isUserInputDefaultValueRef = useRef$g(false);
  const updateTimeoutRef = useRef$g({});
  const lastExternalInputNameRef = useRef$g("");
  const lastExternalDefaultValueRef = useRef$g("");
  useEffect$k(() => {
    if (Array.isArray(data.fields)) {
      const fieldToUse = data.fields.length > 0 ? [data.fields[0]] : [
        {
          inputName: "input_name",
          defaultValue: "Summary the input text"
        }
      ];
      const currentField = localFields[0];
      const newField = fieldToUse[0];
      console.log("CustomInputNode 數據同步檢查:", {
        "current inputName": currentField?.inputName,
        "new inputName": newField?.inputName,
        "current defaultValue": currentField?.defaultValue,
        "new defaultValue": newField?.defaultValue,
        isUserInputInputName: isUserInputInputNameRef.current,
        isUserInputDefaultValue: isUserInputDefaultValueRef.current
      });
      let shouldUpdate = false;
      if (!isUserInputInputNameRef.current && newField.inputName !== lastExternalInputNameRef.current) {
        lastExternalInputNameRef.current = newField.inputName;
        shouldUpdate = true;
      }
      if (!isUserInputDefaultValueRef.current && newField.defaultValue !== lastExternalDefaultValueRef.current) {
        lastExternalDefaultValueRef.current = newField.defaultValue;
        shouldUpdate = true;
      }
      if (shouldUpdate || localFields.length === 0) {
        setLocalFields(fieldToUse);
      }
    } else {
      const defaultFields = [
        {
          inputName: "input_name",
          defaultValue: "Summary the input text"
        }
      ];
      setLocalFields(defaultFields);
      lastExternalInputNameRef.current = "input_name";
      lastExternalDefaultValueRef.current = "Summary the input text";
    }
  }, [data.fields, localFields]);
  useEffect$k(() => {
    return () => {
      Object.values(updateTimeoutRef.current).forEach((timeout) => {
        if (timeout) clearTimeout(timeout);
      });
    };
  }, []);
  const handleUpdateFieldInputName = useCallback$j(
    (index, value) => {
      if (typeof data.updateFieldInputName === "function") {
        data.updateFieldInputName(index, value);
      } else {
        console.warn(
          `節點 ${id}: updateFieldInputName 函數未定義，使用本地實現`
        );
        const updatedFields = [...localFields];
        if (index >= 0 && index < updatedFields.length) {
          updatedFields[index] = {
            ...updatedFields[index],
            inputName: value
          };
          setLocalFields(updatedFields);
          if (data.fields) {
            data.fields = updatedFields;
          }
          forceUpdate();
        }
      }
    },
    [data, localFields, id]
  );
  const handleUpdateFieldDefaultValue = useCallback$j(
    (index, value) => {
      if (typeof data.updateFieldDefaultValue === "function") {
        data.updateFieldDefaultValue(index, value);
      } else {
        const updatedFields = [...localFields];
        if (index >= 0 && index < updatedFields.length) {
          updatedFields[index] = {
            ...updatedFields[index],
            defaultValue: value
          };
          setLocalFields(updatedFields);
          if (data.fields) {
            data.fields = updatedFields;
          }
          forceUpdate();
        }
      }
    },
    [data, localFields, id]
  );
  const debouncedUpdate = useCallback$j(
    (updateFunction, index, value, fieldType) => {
      const timeoutKey = `${fieldType}_${index}`;
      if (updateTimeoutRef.current[timeoutKey]) {
        clearTimeout(updateTimeoutRef.current[timeoutKey]);
      }
      updateTimeoutRef.current[timeoutKey] = setTimeout(() => {
        updateFunction(index, value);
        setTimeout(() => {
          if (fieldType === "inputName") {
            isUserInputInputNameRef.current = false;
          } else if (fieldType === "defaultValue") {
            isUserInputDefaultValueRef.current = false;
          }
        }, 100);
      }, 150);
    },
    []
  );
  const handleInputNameChange = useCallback$j(
    (e) => {
      const value = e.target.value;
      isUserInputInputNameRef.current = true;
      const updatedFields = [...localFields];
      if (updatedFields.length > 0) {
        updatedFields[0] = {
          ...updatedFields[0],
          inputName: value
        };
        setLocalFields(updatedFields);
        lastExternalInputNameRef.current = value;
      }
      if (!isComposingInputNameRef.current) {
        debouncedUpdate(handleUpdateFieldInputName, 0, value, "inputName");
      }
    },
    [localFields, handleUpdateFieldInputName, debouncedUpdate]
  );
  const handleDefaultValueChange = useCallback$j(
    (e) => {
      const value = e.target.value;
      isUserInputDefaultValueRef.current = true;
      const updatedFields = [...localFields];
      if (updatedFields.length > 0) {
        updatedFields[0] = {
          ...updatedFields[0],
          defaultValue: value
        };
        setLocalFields(updatedFields);
        lastExternalDefaultValueRef.current = value;
      }
      if (!isComposingDefaultValueRef.current) {
        debouncedUpdate(
          handleUpdateFieldDefaultValue,
          0,
          value,
          "defaultValue"
        );
      }
    },
    [localFields, handleUpdateFieldDefaultValue, debouncedUpdate]
  );
  const handleInputNameCompositionStart = useCallback$j(() => {
    isComposingInputNameRef.current = true;
    isUserInputInputNameRef.current = true;
    const timeoutKey = "inputName_0";
    if (updateTimeoutRef.current[timeoutKey]) {
      clearTimeout(updateTimeoutRef.current[timeoutKey]);
      updateTimeoutRef.current[timeoutKey] = null;
    }
  }, []);
  const handleDefaultValueCompositionStart = useCallback$j(() => {
    isComposingDefaultValueRef.current = true;
    isUserInputDefaultValueRef.current = true;
    const timeoutKey = "defaultValue_0";
    if (updateTimeoutRef.current[timeoutKey]) {
      clearTimeout(updateTimeoutRef.current[timeoutKey]);
      updateTimeoutRef.current[timeoutKey] = null;
    }
  }, []);
  const handleInputNameCompositionEnd = useCallback$j(
    (e) => {
      isComposingInputNameRef.current = false;
      const finalValue = e.target.value;
      lastExternalInputNameRef.current = finalValue;
      handleUpdateFieldInputName(0, finalValue);
      setTimeout(() => {
        isUserInputInputNameRef.current = false;
      }, 200);
    },
    [handleUpdateFieldInputName]
  );
  const handleDefaultValueCompositionEnd = useCallback$j(
    (e) => {
      isComposingDefaultValueRef.current = false;
      const finalValue = e.target.value;
      lastExternalDefaultValueRef.current = finalValue;
      handleUpdateFieldDefaultValue(0, finalValue);
      setTimeout(() => {
        isUserInputDefaultValueRef.current = false;
      }, 200);
    },
    [handleUpdateFieldDefaultValue]
  );
  const handleInputNameKeyDown = useCallback$j((e) => {
    if (e.key === "Backspace" || e.key === "Delete") {
      isUserInputInputNameRef.current = true;
      setTimeout(() => {
        isUserInputInputNameRef.current = false;
      }, 300);
    }
  }, []);
  const handleDefaultValueKeyDown = useCallback$j((e) => {
    if (e.key === "Backspace" || e.key === "Delete") {
      isUserInputDefaultValueRef.current = true;
      setTimeout(() => {
        isUserInputDefaultValueRef.current = false;
      }, 300);
    }
  }, []);
  const fields = Array.isArray(localFields) && localFields.length > 0 ? localFields : Array.isArray(data.fields) ? data.fields : [];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shadow-md w-64 relative", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-100 rounded-t-lg p-4 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "input" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Input" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-t border-gray-200" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-lg shadow-md rounded-lg w-64 relative", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-bl-xl rounded-br-xl p-4", children: [
      fields.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 text-sm mb-4", children: "No input field found" }),
      fields.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 last:mb-2 relative", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "input_name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "w-full border border-gray-300 rounded p-2 text-sm",
              placeholder: "AI node prompt",
              value: fields[0].inputName || "",
              onChange: handleInputNameChange,
              onCompositionStart: handleInputNameCompositionStart,
              onCompositionEnd: handleInputNameCompositionEnd,
              onKeyDown: handleInputNameKeyDown
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "default_value" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AutoResizeTextarea,
            {
              value: fields[0].defaultValue || "",
              onChange: handleDefaultValueChange,
              onCompositionStart: handleDefaultValueCompositionStart,
              onCompositionEnd: handleDefaultValueCompositionEnd,
              onKeyDown: handleDefaultValueKeyDown,
              placeholder: "Summary the input text"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              position: "absolute",
              right: "-18px",
              top: "50%",
              transform: "translateY(-50%)",
              width: "10px",
              height: "10px",
              background: "transparent"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Handle$1,
              {
                type: "source",
                position: Position.Right,
                id: `output`,
                style: {
                  background: "#e5e7eb",
                  border: "1px solid #D3D3D3",
                  width: "12px",
                  height: "12px",
                  right: "-6px",
                  zIndex: 5
                },
                isConnectable
              }
            )
          }
        )
      ] })
    ] }) })
  ] });
};
const CustomInputNode$1 = memo$i(CustomInputNode);

const API_CONFIG = {
  BASE_URL: "https://api-dev-qoca-apa.qrilab.com/v1",
  CREATE_WEBHOOK_URL: "https://lightly-mature-lemming.ngrok-free.app/v1/external_service/webhook"
};

/**
 * 工作流相關服務共用的基礎映射和轉換功能
 */
class WorkflowMappingService {
  /**
   * 從 ReactFlow 類型獲取 API 操作符
   * @param {string} type - ReactFlow 節點類型
   * @returns {string} - API 操作符類型
   */
  static getOperatorFromType(type) {
    const operatorMap = {
      browserExtensionInput: 'browser_extension_input',
      browserExtensionOutput: 'browser_extension_output',
      webhook: 'webhook',
      customInput: 'basic_input',
      input: 'basic_input',
      aiCustomInput: 'ask_ai',
      ai: 'ask_ai',
      ifElse: 'ifElse',
      knowledgeRetrieval: 'knowledge_retrieval',
      knowledge_retrieval: 'knowledge_retrieval',
      httpRequest: 'http_request',
      timer: 'timer',
      line: 'line_webhook_input',
      event: 'event',
      end: 'end',
      message: 'line_send_message',
      extract_data: 'extract_data',
      extractData: 'extract_data',
      aim_ml: 'aim_ml',
      schedule_trigger: 'schedule_trigger',
      webhook_input: 'webhook_input',
      webhook_output: 'webhook_output',
      combine_text: 'combine_text'
    };
    return operatorMap[type] || type;
  }

  /**
   * 從 API 操作符獲取 ReactFlow 類型
   * @param {string} operator - API 操作符類型
   * @returns {string} - ReactFlow 節點類型
   */
  static getTypeFromOperator(operator) {
    const typeMap = {
      browser_extension_input: 'browserExtensionInput',
      browser_extension_output: 'browserExtensionOutput',
      basic_input: 'customInput',
      ask_ai: 'aiCustomInput',
      ifElse: 'ifElse',
      knowledge_retrieval: 'knowledgeRetrieval',
      http_request: 'httpRequest',
      schedule_trigger: 'schedule_trigger',
      webhook_input: 'webhook_input',
      webhook_output: 'webhook_output',
      combine_text: 'combine_text',
      timer: 'timer',
      line: 'line_webhook_input',
      event: 'event',
      end: 'end',
      message: 'line_send_message',
      extract_data: 'extract_data',
      aim_ml: 'aim_ml'
    };
    return typeMap[operator] || operator;
  }

  /**
   * 從 ReactFlow 類型獲取 API 類別
   * @param {string} type - ReactFlow 節點類型
   * @returns {string} - API 節點類別
   */
  static getCategoryFromType(type) {
    const categoryMap = {
      browserExtensionInput: 'starter',
      browserExtInput: 'starter',
      webhook: 'starter',
      customInput: 'input',
      input: 'input',
      aiCustomInput: 'advanced',
      ai: 'advanced',
      knowledgeRetrieval: 'advanced',
      knowledge_retrieval: 'advanced',
      ifElse: 'logic',
      httpRequest: 'integration',
      timer: 'event',
      line: 'integration',
      event: 'event',
      end: 'output',
      browserExtensionOutput: 'output',
      extract_data: 'advanced',
      extractData: 'advanced',
      aim_ml: 'advanced',
      schedule_trigger: 'advanced',
      webhook_input: 'advanced',
      webhook_output: 'advanced',
      combine_text: 'advanced'
    };
    return categoryMap[type] || 'advanced';
  }

  /**
   * 根據節點數據生成標籤
   * @param {Object} node - 節點數據
   * @returns {string} - 節點標籤
   */
  static getNodeLabel(node) {
    switch (node.operator) {
      case 'browser_extension_input':
        return '瀏覽器擴充輸入';
      case 'browser_extension_output':
        return '瀏覽器擴充輸出';
      case 'ask_ai':
        return `AI (${node.parameters?.llm_id?.data || ''})`;
      case 'basic_input': {
        // 嘗試獲取第一個輸入欄位的名稱
        const inputName =
          node.parameters?.input_name_0?.data ||
          node.parameters?.input_name?.data;
        return inputName || '輸入';
      }
      case 'ifElse':
        return '條件判斷';
      case 'knowledge_retrieval':
        return '知識檢索';
      case 'end':
        return '結束';
      case 'webhook':
        return 'Webhook';
      case 'webhook_input':
        return 'Webhook Input';
      case 'webhook_output':
        return 'Webhook Output';
      case 'http_request':
        return 'HTTP Request';
      case 'timer':
        return '計時器';
      case 'line_webhook_input':
        return 'LINE Webhook';
      case 'line_send_message':
        return 'LINE Message';
      case 'event':
        return '事件處理';
      case 'extract_data':
        return '資料提取';
      case 'schedule_trigger':
        return '排程觸發';
      case 'aim_ml':
        return 'QOCA AIM';
      case 'combine_text':
        return '組合文字';
      default:
        return node.operator;
    }
  }

  /**
   * 修正 extractNodeInputForAPI 方法，增加 return_name 支持
   * 從 ReactFlow 邊緣數據中提取節點輸入連接
   * @param {string} nodeId - 目標節點ID
   * @param {Array} edges - 所有邊緣數據
   * @param {Array} allNodes - 所有節點數據
   * @returns {Object} - API 格式的節點輸入
   */
  static extractNodeInputForAPI(nodeId, edges, allNodes) {
    const nodeInput = {};
    console.log(`提取節點 ${nodeId} 的輸入連接`);

    // 獲取目標節點
    const targetNode = allNodes.find((n) => n.id === nodeId);
    if (!targetNode) {
      console.warn(`找不到節點 ${nodeId}`);
      return nodeInput;
    }

    // 檢查節點類型
    const isBrowserExtensionOutput =
      targetNode.type === 'browserExtensionOutput';
    const isWebookOutputNode = targetNode.type === 'webhook_output';
    const isQOCAAimNode = targetNode && targetNode.type === 'aim_ml';
    const isScheduleTriggerNode =
      targetNode && targetNode.type === 'schedule_trigger';
    const isCombineTextNode = targetNode && targetNode.type === 'combine_text';
    const isAINode =
      targetNode.type === 'aiCustomInput' || targetNode.type === 'ai';
    const isMessageNode = targetNode.type === 'line_send_message';
    const isExtractDataNode = targetNode.type === 'extract_data';

    // Schedule Trigger 節點沒有輸入連接，直接返回空對象
    if (isScheduleTriggerNode) {
      return nodeInput;
    }

    // 特殊處理 BrowserExtensionOutput 節點，確保所有 inputHandles 都被保留
    if (
      isBrowserExtensionOutput &&
      targetNode.data &&
      targetNode.data.inputHandles
    ) {
      console.log(`處理 BrowserExtensionOutput 節點的所有 input handles`);

      // 保存原始的 node_input 資訊
      const originalNodeInput = targetNode.data.node_input || {};

      // 保存原始的 handleLabels 狀態，用於映射 handle ID
      const handleLabels = {};

      // 首先檢查 node_input 中是否存在 return_name
      Object.entries(originalNodeInput).forEach(([key, value]) => {
        if (value && value.return_name) {
          // 使用 processHandleId 或等效邏輯轉換 handle ID
          const baseHandleId = key.split('_')[0];
          handleLabels[baseHandleId] = value.return_name;
          console.log(
            `從 node_input 讀取標籤: ${baseHandleId} => ${value.return_name}`
          );
        }
      });

      // 還原 input 到 output0 的映射 (處理第一個預設 handle 的情況)
      if (
        originalNodeInput.input &&
        originalNodeInput.input.return_name &&
        !handleLabels.output0
      ) {
        handleLabels.output0 = originalNodeInput.input.return_name;
        console.log(
          `特殊處理: 將 input.return_name (${originalNodeInput.input.return_name}) 映射到 output0`
        );
      }

      // 查找所有連線到此節點的邊
      const relevantEdges = edges.filter((edge) => edge.target === nodeId);

      // 按基本 handle 分組
      const handleGroups = {};
      relevantEdges.forEach((edge) => {
        // 確保有效的 targetHandle
        if (!edge.targetHandle) {
          console.warn(`邊緣 ${edge.id} 沒有有效的 targetHandle，跳過`);
          return;
        }

        const baseHandle = edge.targetHandle.split('_')[0];
        if (!handleGroups[baseHandle]) {
          handleGroups[baseHandle] = [];
        }
        handleGroups[baseHandle].push(edge);
      });

      // 遍歷所有基本 handle
      Object.keys(handleGroups).forEach((baseHandle) => {
        const groupEdges = handleGroups[baseHandle];

        if (groupEdges.length > 1) {
          // 多連線情況
          groupEdges.forEach((edge, index) => {
            const inputKey = `${baseHandle}_${index + 1}`;

            // 使用保存的標籤或原始的 return_name 或預設值
            let returnName = handleLabels[baseHandle] || '';

            console.log(`多連線 Handle ${inputKey} 使用標籤值: ${returnName}`);

            nodeInput[inputKey] = {
              node_id: edge.source,
              output_name: edge.sourceHandle || 'output',
              type: 'string',
              return_name: returnName
            };

            console.log(
              `多連線 Handle: ${edge.source} -> ${nodeId}:${inputKey} (return_name: ${returnName})`
            );
          });
        } else {
          // 單一連線情況
          const edge = groupEdges[0];

          // 使用保存的標籤或預設值
          let returnName = handleLabels[baseHandle] || '';

          console.log(
            `單一連線 Handle ${baseHandle} 使用標籤值: ${returnName}`
          );

          nodeInput[baseHandle] = {
            node_id: edge.source,
            output_name: edge.sourceHandle || 'output',
            type: 'string',
            return_name: returnName
          };
        }
      });

      const connectedHandles = Object.keys(handleGroups);
      targetNode.data.inputHandles
        .filter((handle) => !connectedHandles.includes(handle.id))
        .forEach((handle) => {
          const baseHandleId = handle.id;

          // 檢查這個 handle 是否確實存在於 inputHandles 中（避免處理已刪除的 handle）
          const isValidHandle = targetNode.data.inputHandles.some(
            (h) => h.id === baseHandleId
          );

          if (isValidHandle) {
            // 使用保存的標籤或空字串
            let returnName = handleLabels[baseHandleId] || '';

            console.log(
              `未連線但有效的 Handle ${baseHandleId} 使用標籤值: ${returnName}`
            );

            nodeInput[baseHandleId] = {
              node_id: '',
              output_name: '',
              type: 'string',
              data: '',
              is_empty: true,
              return_name: returnName
            };
          } else {
            console.log(
              `跳過無效的 handle: ${baseHandleId}（已從 inputHandles 中移除）`
            );
          }
        });

      const validHandleIds = targetNode.data.inputHandles.map((h) => h.id);
      const nodeInputKeys = Object.keys(nodeInput);

      // 移除不再有效的 nodeInput 項目
      nodeInputKeys.forEach((key) => {
        const baseKey = key.split('_')[0];
        if (
          !validHandleIds.includes(baseKey) &&
          !connectedHandles.includes(baseKey)
        ) {
          delete nodeInput[key];
        }
      });

      return nodeInput;
    }

    // 特殊處理 webhook_output 節點
    if (isWebookOutputNode && targetNode.data && targetNode.data.inputHandles) {
      // 保存原始的 node_input 資訊
      const originalNodeInput = targetNode.data.node_input || {};

      // 保存原始的 handleLabels 狀態，用於映射 handle ID
      const handleLabels = {};

      // 首先檢查 node_input 中是否存在 return_name
      Object.entries(originalNodeInput).forEach(([key, value]) => {
        if (value && value.return_name) {
          // 使用 processHandleId 或等效邏輯轉換 handle ID
          const baseHandleId = key.split('_')[0]; // 簡化版的 processHandleId
          handleLabels[baseHandleId] = value.return_name;
        }
      });

      // 還原 input 到 text0 的映射 (處理第一個預設 handle 的情況)
      if (
        originalNodeInput.input &&
        originalNodeInput.input.return_name &&
        !handleLabels.text0
      ) {
        handleLabels.text0 = originalNodeInput.input.return_name;
      }

      // 查找所有連線到此節點的邊
      const relevantEdges = edges.filter((edge) => edge.target === nodeId);

      // 按基本 handle 分組
      const handleGroups = {};
      relevantEdges.forEach((edge) => {
        // 確保有效的 targetHandle
        if (!edge.targetHandle) {
          console.warn(`邊緣 ${edge.id} 沒有有效的 targetHandle，跳過`);
          return;
        }

        const baseHandle = edge.targetHandle.split('_')[0];
        if (!handleGroups[baseHandle]) {
          handleGroups[baseHandle] = [];
        }
        handleGroups[baseHandle].push(edge);
      });

      // 遍歷所有基本 handle
      Object.keys(handleGroups).forEach((baseHandle) => {
        const groupEdges = handleGroups[baseHandle];

        if (groupEdges.length > 1) {
          // 多連線情況
          groupEdges.forEach((edge, index) => {
            const inputKey = `${baseHandle}_${index + 1}`;

            // 使用保存的標籤或原始的 return_name 或預設值
            let returnName = handleLabels[baseHandle] || '';

            nodeInput[inputKey] = {
              node_id: edge.source,
              output_name: edge.sourceHandle || 'output',
              type: 'string',
              return_name: returnName
            };
          });
        } else {
          // 單一連線情況
          const edge = groupEdges[0];

          // 使用保存的標籤或預設值
          let returnName = handleLabels[baseHandle] || '';

          nodeInput[baseHandle] = {
            node_id: edge.source,
            output_name: edge.sourceHandle || 'output',
            type: 'string',
            return_name: returnName
          };
        }
      });

      // 處理未連線的 handle
      targetNode.data.inputHandles
        .filter((handle) => !handleGroups[handle.id])
        .forEach((handle) => {
          const baseHandleId = handle.id;

          // 使用保存的標籤或空字串
          let returnName = handleLabels[baseHandleId] || '';

          console.log(
            `未連線 Handle ${baseHandleId} 使用標籤值: ${returnName}`
          );

          nodeInput[baseHandleId] = {
            node_id: '',
            output_name: '',
            type: 'string',
            data: '',
            is_empty: true,
            return_name: returnName
          };
        });

      return nodeInput;
    }

    // 獲取所有以該節點為目標的邊緣
    const relevantEdges = edges.filter((edge) => edge.target === nodeId);

    // 如果沒有連接，處理特殊情況
    if (relevantEdges.length === 0) {
      // 對於 AI 節點，仍需檢查是否有直接輸入的 promptText
      if (isAINode && targetNode.data?.promptText) {
        nodeInput.prompt = {
          type: 'string',
          data: targetNode.data.promptText,
          node_id: ''
        };
      }
      return nodeInput;
    }

    // AI 節點的特殊處理邏輯 ===
    if (isAINode) {
      // 分別收集 context 和 prompt 連線
      const contextEdges = [];
      const promptEdges = [];

      relevantEdges.forEach((edge) => {
        const targetHandle = edge.targetHandle || 'input';

        // 檢查是否為 context 相關的 handle
        if (
          targetHandle === 'context-input' ||
          targetHandle.startsWith('context-input_') ||
          targetHandle.startsWith('context')
        ) {
          contextEdges.push(edge);
        }
        // 檢查是否為 prompt 相關的 handle
        else if (
          targetHandle === 'prompt-input' ||
          targetHandle.startsWith('prompt-input_') ||
          targetHandle.startsWith('prompt')
        ) {
          promptEdges.push(edge);
        }
      });

      // 處理 context 連線 - 統一使用 context0, context1, context2 格式
      contextEdges.forEach((edge, index) => {
        const inputKey = `context${index}`;

        // 查找源節點以獲取 return_name
        const returnName = WorkflowMappingService.getReturnNameFromSourceNode(
          edge,
          allNodes
        );

        // 添加到 nodeInput
        nodeInput[inputKey] = {
          node_id: edge.source,
          output_name: edge.sourceHandle || 'output',
          type: 'string',
          return_name: returnName
        };
      });

      // 處理 prompt 連線 - 只使用 "prompt" 作為 key
      if (promptEdges.length > 0) {
        const edge = promptEdges[0]; // 只取第一個連接，因為 prompt 只能有一個
        const inputKey = 'prompt';

        // 查找源節點以獲取 return_name
        const returnName = WorkflowMappingService.getReturnNameFromSourceNode(
          edge,
          allNodes
        );

        nodeInput[inputKey] = {
          node_id: edge.source,
          output_name: edge.sourceHandle || 'output',
          type: 'string',
          return_name: returnName
        };
      }

      // 檢查是否有直接輸入的 promptText（當沒有 prompt 連線時）
      if (targetNode.data?.promptText && promptEdges.length === 0) {
        nodeInput.prompt = {
          type: 'string',
          data: targetNode.data.promptText,
          node_id: '' // 空 node_id 表示使用直接輸入的文本
        };
      }

      return nodeInput;
    }

    // Combine Text 節點的特殊處理邏輯
    if (isCombineTextNode && targetNode.data) {
      // 獲取原始的 node_input 資訊（如果存在）
      const originalNodeInput = targetNode.data.node_input || {};
      console.log('原始 node_input:', originalNodeInput);

      // 建立現有連線的映射，使用 node_id + output_name 作為唯一 key
      const existingConnections = new Map();
      Object.entries(originalNodeInput).forEach(([key, value]) => {
        if (key.startsWith('text') && value.node_id) {
          const connectionKey = `${value.node_id}:${
            value.output_name || 'output'
          }`;
          existingConnections.set(connectionKey, {
            key,
            value,
            index: parseInt(key.replace('text', '')) || 0
          });
        }
      });

      const sortedEdges = relevantEdges.sort((a, b) => {
        // 使用相同的 key 格式
        const aConnectionKey = `${a.source}:${a.sourceHandle || 'output'}`;
        const bConnectionKey = `${b.source}:${b.sourceHandle || 'output'}`;

        const aExisting = existingConnections.get(aConnectionKey);
        const bExisting = existingConnections.get(bConnectionKey);

        if (aExisting && bExisting) {
          // 兩個都是已存在的連線，按原有索引排序
          return aExisting.index - bExisting.index;
        } else if (aExisting) {
          // a 是已存在的連線，排在前面
          return -1;
        } else if (bExisting) {
          // b 是已存在的連線，排在前面
          return 1;
        } else {
          // 兩個都是新連線，按節點 ID 字母順序排序
          return a.source.localeCompare(b.source);
        }
      });

      // 追蹤已使用的索引
      const usedIndices = new Set();

      // 分配輸入鍵
      sortedEdges.forEach((edge) => {
        // 使用相同的 key 格式檢查現有連線
        const connectionKey = `${edge.source}:${edge.sourceHandle || 'output'}`;
        const existingConnection = existingConnections.get(connectionKey);
        let inputKey;

        if (existingConnection) {
          // 使用原有的鍵
          inputKey = existingConnection.key;
          usedIndices.add(existingConnection.index);
        } else {
          // 為新連線分配新的索引
          let newIndex = 0;
          while (usedIndices.has(newIndex)) {
            newIndex++;
          }
          inputKey = `text${newIndex}`;
          usedIndices.add(newIndex);
        }

        // 查找源節點以獲取 return_name
        const returnName = WorkflowMappingService.getReturnNameFromSourceNode(
          edge,
          allNodes
        );

        // 添加到 nodeInput
        nodeInput[inputKey] = {
          node_id: edge.source,
          output_name: edge.sourceHandle || 'output',
          type: 'string',
          return_name: returnName
        };
      });

      return nodeInput;
    }

    // 按 targetHandle 分組邊緣
    const handleGroups = {};

    // 首先，分組所有邊緣
    relevantEdges.forEach((edge) => {
      const targetHandle = edge.targetHandle || 'input';

      // 初始化組
      if (!handleGroups[targetHandle]) {
        handleGroups[targetHandle] = [];
      }

      // 添加邊緣到組
      handleGroups[targetHandle].push(edge);
    });

    // 處理每個句柄組 - 保持原始處理邏輯不變
    Object.entries(handleGroups).forEach(([targetHandle, targetEdges]) => {
      // 特殊處理 Message 節點的多個連接
      if (isMessageNode && targetHandle.startsWith('message')) {
        // 處理 Message 節點的多個連接，參考 AI 節點的 context 處理方式
        targetEdges.forEach((edge, index) => {
          // 對於多個連接到同一個 message handle，創建 message0, message1, message2 等輸入鍵
          const inputKey =
            targetEdges.length > 1 ? `message${index}` : 'message0';

          // 添加到 nodeInput
          nodeInput[inputKey] = {
            node_id: edge.source,
            output_name: edge.sourceHandle || 'output',
            type: 'string'
          };
        });
      } else if (isExtractDataNode && targetHandle === 'context-input') {
        // 處理 Extract Data 節點的輸入
        targetEdges.forEach((edge) => {
          const inputKey = 'context_to_extract_from';

          // 添加到 nodeInput
          nodeInput[inputKey] = {
            node_id: edge.source,
            output_name: edge.sourceHandle || 'output',
            type: 'string'
          };
        });
      } else if (isQOCAAimNode && targetHandle === 'input') {
        // 處理 QOCA AIM 節點的輸入
        targetEdges.forEach((edge) => {
          const inputKey = 'context';

          // 添加到 nodeInput，只儲存 node_id，不帶其他參數
          nodeInput[inputKey] = {
            node_id: edge.source,
            output_name: edge.sourceHandle || 'output',
            type: 'string'
          };
        });
      }
      // 其他節點類型的處理...
      else {
        // 處理多個連接到同一 handle 的情況
        if (targetEdges.length > 1) {
          targetEdges.forEach((edge, index) => {
            // 創建唯一的輸入鍵
            const inputKey = `${targetHandle}_${index + 1}`;

            // 添加到 nodeInput
            nodeInput[inputKey] = {
              node_id: edge.source,
              output_name: edge.sourceHandle || 'output',
              type: 'string'
            };

            console.log(
              `多重輸入連接: ${edge.source} -> ${nodeId}:${inputKey}`
            );
          });
        } else if (targetEdges.length === 1) {
          // 單一連接，直接使用原始句柄
          const edge = targetEdges[0];

          nodeInput[targetHandle] = {
            node_id: edge.source,
            output_name: edge.sourceHandle || 'output',
            type: 'string'
          };

          console.log(`輸入連接: ${edge.source} -> ${nodeId}:${targetHandle}`);
        }
      }
    });

    return nodeInput;
  }

  /**
   * 輔助函數：從源節點獲取 return_name
   * @param {Object} edge - 邊緣對象
   * @param {Array} allNodes - 所有節點數組
   * @returns {string} - return_name 值
   */
  static getReturnNameFromSourceNode(edge, allNodes) {
    const sourceNode = allNodes.find((n) => n.id === edge.source);
    let returnName = edge.label || '';

    if (sourceNode) {
      if (sourceNode.type === 'customInput' || sourceNode.type === 'input') {
        // 從自定義輸入節點獲取欄位名稱
        if (
          sourceNode.data &&
          sourceNode.data.fields &&
          Array.isArray(sourceNode.data.fields)
        ) {
          if (edge.sourceHandle === 'output' && sourceNode.data.fields[0]) {
            returnName = sourceNode.data.fields[0].inputName || returnName;
          } else if (
            edge.sourceHandle &&
            edge.sourceHandle.startsWith('output-')
          ) {
            const outputIndex = parseInt(edge.sourceHandle.split('-')[1] || 0);
            if (sourceNode.data.fields[outputIndex]) {
              returnName =
                sourceNode.data.fields[outputIndex].inputName || returnName;
            }
          }
        }
      } else if (sourceNode.type === 'browserExtensionInput') {
        // 從瀏覽器擴展輸入節點獲取項目名稱
        if (
          sourceNode.data &&
          sourceNode.data.items &&
          Array.isArray(sourceNode.data.items)
        ) {
          const targetItem = sourceNode.data.items.find(
            (item) => item.id === edge.sourceHandle
          );
          if (targetItem && targetItem.name) {
            returnName = targetItem.name;
          } else {
            const itemIndex = sourceNode.data.items.findIndex(
              (item) => item.id === edge.sourceHandle
            );
            if (itemIndex !== -1 && sourceNode.data.items[itemIndex]) {
              returnName = sourceNode.data.items[itemIndex].name || returnName;
            }
          }
        }
      } else if (
        sourceNode.type === 'aiCustomInput' ||
        sourceNode.type === 'ai'
      ) {
        returnName = 'output';
      } else if (sourceNode.type === 'knowledgeRetrieval') {
        returnName = 'output';
      } else {
        returnName = edge.sourceHandle || 'output';
      }
    }

    return returnName;
  }

  /**
   * 提取節點輸出以供 API 格式使用
   * @param {Object} node - ReactFlow 節點
   * @returns {Object} - API 格式的節點輸出
   */
  static extractNodeOutputForAPI(node) {
    const nodeOutput = {};
    console.log(`提取節點 ${node.id} 的輸出`);

    switch (node.type) {
      case 'router_switch': {
        // Router Switch 節點根據 routers 數組動態生成輸出
        const routers = node.data?.routers || [];

        routers.forEach((router) => {
          // 使用 router_id 作為 node_output 的 key
          nodeOutput[router.router_id] = {};
        });

        break;
      }
      // case 'httpRequest':
      // HTTP Request 節點輸出
      // nodeOutput.output = {
      //   response: {
      //     node_id: node.id,
      //     type: 'json'
      //   },
      //   status: {
      //     node_id: node.id,
      //     type: 'number'
      //   },
      //   headers: {
      //     node_id: node.id,
      //     type: 'json'
      //   }
      // };

      // break;
      case 'schedule_trigger':
        // Schedule Trigger 節點只有一個 trigger 輸出
        nodeOutput.trigger = {
          node_id: node.id,
          type: 'object'
        };
        break;
      case 'aim_ml': {
        // QOCA AIM 節點輸出 - 根據節點數據判斷
        const isExplainEnabled =
          node.data?.enableExplain ?? node.data?.enable_explain?.data ?? true; // 預設為 true

        if (isExplainEnabled) {
          // 當解釋功能開啟時，有 text 和 images 輸出
          nodeOutput.text = {
            node_id: node.id,
            type: 'string'
          };
          nodeOutput.images = {
            node_id: node.id,
            type: 'string'
          };
        } else {
          // 當解釋功能關閉時，只有text輸出
          nodeOutput.text = {
            node_id: node.id,
            type: 'string'
          };
        }
        break;
      }
      case 'line':
      case 'line_webhook_input':
        // Line Webhook 節點輸出多種訊息類型
        if (
          node.data.output_handles &&
          Array.isArray(node.data.output_handles)
        ) {
          node.data.output_handles.forEach((handleType) => {
            nodeOutput[handleType] = {
              node_id: node.id,
              type: 'string'
            };
          });
        } else {
          // 預設輸出類型
          ['text', 'image'].forEach((handleType) => {
            nodeOutput[handleType] = {
              node_id: node.id,
              type: 'string'
            };
          });
        }
        break;
      case 'webhook_output':
        // Add a single output for the browser extension output node
        nodeOutput.output = {
          node_id: node.id,
          type: 'string'
        };
        break;
      case 'combine_text':
        // Combine Text 節點的輸出
        nodeOutput.output = {
          node_id: node.id,
          type: 'string'
        };
        break;
      case 'browserExtensionOutput':
        // Add a single output for the browser extension output node
        nodeOutput.output = {
          node_id: node.id,
          type: 'string'
        };
        break;
      case 'browserExtensionInput':
      case 'browserExtInput':
        if (node.data.items && node.data.items.length > 0) {
          node.data.items.forEach((item, index) => {
            const outputKey = item.id || `a${index + 1}`;
            nodeOutput[outputKey] = {
              node_id: node.id,
              type: 'string'
            };
          });
          console.log(`瀏覽器擴展輸入: 設置 ${node.data.items.length} 個輸出`);
        } else {
          nodeOutput.output = {
            node_id: node.id,
            type: 'string'
          };
        }
        break;

      case 'webhook':
        nodeOutput.headers = {
          node_id: node.id,
          type: 'json',
          data: {}
        };
        nodeOutput.payload = {
          node_id: node.id,
          type: 'json',
          data: {}
        };
        break;

      case 'customInput':
      case 'input':
        // 修改: 使用單一 "output" 作為 handle ID 而不是 "output-0"
        nodeOutput.output = {
          node_id: node.id,
          type: 'string'
        };
        console.log(`輸入節點: 設置單一輸出 (output)`);
        break;

      case 'ifElse':
        nodeOutput.true = {
          node_id: node.id,
          type: 'boolean',
          data: true
        };
        nodeOutput.false = {
          node_id: node.id,
          type: 'boolean',
          data: false
        };
        break;
      case 'extract_data':
      case 'extractData':
        // Extract Data 節點的輸出
        nodeOutput.output = {
          node_id: node.id,
          type: 'json' // Extract Data 輸出為 JSON 格式
        };
        break;

      default:
        // 預設輸出
        nodeOutput.output = {
          node_id: node.id,
          type: 'string',
          data: {}
        };
    }

    return nodeOutput;
  }
}

// TokenService.js 簡化版

class TokenService {
  constructor() {
    this.token = null;
    this.storageType = 'local'; // 默認使用 localStorage
    this.initToken();
  }

  initToken() {
    try {
      const storedToken = localStorage.getItem('access_token');
      if (storedToken) {
        this.token = storedToken;
        console.log('已從 localStorage 載入 API Token');
      }
    } catch (error) {
      console.error('初始化 token 失敗:', error);
    }
  }

  setToken(token, storageType = 'local') {
    if (!token) return;

    this.token = token;
    this.storageType = storageType;
    console.log(`API Token 已更新 (儲存類型: ${storageType})`);

    try {
      const storage = storageType === 'session' ? sessionStorage : localStorage;
      storage.setItem('access_token', token);
    } catch (error) {
      console.error('保存 token 到 localStorage 失敗:', error);
    }
  }

  getToken() {
    return this.token;
  }

  setWorkspaceId(workspaceId) {
    if (!workspaceId) return;

    try {
      localStorage.setItem('selected_workspace_id', workspaceId);
      console.log(`已設置工作區 ID: ${workspaceId}`);
    } catch (error) {
      console.error('保存工作區 ID 失敗:', error);
    }
  }

  getWorkspaceId() {
    try {
      return localStorage.getItem('selected_workspace_id');
    } catch (error) {
      console.error('讀取工作區 ID 失敗:', error);
      return null;
    }
  }

  createAuthHeader(options = {}) {
    // 嘗試獲取 token
    if (!this.token) {
      // 優先檢查 sessionStorage
      this.token = sessionStorage.getItem('access_token');
      // 如果 sessionStorage 中沒有，檢查 localStorage
      if (!this.token) {
        this.token = localStorage.getItem('access_token');
      }
    }

    if (!this.token) {
      return options;
    }

    const headers = {
      ...(options.headers || {}),
      Authorization: `Bearer ${this.token}`
    };

    return {
      ...options,
      headers
    };
  }
  /**
   * 創建帶有 workspace_id 的完整 URL
   * @param {string} baseUrl - 基礎 URL
   * @param {Object} params - 額外的查詢參數
   * @returns {string} 完整的 URL
   */
  createUrlWithWorkspace(baseUrl, params = {}) {
    const workspaceId = this.getWorkspaceId();

    // 創建 URL 對象
    const url = new URL(baseUrl);

    // 如果有 workspace_id，加入到查詢參數
    if (workspaceId) {
      url.searchParams.append('workspace_id', workspaceId);
    }

    // 加入其他參數
    Object.entries(params).forEach(([key, value]) => {
      if (value !== null && value !== undefined) {
        url.searchParams.append(key, value);
      }
    });

    return url.toString();
  }
}

const tokenService = new TokenService();

/**
 * 更新後的工作流 API 服務，使用共用的映射功能
 */
class WorkflowAPIService {
  constructor() {}

  /**
   * 載入工作流數據
   * @param {string} workflowId - 要載入的工作流 ID
   * @returns {Promise<Object>} 工作流數據
   */
  async loadWorkflow(workflowId) {
    try {
      console.log(`嘗試載入工作流 ID: ${workflowId}`);
      // 使用 tokenService 創建帶有 Authorization 的請求配置
      const options = tokenService.createAuthHeader({
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          flow_id: workflowId
        })
      });

      const url = tokenService.createUrlWithWorkspace(
        `${API_CONFIG.BASE_URL}/agent_designer/workflows/load`
      );
      const response = await fetch(url, options);

      if (!response.ok) {
        throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
      }

      const data = await response.json();
      console.log('成功載入工作流數據');
      return data;
    } catch (error) {
      console.error('載入工作流失敗:', error);
      throw error;
    }
  }

  /**
   * 建立工作流數據
   * @param {Object} data - 要保存的工作流數據
   * @returns {Promise<Object>} API 回應
   */
  async createWorkflow(data) {
    console.log('創建新工作流:', data);
    try {
      const options = tokenService.createAuthHeader({
        method: 'POST',
        headers: {
          accept: 'application/json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          flow_name: data.flow_name,
          content: data.content,
          flow_pipeline: data.flow_pipeline
        })
      });

      const url = tokenService.createUrlWithWorkspace(
        `${API_CONFIG.BASE_URL}/agent_designer/workflows/`
      );

      const response = await fetch(url, options);

      if (!response.ok) {
        throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
      }

      const responseData = await response.json();
      console.log('工作流創建成功');
      return responseData;
    } catch (error) {
      console.error('保存工作流失敗:', error);
      throw error;
    }
  }

  /**
   * 保存工作流數據
   * @param {Object} data - 要保存的工作流數據
   * @returns {Promise<Object>} API 回應
   */
  async updateWorkflow(data) {
    console.log('更新工作流:', data);
    try {
      const options = tokenService.createAuthHeader({
        method: 'PUT',
        headers: {
          accept: 'application/json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          flow_name: data.flow_name,
          content: data.content,
          flow_id: data.flow_id,
          flow_pipeline: data.flow_pipeline
        })
      });

      const url = tokenService.createUrlWithWorkspace(
        `${API_CONFIG.BASE_URL}/agent_designer/workflows/`
      );
      const response = await fetch(url, options);

      if (!response.ok) {
        throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
      }

      const responseData = await response.json();
      console.log('工作流更新成功');
      return responseData;
    } catch (error) {
      console.error('保存工作流失敗:', error);
      throw error;
    }
  }
}

/**
 * LLM模型和知識檢索服務 - 處理與LLM模型和文件相關的API請求
 */
class LLMService {
  constructor() {
    // 模型相關緩存
    this.modelsCache = null;
    this.lastFetchTime = null;
    this.cacheExpiryTime = 10 * 60 * 1000; // 10分鐘cache過期
    this.pendingRequest = null; // 用於追蹤進行中的請求

    // 知識庫相關緩存
    this.knowledgeBasesCache = null;
    this.lastKnowledgeBasesFetchTime = null;
    this.pendingKnowledgeBasesRequest = null; // 用於追蹤進行中的知識庫請求

    // 新增：結構化輸出模型相關緩存
    this.structuredOutputModelsCache = null;
    this.lastStructuredOutputFetchTime = null;
    this.pendingStructuredOutputRequest = null; // 用於追蹤進行中的結構化輸出請求
  }

  /**
   * 獲取所有可用的LLM模型
   * @returns {Promise<Array>} 模型列表
   */
  async getModels() {
    try {
      // 檢查是否有有效的快取
      const now = Date.now();
      if (
        this.modelsCache &&
        this.lastFetchTime &&
        now - this.lastFetchTime < this.cacheExpiryTime
      ) {
        return this.modelsCache;
      }

      // 如果已經有一個請求在進行中，則返回該請求
      if (this.pendingRequest) {
        return this.pendingRequest;
      }

      // 創建新請求

      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });
      const url = tokenService.createUrlWithWorkspace(
        `${API_CONFIG.BASE_URL}/agent_designer/llm/`
      );
      this.pendingRequest = fetch(url, options)
        .then((response) => {
          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }
          return response.json();
        })
        .then((data) => {
          // 檢查數據是否為數組
          if (!Array.isArray(data)) {
            console.warn('API返回的模型數據不是陣列');
            // 嘗試從可能的非數組格式中提取數據
            if (
              data &&
              typeof data === 'object' &&
              data.models &&
              Array.isArray(data.models)
            ) {
              data = data.models;
            } else {
              // 如果無法提取合理的數據，則返回預設模型
              console.warn('無法從API回應中提取合理的模型數據，使用預設模型');
              data = [
                {
                  id: 1,
                  name: 'O3-mini',
                  display_name: 'O3-mini',
                  is_default: true
                },
                { id: 2, name: 'O3-plus', display_name: 'O3-plus' },
                { id: 3, name: 'O3-mega', display_name: 'O3-mega' },
                { id: 4, name: 'O3-ultra', display_name: 'O3-ultra' }
              ];
            }
          }

          // 檢查每個模型對象，確保結構正確
          const processedData = data.map((model, index) => {
            if (!model || typeof model !== 'object') {
              console.warn(`模型 ${index} 無效，使用替代數據`);
              return {
                id: index + 1,
                name: `Model ${index + 1}`,
                display_name: `Model ${index + 1}`,
                is_default: index === 0
              };
            }

            // 確保模型有ID
            if (model.id === undefined || model.id === null) {
              console.warn(`模型 ${index} 缺少ID，使用索引作為ID`);
              model.id = index + 1;
            }

            // 確保模型有名稱
            if (!model.name && !model.display_name) {
              console.warn(`模型 ${index} 缺少名稱，使用索引作為名稱`);
              model.name = `Model ${model.id}`;
            }

            return model;
          });

          // 更新快取
          this.modelsCache = processedData;
          this.lastFetchTime = now;
          this.pendingRequest = null; // 清除進行中的請求

          return processedData;
        })
        .catch((error) => {
          console.error('獲取LLM模型失敗:', error);
          this.pendingRequest = null; // 清除進行中的請求，即使出錯

          // 返回預設模型，而不是拋出錯誤
          return [
            {
              id: 1,
              name: 'O3-mini',
              display_name: 'O3-mini',
              is_default: true
            },
            { id: 2, name: 'O3-plus', display_name: 'O3-plus' },
            { id: 3, name: 'O3-mega', display_name: 'O3-mega' },
            { id: 4, name: 'O3-ultra', display_name: 'O3-ultra' }
          ];
        });

      return this.pendingRequest;
    } catch (error) {
      console.error('獲取LLM模型過程中出錯:', error);
      this.pendingRequest = null;

      // 返回預設模型，而不是拋出錯誤
      return [
        { id: 1, name: 'O3-mini', display_name: 'O3-mini', is_default: true },
        { id: 2, name: 'O3-plus', display_name: 'O3-plus' },
        { id: 3, name: 'O3-mega', display_name: 'O3-mega' },
        { id: 4, name: 'O3-ultra', display_name: 'O3-ultra' }
      ];
    }
  }

  /**
   * 新增：獲取支援結構化輸出的LLM模型
   * @returns {Promise<Array>} 結構化輸出模型列表
   */
  async getStructuredOutputModels() {
    try {
      // 檢查是否有有效的快取
      const now = Date.now();
      if (
        this.structuredOutputModelsCache &&
        this.lastStructuredOutputFetchTime &&
        now - this.lastStructuredOutputFetchTime < this.cacheExpiryTime
      ) {
        return this.structuredOutputModelsCache;
      }

      // 如果已經有一個請求在進行中，則返回該請求
      if (this.pendingStructuredOutputRequest) {
        return this.pendingStructuredOutputRequest;
      }

      // 創建新請求
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });
      const url = tokenService.createUrlWithWorkspace(
        `${API_CONFIG.BASE_URL}/agent_designer/llm/structured-output`
      );
      this.pendingStructuredOutputRequest = fetch(url, options)
        .then((response) => {
          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }
          return response.json();
        })
        .then((data) => {
          console.log('API返回原始結構化輸出模型數據:', data);

          // 檢查數據是否為數組
          if (!Array.isArray(data)) {
            console.warn('API返回的結構化輸出模型數據不是陣列');
            // 返回預設模型
            data = [
              {
                id: 0,
                display_name: 'GPT-4o',
                description: 'OpenAI GPT-4o 支援結構化輸出',
                provider: 'AZURE_OPENAI'
              }
            ];
          }

          // 檢查每個模型對象，確保結構正確
          const processedData = data.map((model, index) => {
            if (!model || typeof model !== 'object') {
              console.warn(`結構化輸出模型 ${index} 無效，使用替代數據`);
              return {
                id: index,
                display_name: `Structured Model ${index}`,
                description: `結構化輸出模型 ${index}`,
                provider: 'AZURE_OPENAI'
              };
            }

            // 確保模型有ID
            if (model.id === undefined || model.id === null) {
              console.warn(`結構化輸出模型 ${index} 缺少ID，使用索引作為ID`);
              model.id = index;
            }

            // 確保模型有顯示名稱
            if (!model.display_name) {
              console.warn(
                `結構化輸出模型 ${index} 缺少顯示名稱，使用預設名稱`
              );
              model.display_name = `Structured Model ${model.id}`;
            }

            return model;
          });

          // 更新快取
          this.structuredOutputModelsCache = processedData;
          this.lastStructuredOutputFetchTime = now;
          this.pendingStructuredOutputRequest = null; // 清除進行中的請求

          return processedData;
        })
        .catch((error) => {
          console.error('獲取結構化輸出模型失敗:', error);
          this.pendingStructuredOutputRequest = null; // 清除進行中的請求，即使出錯

          // 返回預設模型，而不是拋出錯誤
          return [
            {
              id: 0,
              display_name: 'GPT-4o',
              description: 'OpenAI GPT-4o 支援結構化輸出',
              provider: 'AZURE_OPENAI'
            }
          ];
        });

      return this.pendingStructuredOutputRequest;
    } catch (error) {
      console.error('獲取結構化輸出模型過程中出錯:', error);
      this.pendingStructuredOutputRequest = null;

      // 返回預設模型，而不是拋出錯誤
      return [
        {
          id: 0,
          display_name: 'GPT-4o',
          description: 'OpenAI GPT-4o 支援結構化輸出',
          provider: 'AZURE_OPENAI'
        }
      ];
    }
  }

  /**
   * 獲取所有知識庫列表
   * @returns {Promise<Array>} 知識庫列表
   */
  async getKnowledgeBases() {
    try {
      // 檢查是否有有效的快取
      const now = Date.now();
      if (
        this.knowledgeBasesCache &&
        this.lastKnowledgeBasesFetchTime &&
        now - this.lastKnowledgeBasesFetchTime < this.cacheExpiryTime
      ) {
        return this.knowledgeBasesCache;
      }

      // 如果已經有一個請求在進行中，則返回該請求
      if (this.pendingKnowledgeBasesRequest) {
        return this.pendingKnowledgeBasesRequest;
      }

      // 創建新請求
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });
      // 獲取 workspace_id 並替換路徑參數
      const workspaceId = tokenService.getWorkspaceId();
      if (!workspaceId) {
        throw new Error('未設置工作區 ID');
      }
      const url = `${API_CONFIG.BASE_URL}/agent_designer/knowledge-bases/workspace/${workspaceId}/list`;
      this.pendingKnowledgeBasesRequest = fetch(url, options)
        .then((response) => {
          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }
          return response.json();
        })
        .then((responseData) => {
          // 檢查新的 response 格式
          let knowledgeBases = [];

          if (responseData && responseData.data) {
            knowledgeBases = responseData.data.knowledge_bases || [];
          } else {
            console.warn(
              'API回應格式不符合預期，檢查是否有 knowledge_bases 陣列'
            );
            // 嘗試直接使用 responseData 如果它是陣列
            if (Array.isArray(responseData)) {
              knowledgeBases = responseData;
            }
          }

          // 如果沒有找到有效數據，返回預設知識庫
          if (!Array.isArray(knowledgeBases) || knowledgeBases.length === 0) {
            console.warn('無法從API回應中提取合理的知識庫數據，使用預設知識庫');
            knowledgeBases = [];
          }

          // 檢查每個知識庫對象，確保結構正確
          const processedData = knowledgeBases.map((kb, index) => {
            if (!kb || typeof kb !== 'object') {
              console.warn(`知識庫 ${index} 無效，使用替代數據`);
              return {
                id: index + 1,
                name: `知識庫 ${index + 1}`,
                description: `知識庫 ${index + 1} 的描述`,
                file_count: 0,
                updated_at: new Date().toISOString()
              };
            }

            // 確保知識庫有ID
            if (kb.id === undefined || kb.id === null) {
              console.warn(`知識庫 ${index} 缺少ID，使用索引作為ID`);
              kb.id = index + 1;
            }

            // 確保知識庫有名稱
            if (!kb.name) {
              console.warn(`知識庫 ${index} 缺少名稱，使用預設名稱`);
              kb.name = `知識庫 ${kb.id}`;
            }

            // 確保有描述
            if (!kb.description) {
              kb.description = `${kb.name} 的描述`;
            }

            // 確保有檔案數量
            if (kb.file_count === undefined || kb.file_count === null) {
              kb.file_count = 0;
            }

            // 確保有更新時間
            if (!kb.updated_at) {
              kb.updated_at = new Date().toISOString();
            }

            return kb;
          });

          // 更新快取
          this.knowledgeBasesCache = processedData;
          this.lastKnowledgeBasesFetchTime = now;
          this.pendingKnowledgeBasesRequest = null; // 清除進行中的請求

          return processedData;
        })
        .catch((error) => {
          console.error('獲取知識庫失敗:', error);
          this.pendingKnowledgeBasesRequest = null; // 清除進行中的請求，即使出錯

          // 檢查是否為 CORS 錯誤
          if (
            error.message &&
            (error.message.includes('NetworkError') ||
              error.message.includes('Failed to fetch'))
          ) {
            return [
              {
                id: 1,
                name: '產品文檔知識庫',
                description: '存放所有產品相關文檔和規格',
                file_count: 3,
                updated_at: new Date().toISOString()
              }
            ];
          }

          throw error;
        });

      return this.pendingKnowledgeBasesRequest;
    } catch (error) {
      console.error('獲取知識庫過程中出錯:', error);
      this.pendingKnowledgeBasesRequest = null;
      throw error;
    }
  }

  /**
   * 向後相容方法 - 保持原有的 getCompletedFiles 方法名
   * @returns {Promise<Array>} 知識庫列表（原文件列表）
   */
  async getCompletedFiles() {
    return this.getKnowledgeBases();
  }

  /**
   * 獲取格式化後的模型選項，適用於下拉選單
   * @returns {Promise<Array>} 格式化的模型選項
   */
  async getModelOptions() {
    try {
      const models = await this.getModels();

      // 檢查模型數據是否有效
      if (!models || !Array.isArray(models)) {
        console.warn('模型數據無效或不是陣列，使用默認選項');
        return [
          { value: '1', label: 'O3-mini' },
          { value: '2', label: 'O3-plus' },
          { value: '3', label: 'O3-mega' },
          { value: '4', label: 'O3-ultra' }
        ];
      }

      if (models.length === 0) {
        console.warn('API返回的模型陣列為空，使用默認選項');
        return [
          { value: '1', label: 'O3-mini' },
          { value: '2', label: 'O3-plus' },
          { value: '3', label: 'O3-mega' },
          { value: '4', label: 'O3-ultra' }
        ];
      }

      // 將API返回的模型數據轉換為select選項格式
      const options = models.map((model, index) => {
        // 確保模型對象存在
        if (!model) {
          console.warn(`遇到無效的模型數據，索引: ${index}`);
          return { value: `${index + 1}`, label: `Model ${index + 1}` };
        }

        // 取得 ID，確保是字串型別
        let modelId = '1'; // 預設 ID
        if (model.id !== undefined && model.id !== null) {
          modelId = model.id.toString();
        } else {
          modelId = `${index + 1}`; // 使用索引+1作為ID
        }

        // 取得顯示名稱
        const modelLabel = model.display_name || model.name;

        // 如果連名稱也沒有，則使用模型ID作為顯示名稱
        const displayLabel = modelLabel || `Model ${modelId}`;

        return {
          value: modelId,
          label: displayLabel,
          description: model.description || '',
          isDefault: !!model.is_default
        };
      });

      return options;
    } catch (error) {
      console.error('獲取模型選項失敗:', error);
      // 返回一些默認選項，以防API失敗
      return [
        { value: '1', label: 'O3-mini' },
        { value: '2', label: 'O3-plus' },
        { value: '3', label: 'O3-mega' },
        { value: '4', label: 'O3-ultra' }
      ];
    }
  }

  /**
   * 新增：獲取格式化後的結構化輸出模型選項，適用於下拉選單
   * @returns {Promise<Array>} 格式化的結構化輸出模型選項
   */
  async getStructuredOutputModelOptions() {
    try {
      const models = await this.getStructuredOutputModels();

      // 檢查模型數據是否有效
      if (!models || !Array.isArray(models)) {
        console.warn('結構化輸出模型數據無效或不是陣列，使用默認選項');
        return [
          {
            value: '0',
            label: 'GPT-4o',
            description: 'OpenAI GPT-4o 支援結構化輸出',
            provider: 'AZURE_OPENAI'
          }
        ];
      }

      if (models.length === 0) {
        console.warn('API返回的結構化輸出模型陣列為空，使用默認選項');
        return [
          {
            value: '0',
            label: 'GPT-4o',
            description: 'OpenAI GPT-4o 支援結構化輸出',
            provider: 'AZURE_OPENAI'
          }
        ];
      }

      // 將API返回的結構化輸出模型數據轉換為select選項格式
      const options = models.map((model, index) => {
        // 確保模型對象存在
        if (!model) {
          console.warn(`遇到無效的結構化輸出模型數據，索引: ${index}`);
          return {
            value: `${index}`,
            label: `Structured Model ${index}`,
            description: '',
            provider: 'AZURE_OPENAI'
          };
        }

        // 取得 ID，確保是字串型別
        let modelId = '0'; // 預設 ID
        if (model.id !== undefined && model.id !== null) {
          modelId = model.id.toString();
        } else {
          modelId = `${index}`; // 使用索引作為ID
        }

        // 取得顯示名稱
        const displayLabel =
          model.display_name || `Structured Model ${modelId}`;

        return {
          value: modelId,
          label: displayLabel,
          description: model.description || '',
          provider: model.provider || 'AZURE_OPENAI'
        };
      });

      return options;
    } catch (error) {
      console.error('獲取結構化輸出模型選項失敗:', error);
      // 返回一些默認選項，以防API失敗
      return [
        {
          value: '0',
          label: 'GPT-4o',
          description: 'OpenAI GPT-4o 支援結構化輸出',
          provider: 'AZURE_OPENAI'
        }
      ];
    }
  }

  /**
   * 獲取格式化後的知識庫選項，適用於下拉選單
   * @returns {Promise<Array>} 格式化的知識庫選項
   */
  async getKnowledgeBaseOptions() {
    try {
      const knowledgeBases = await this.getKnowledgeBases();

      // 根據新的知識庫格式進行處理
      return knowledgeBases.map((kb) => ({
        id: kb.id.toString(), // 確保ID是字符串
        value: kb.id.toString(), // 用於選項值
        name: kb.name, // 用於顯示名稱
        label: kb.name, // 用於顯示名稱 (替代)
        description: kb.description, // 知識庫描述
        fileCount: kb.file_count, // 檔案數量
        updatedAt: kb.updated_at // 更新時間
      }));
    } catch (error) {
      console.error('獲取知識庫選項失敗:', error);
      // 返回一些默認選項，以防API失敗
      return [
        {
          id: '1',
          value: '1',
          name: '產品文檔知識庫',
          label: '產品文檔知識庫',
          description: '存放所有產品相關文檔和規格',
          fileCount: 3,
          updatedAt: new Date().toISOString()
        }
      ];
    }
  }

  /**
   * 向後相容方法 - 保持原有的 getFileOptions 方法名
   * @returns {Promise<Array>} 格式化的知識庫選項（原文件選項）
   */
  async getFileOptions() {
    return this.getKnowledgeBaseOptions();
  }

  /**
   * 預加載模型與知識庫數據，通常在應用啟動時呼叫
   */
  preloadData() {
    console.log('預加載LLM模型、結構化輸出模型和知識庫列表');

    // 預加載模型
    this.getModels().catch((err) => {
      console.log('預加載模型失敗:', err);
    });

    // 預加載結構化輸出模型
    this.getStructuredOutputModels().catch((err) => {
      console.log('預加載結構化輸出模型失敗:', err);
    });

    // 預加載知識庫
    this.getKnowledgeBases().catch((err) => {
      console.log('預加載知識庫失敗:', err);
    });
  }
}

/**
 * 外部服務配置管理 - 處理與外部服務（LINE、WHATSAPP等）相關的API請求
 */
class ExternalService {
  constructor() {
    // 服務配置相關緩存
    this.servicesCache = new Map(); // 使用Map來儲存不同service_type的緩存
    this.lastFetchTimes = new Map(); // 記錄每個service_type的最後獲取時間
    this.cacheExpiryTime = 10 * 60 * 1000; // 10分鐘cache過期
    this.pendingRequests = new Map(); // 用於追蹤進行中的請求
    // Messaging types 相關緩存
    this.messagingTypesCache = new Map(); // 緩存不同頻道的 messaging types
    this.lastMessagingTypesFetchTimes = new Map(); // 記錄每個頻道的最後獲取時間
    this.pendingMessagingTypesRequests = new Map(); // 用於追蹤進行中的請求
    // 支援的服務類型
    this.supportedServiceTypes = ['LINE', 'WHATSAPP'];
    // 支援的頻道類型 (用於 messaging types)
    this.supportedChannelTypes = ['line'];
  }

  /**
   * 創建新的Webhook
   * @param {string} flowId - 工作流ID
   */
  createWebhook(flowId) {
    try {
      console.log(`創建新的Webhook，工作流ID: ${flowId}`);
      // const options = tokenService.createAuthHeader({
      //   method: 'POST',
      //   headers: {
      //     'Content-Type': 'application/json',
      //     Accept: 'application/json'
      //   }
      // });
      // url is API_CONFIG.CREATE_WEBHOOK_URL, need to append flowId
      const url = `${API_CONFIG.CREATE_WEBHOOK_URL}/${flowId}`;
      // use promise to reply url
      return url;
    } catch (error) {
      console.error('創建Webhook失敗:', error);
      throw error;
    }
  }

  /**
   * 獲取指定頻道的 Messaging Types
   * @param {string} channelType - 頻道類型 (line, telegram等)
   * @returns {Promise<Array>} Messaging types 列表
   */
  async getMessagingTypes(channelType = 'line') {
    try {
      // 驗證頻道類型
      if (!channelType || typeof channelType !== 'string') {
        throw new Error('頻道類型不能為空且必須是字符串');
      }
      const lowerChannelType = channelType.toLowerCase();

      // 檢查是否有有效的快取
      const now = Date.now();
      const cacheKey = lowerChannelType;
      if (
        this.messagingTypesCache.has(cacheKey) &&
        this.lastMessagingTypesFetchTimes.has(cacheKey) &&
        now - this.lastMessagingTypesFetchTimes.get(cacheKey) <
          this.cacheExpiryTime
      ) {
        console.log(`使用快取的${lowerChannelType} Messaging Types列表`);
        return this.messagingTypesCache.get(cacheKey);
      }

      // 如果已經有一個請求在進行中，則返回該請求
      if (this.pendingMessagingTypesRequests.has(cacheKey)) {
        console.log(
          `已有進行中的${lowerChannelType} Messaging Types請求，使用相同請求`
        );
        return this.pendingMessagingTypesRequests.get(cacheKey);
      }

      // 創建新請求
      console.log(`獲取${lowerChannelType} Messaging Types列表...`);
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      const url = tokenService.createUrlWithWorkspace(
        `${API_CONFIG.BASE_URL}/agent_designer/channel/${lowerChannelType}/messaging_types`
      );

      const request = fetch(url, options)
        .then((response) => {
          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }
          return response.json();
        })
        .then((data) => {
          console.log(
            `API返回原始${lowerChannelType} Messaging Types數據:`,
            data
          );

          // 檢查數據是否為數組
          if (!Array.isArray(data)) {
            console.warn(
              `API返回的${lowerChannelType} Messaging Types數據不是陣列`
            );
            // 嘗試從可能的非數組格式中提取數據
            if (
              data &&
              typeof data === 'object' &&
              data.messaging_types &&
              Array.isArray(data.messaging_types)
            ) {
              data = data.messaging_types;
              console.log(`從API回應中提取messaging_types陣列:`, data);
            } else {
              // 如果無法提取合理的數據，則返回預設的 messaging types
              console.warn(
                `無法從API回應中提取合理的${lowerChannelType} Messaging Types數據，返回預設值`
              );
              data = ['Reply Message', 'Push Message'];
            }
          }

          // 處理數據，確保都是字符串
          const processedData = data
            .filter((type) => type && typeof type === 'string')
            .map((type) => type.trim());

          console.log(
            `處理後的${lowerChannelType} Messaging Types數據:`,
            processedData
          );

          // 更新快取
          this.messagingTypesCache.set(cacheKey, processedData);
          this.lastMessagingTypesFetchTimes.set(cacheKey, now);
          this.pendingMessagingTypesRequests.delete(cacheKey); // 清除進行中的請求
          return processedData;
        })
        .catch((error) => {
          console.error(`獲取${lowerChannelType} Messaging Types失敗:`, error);
          this.pendingMessagingTypesRequests.delete(cacheKey); // 清除進行中的請求，即使出錯

          // 檢查是否為 CORS 錯誤或網路錯誤
          if (
            error.message &&
            (error.message.includes('NetworkError') ||
              error.message.includes('Failed to fetch') ||
              error.message.includes('CORS'))
          ) {
            console.log(
              `疑似 CORS 或網路問題，返回預設的${lowerChannelType} Messaging Types列表`
            );
            return ['Reply Message', 'Push Message'];
          }
          // 返回預設值，而不是拋出錯誤
          return ['Reply Message', 'Push Message'];
        });

      this.pendingMessagingTypesRequests.set(cacheKey, request);
      return request;
    } catch (error) {
      console.error(`獲取${channelType} Messaging Types過程中出錯:`, error);
      const cacheKey = channelType.toLowerCase();
      this.pendingMessagingTypesRequests.delete(cacheKey);
      // 返回預設值，而不是拋出錯誤
      return ['Reply Message', 'Push Message'];
    }
  }

  /**
   * 獲取格式化後的 Messaging Types 選項，適用於下拉選單
   * @param {string} channelType - 頻道類型
   * @returns {Promise<Array>} 格式化的 messaging types 選項
   */
  async getMessagingTypeOptions(channelType = 'line') {
    try {
      const messagingTypes = await this.getMessagingTypes(channelType);
      console.log(`${channelType} Messaging Types數據:`, messagingTypes);

      // 檢查 messaging types 數據是否有效
      if (!messagingTypes || !Array.isArray(messagingTypes)) {
        console.warn(
          `${channelType} Messaging Types數據無效或不是陣列，返回預設選項`
        );
        return [
          { value: 'Reply Message', label: 'Reply Message' },
          { value: 'Push Message', label: 'Push Message' }
        ];
      }

      if (messagingTypes.length === 0) {
        console.warn(`API返回的${channelType} Messaging Types陣列為空`);
        return [
          { value: 'Reply Message', label: 'Reply Message' },
          { value: 'Push Message', label: 'Push Message' }
        ];
      }

      // 將 messaging types 轉換為 select 選項格式
      const options = messagingTypes
        .map((type, index) => {
          // 確保 messaging type 存在且為字符串
          if (!type || typeof type !== 'string') {
            console.warn(
              `遇到無效的${channelType} Messaging Type數據，索引: ${index}`
            );
            return null;
          }

          const cleanType = type.trim();
          return {
            value: cleanType,
            label: cleanType
          };
        })
        .filter((option) => option !== null); // 過濾掉無效的選項

      console.log(`最終格式化的${channelType} Messaging Types選項:`, options);
      return options;
    } catch (error) {
      console.error(`獲取${channelType} Messaging Types選項失敗:`, error);
      // 返回預設選項，以防API失敗
      return [
        { value: 'Reply Message', label: 'Reply Message' },
        { value: 'Push Message', label: 'Push Message' }
      ];
    }
  }

  /**
   * 獲取指定類型的外部服務配置
   * @param {string} serviceType - 服務類型 (LINE, WHATSAPP等)
   * @returns {Promise<Array>} 服務配置列表
   */
  async getExternalServiceConfigs(serviceType) {
    try {
      // 驗證服務類型
      if (!serviceType || typeof serviceType !== 'string') {
        throw new Error('服務類型不能為空且必須是字符串');
      }
      const upperServiceType = serviceType.toUpperCase();
      // 檢查是否有有效的快取
      const now = Date.now();
      const cacheKey = upperServiceType;
      if (
        this.servicesCache.has(cacheKey) &&
        this.lastFetchTimes.has(cacheKey) &&
        now - this.lastFetchTimes.get(cacheKey) < this.cacheExpiryTime
      ) {
        console.log(`使用快取的${upperServiceType}服務配置列表`);
        return this.servicesCache.get(cacheKey);
      }
      // 如果已經有一個請求在進行中，則返回該請求
      if (this.pendingRequests.has(cacheKey)) {
        console.log(
          `已有進行中的${upperServiceType}服務配置請求，使用相同請求`
        );
        return this.pendingRequests.get(cacheKey);
      }
      // 創建新請求
      console.log(`獲取${upperServiceType}服務配置列表...`);
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      const url = tokenService.createUrlWithWorkspace(
        `${API_CONFIG.BASE_URL}/agent_designer/external_service_configs/${upperServiceType}`
      );
      const request = fetch(url, options)
        .then((response) => {
          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }
          return response.json();
        })
        .then((data) => {
          console.log(`API返回原始${upperServiceType}服務配置數據:`, data);
          // 檢查數據是否為數組
          if (!Array.isArray(data)) {
            console.warn(`API返回的${upperServiceType}服務配置數據不是陣列`);
            // 嘗試從可能的非數組格式中提取數據
            if (
              data &&
              typeof data === 'object' &&
              data.configs &&
              Array.isArray(data.configs)
            ) {
              data = data.configs;
              console.log(`從API回應中提取configs陣列:`, data);
            } else {
              // 如果無法提取合理的數據，則返回空陣列
              console.warn(
                `無法從API回應中提取合理的${upperServiceType}服務配置數據，返回空陣列`
              );
              data = [];
            }
          }
          // 檢查每個服務配置對象，確保結構正確
          const processedData = data
            .map((config, index) => {
              if (!config || typeof config !== 'object') {
                console.warn(
                  `${upperServiceType}服務配置 ${index} 無效，跳過該項目`
                );
                return null;
              }
              // 確保服務配置有ID
              if (config.id === undefined || config.id === null) {
                console.warn(
                  `${upperServiceType}服務配置 ${index} 缺少ID，使用索引作為ID`
                );
                config.id = index + 1;
              }
              // 確保服務配置有名稱
              if (!config.name) {
                console.warn(
                  `${upperServiceType}服務配置 ${index} 缺少名稱，使用預設名稱`
                );
                config.name = `${upperServiceType} Config ${config.id}`;
              }
              // 確保服務類型正確
              if (!config.service_type) {
                config.service_type = upperServiceType;
              }
              return config;
            })
            .filter((config) => config !== null); // 過濾掉無效的配置
          console.log(
            `處理後的${upperServiceType}服務配置數據:`,
            processedData
          );
          // 更新快取
          this.servicesCache.set(cacheKey, processedData);
          this.lastFetchTimes.set(cacheKey, now);
          this.pendingRequests.delete(cacheKey); // 清除進行中的請求
          return processedData;
        })
        .catch((error) => {
          console.error(`獲取${upperServiceType}服務配置失敗:`, error);
          this.pendingRequests.delete(cacheKey); // 清除進行中的請求，即使出錯
          // 檢查是否為 CORS 錯誤或網路錯誤
          if (
            error.message &&
            (error.message.includes('NetworkError') ||
              error.message.includes('Failed to fetch') ||
              error.message.includes('CORS'))
          ) {
            console.log(
              `疑似 CORS 或網路問題，返回空的${upperServiceType}服務配置列表`
            );
            return [];
          }
          // 返回空陣列，而不是拋出錯誤
          return [];
        });
      this.pendingRequests.set(cacheKey, request);
      return request;
    } catch (error) {
      console.error(`獲取${serviceType}服務配置過程中出錯:`, error);
      const cacheKey = serviceType.toUpperCase();
      this.pendingRequests.delete(cacheKey);
      // 返回空陣列，而不是拋出錯誤
      return [];
    }
  }

  /**
   * 獲取格式化後的外部服務配置選項，適用於下拉選單
   * @param {string} serviceType - 服務類型
   * @returns {Promise<Array>} 格式化的服務配置選項
   */
  async getServiceConfigOptions(serviceType) {
    try {
      const configs = await this.getExternalServiceConfigs(serviceType);
      console.log(`${serviceType}服務配置數據:`, configs);
      // 檢查服務配置數據是否有效
      if (!configs || !Array.isArray(configs)) {
        console.warn(`${serviceType}服務配置數據無效或不是陣列，返回空選項`);
        return [];
      }
      if (configs.length === 0) {
        console.warn(`API返回的${serviceType}服務配置陣列為空`);
        return [];
      }
      // 將API返回的服務配置數據轉換為select選項格式
      const options = configs
        .map((config, index) => {
          // 確保服務配置對象存在
          if (!config) {
            console.warn(
              `遇到無效的${serviceType}服務配置數據，索引: ${index}`
            );
            return null;
          }
          // 記錄每個服務配置的關鍵屬性
          console.log(`處理${serviceType}服務配置 ${index}:`, {
            id: config.id,
            name: config.name,
            service_type: config.service_type,
            description: config.description
          });
          // 取得 ID，確保是字串型別
          const configId =
            config.id !== undefined && config.id !== null
              ? config.id.toString()
              : `${index + 1}`;
          // 取得顯示名稱
          const displayLabel =
            config.name || `${serviceType} Config ${configId}`;
          // 取得描述
          const description = config.description || '';
          return {
            value: configId,
            label: displayLabel,
            description: description,
            serviceType: config.service_type || serviceType.toUpperCase(),
            config: config.config || {},
            updatedAt: config.updated_at,
            userId: config.user_id
          };
        })
        .filter((option) => option !== null); // 過濾掉無效的選項
      console.log(`最終格式化的${serviceType}選項:`, options);
      return options;
    } catch (error) {
      console.error(`獲取${serviceType}服務配置選項失敗:`, error);
      // 返回空陣列，以防API失敗
      return [];
    }
  }

  /**
   * 獲取所有支援的服務類型的配置
   * @returns {Promise<Object>} 所有服務類型的配置對象
   */
  async getAllServiceConfigs() {
    try {
      const allConfigs = {};
      // 並行獲取所有支援的服務類型配置
      const promises = this.supportedServiceTypes.map(async (serviceType) => {
        try {
          const configs = await this.getExternalServiceConfigs(serviceType);
          allConfigs[serviceType] = configs;
        } catch (error) {
          console.error(`獲取${serviceType}配置失敗:`, error);
          allConfigs[serviceType] = [];
        }
      });
      await Promise.all(promises);
      console.log('所有服務配置:', allConfigs);
      return allConfigs;
    } catch (error) {
      console.error('獲取所有服務配置失敗:', error);
      // 返回空對象結構
      const emptyConfigs = {};
      this.supportedServiceTypes.forEach((type) => {
        emptyConfigs[type] = [];
      });
      return emptyConfigs;
    }
  }

  /**
   * 清除特定服務類型的快取
   * @param {string} serviceType - 服務類型
   */
  clearCache(serviceType = null) {
    if (serviceType) {
      const cacheKey = serviceType.toUpperCase();
      this.servicesCache.delete(cacheKey);
      this.lastFetchTimes.delete(cacheKey);
      this.pendingRequests.delete(cacheKey);
      console.log(`已清除${serviceType}的快取`);
    } else {
      // 清除所有快取
      this.servicesCache.clear();
      this.lastFetchTimes.clear();
      this.pendingRequests.clear();
      console.log('已清除所有外部服務配置快取');
    }
  }

  /**
   * 清除特定頻道類型的 Messaging Types 快取
   * @param {string} channelType - 頻道類型
   */
  clearMessagingTypesCache(channelType = null) {
    if (channelType) {
      const cacheKey = channelType.toLowerCase();
      this.messagingTypesCache.delete(cacheKey);
      this.lastMessagingTypesFetchTimes.delete(cacheKey);
      this.pendingMessagingTypesRequests.delete(cacheKey);
      console.log(`已清除${channelType}的 Messaging Types 快取`);
    } else {
      // 清除所有 Messaging Types 快取
      this.messagingTypesCache.clear();
      this.lastMessagingTypesFetchTimes.clear();
      this.pendingMessagingTypesRequests.clear();
      console.log('已清除所有 Messaging Types 快取');
    }
  }

  /**
   * 預加載所有支援的服務類型配置，通常在應用啟動時呼叫
   */
  preloadData() {
    console.log('預加載所有外部服務配置和 Messaging Types');

    // 預加載服務配置
    this.supportedServiceTypes.forEach((serviceType) => {
      this.getExternalServiceConfigs(serviceType).catch((err) => {
        console.log(`預加載${serviceType}服務配置失敗:`, err);
      });
    });

    // 預加載 Messaging Types
    this.supportedChannelTypes.forEach((channelType) => {
      this.getMessagingTypes(channelType).catch((err) => {
        console.log(`預加載${channelType} Messaging Types失敗:`, err);
      });
    });
  }

  /**
   * 檢查服務類型是否被支援
   * @param {string} serviceType - 服務類型
   * @returns {boolean} 是否支援該服務類型
   */
  isSupportedServiceType(serviceType) {
    return this.supportedServiceTypes.includes(serviceType?.toUpperCase());
  }

  /**
   * 檢查頻道類型是否被支援 (用於 messaging types)
   * @param {string} channelType - 頻道類型
   * @returns {boolean} 是否支援該頻道類型
   */
  isSupportedChannelType(channelType) {
    return this.supportedChannelTypes.includes(channelType?.toLowerCase());
  }

  /**
   * 獲取支援的服務類型列表
   * @returns {Array} 支援的服務類型陣列
   */
  getSupportedServiceTypes() {
    return [...this.supportedServiceTypes];
  }

  /**
   * 獲取支援的頻道類型列表
   * @returns {Array} 支援的頻道類型陣列
   */
  getSupportedChannelTypes() {
    return [...this.supportedChannelTypes];
  }
}

/**
 * 更新後的工作流數據轉換器，使用共用的映射功能
 */
class WorkflowDataConverter {
  // 修改 transformToReactFlowFormat 方法，確保連線正確處理
  static transformToReactFlowFormat(apiData) {
    console.log('開始轉換 API 格式為 ReactFlow 格式', apiData);

    // 處理 API 數據結構差異
    const flowPipeline =
      apiData.flow_pipeline ||
      (apiData.content ? apiData.content.flow_pipeline : []);

    if (!flowPipeline || !Array.isArray(flowPipeline)) {
      console.error('找不到有效的 flow_pipeline 數組');
      return { nodes: [], edges: [] };
    }

    const nodes = [];
    const edges = [];

    // 首先處理所有節點，確保在創建邊緣之前節點已存在
    flowPipeline.forEach((node) => {
      console.log(`處理節點 ${node.id}, 操作符: ${node.operator}`);

      // 轉換為 ReactFlow 節點格式
      const reactFlowNode = {
        id: node.id,
        type: WorkflowMappingService.getTypeFromOperator(node.operator),
        position: {
          x: typeof node.position_x === 'number' ? node.position_x : 0,
          y: typeof node.position_y === 'number' ? node.position_y : 0
        },
        data: this.transformNodeDataToReactFlow(node)
      };

      // 特殊處理 BrowserExtensionOutput 節點
      if (node.operator === 'browser_extension_output') {
        console.log(`特殊處理 BrowserExtensionOutput 節點: ${node.id}`);

        // 從 node_input 提取所有 handle
        const inputHandles = [];
        const handleMap = new Map();

        if (node.node_input && typeof node.node_input === 'object') {
          const handlePattern = /^(output\d+)(?:_\d+)?$/;
          Object.keys(node.node_input).forEach((key) => {
            const match = key.match(handlePattern);
            if (match && match[1]) {
              const baseHandleId = match[1];
              if (!handleMap.has(baseHandleId)) {
                handleMap.set(baseHandleId, true);
                inputHandles.push({ id: baseHandleId });
                console.log(
                  `從 node_input 提取基本 handle ID: ${baseHandleId}`
                );
              }
            } else if (key === 'input') {
              // 處理舊版 'input' 格式，轉換為 'output0'
              if (!handleMap.has('output0')) {
                handleMap.set('output0', true);
                inputHandles.push({ id: 'output0' });
                console.log(`將舊版 'input' 轉換為 'output0'`);
              }
            } else {
              // 非標準格式的 handle ID 直接添加，但確保格式正確
              const normalizedId = key.startsWith('output')
                ? key
                : `output${inputHandles.length}`;
              if (!handleMap.has(normalizedId)) {
                handleMap.set(normalizedId, true);
                inputHandles.push({ id: normalizedId });
                console.log(`標準化 handle ID: ${key} -> ${normalizedId}`);
              }
            }
          });
        }

        // 檢查是否有從參數中保存的 inputHandles
        if (
          node.parameters &&
          node.parameters.inputHandles &&
          node.parameters.inputHandles.data
        ) {
          const savedHandles = node.parameters.inputHandles.data;
          if (Array.isArray(savedHandles)) {
            savedHandles.forEach((handleId) => {
              const normalizedId = handleId === 'input' ? 'output0' : handleId;
              if (!inputHandles.some((h) => h.id === normalizedId)) {
                inputHandles.push({ id: normalizedId });
                console.log(`從 parameters 提取 handle: ${normalizedId}`);
              }
            });
          }
        }

        // 確保至少有一個默認 handle
        if (inputHandles.length === 0) {
          inputHandles.push({ id: 'output0' });
          console.log(`添加默認 handle: output0`);
        }

        // 設置節點數據，確保所有必要的屬性都存在
        reactFlowNode.data.inputHandles = inputHandles;

        // 確保 node_input 與 inputHandles 同步
        if (!reactFlowNode.data.node_input) {
          reactFlowNode.data.node_input = {};
        }

        // 為每個 handle 確保有對應的 node_input 項目
        inputHandles.forEach((handle) => {
          if (!reactFlowNode.data.node_input[handle.id]) {
            reactFlowNode.data.node_input[handle.id] = {
              node_id: '',
              output_name: '',
              type: 'string',
              data: '',
              is_empty: true,
              return_name: ''
            };
          }
        });

        // 重要：立即標記節點為已初始化，避免重複初始化
        reactFlowNode.data.isPreInitialized = true;
      }

      if (node.operator === 'webhook_output') {
        console.log(`特殊處理 webhook_output 節點: ${node.id}`);

        const inputHandles = [];
        const handleMap = new Map();

        if (node.node_input && typeof node.node_input === 'object') {
          const handlePattern = /^(text\d+)(?:_\d+)?$/;
          Object.keys(node.node_input).forEach((key) => {
            const match = key.match(handlePattern);
            if (match && match[1]) {
              const baseHandleId = match[1];
              if (!handleMap.has(baseHandleId)) {
                handleMap.set(baseHandleId, true);
                inputHandles.push({ id: baseHandleId });
                console.log(
                  `從 node_input 提取基本 handle ID: ${baseHandleId}`
                );
              }
            } else if (key === 'input') {
              // 處理舊版 'input' 格式，轉換為 'text0'
              if (!handleMap.has('text0')) {
                handleMap.set('text0', true);
                inputHandles.push({ id: 'text0' });
                console.log(`將舊版 'input' 轉換為 'text0'`);
              }
            } else {
              const normalizedId = key.startsWith('text')
                ? key
                : `text${inputHandles.length}`;
              if (!handleMap.has(normalizedId)) {
                handleMap.set(normalizedId, true);
                inputHandles.push({ id: normalizedId });
                console.log(`標準化 handle ID: ${key} -> ${normalizedId}`);
              }
            }
          });
        }

        if (
          node.parameters &&
          node.parameters.inputHandles &&
          node.parameters.inputHandles.data
        ) {
          const savedHandles = node.parameters.inputHandles.data;
          if (Array.isArray(savedHandles)) {
            savedHandles.forEach((handleId) => {
              const normalizedId = handleId === 'input' ? 'text0' : handleId;
              if (!inputHandles.some((h) => h.id === normalizedId)) {
                inputHandles.push({ id: normalizedId });
                console.log(`從 parameters 提取 handle: ${normalizedId}`);
              }
            });
          }
        }

        if (inputHandles.length === 0) {
          inputHandles.push({ id: 'text0' });
          console.log(`添加默認 handle: text0`);
        }

        reactFlowNode.data.inputHandles = inputHandles;

        if (!reactFlowNode.data.node_input) {
          reactFlowNode.data.node_input = {};
        }

        inputHandles.forEach((handle) => {
          if (!reactFlowNode.data.node_input[handle.id]) {
            reactFlowNode.data.node_input[handle.id] = {
              node_id: '',
              output_name: '',
              type: 'string',
              data: '',
              is_empty: true,
              return_name: ''
            };
          }
        });

        reactFlowNode.data.isPreInitialized = true;
      }

      nodes.push(reactFlowNode);
    });

    // 處理連接關係 - 延遲處理，確保所有節點都已設置
    setTimeout(() => {
      this.createEdgesFromNodeInputs(flowPipeline, nodes, edges);
    }, 0);

    console.log(`轉換完成: ${nodes.length} 個節點, 準備創建連接`);

    // 自動布局（如果位置都是 0,0）
    this.autoLayout(nodes);

    return { nodes, edges };
  }

  // 新增方法：從 node_input 創建邊緣
  static createEdgesFromNodeInputs(flowPipeline, nodes, edges) {
    flowPipeline.forEach((node) => {
      const isAINode = node.operator === 'ask_ai';
      const isKnowledgeNode = node.operator === 'knowledge_retrieval';
      const isMessageNode = node.operator === 'line_send_message';
      const isExtractDataNode = node.operator === 'extract_data';
      const isQOCAAimNode = node.operator === 'aim_ml';

      if (node.node_input && Object.keys(node.node_input).length > 0) {
        console.log(`處理節點 ${node.id} 的輸入連接:`, node.node_input);

        if (isAINode) {
          const promptInput = node.node_input.prompt;
          if (promptInput && promptInput.node_id === '') {
            const reactFlowNode = nodes.find((n) => n.id === node.id);
            if (reactFlowNode) {
              reactFlowNode.data.promptText = promptInput.data || '';
              console.log(
                `設置AI節點直接輸入的提示文本: "${promptInput.data}"`
              );
            }
          }
        }

        Object.entries(node.node_input).forEach(([inputKey, inputValue]) => {
          if (inputKey === 'prompt' && inputValue.node_id === '') {
            return;
          }

          if (!inputValue.node_id || inputValue.is_empty === true) {
            console.log(`跳過空連接: ${node.id}:${inputKey}`);
            return;
          }

          let targetHandle = inputKey;

          // 處理不同節點類型的特殊targetHandle
          if (node.operator === 'browser_extension_output') {
            const match = inputKey.match(/^(output\d+)(?:_\d+)?$/);
            if (match && match[1]) {
              targetHandle = match[1];
            } else if (inputKey === 'input') {
              targetHandle = 'output0';
            }
          }

          if (node.operator === 'webhook_output') {
            const match = inputKey.match(/^(text\d+)(?:_\d+)?$/);
            if (match && match[1]) {
              targetHandle = match[1];
            } else if (inputKey === 'input') {
              targetHandle = 'text0';
            }
          }

          if (isAINode) {
            if (inputKey.startsWith('context')) {
              targetHandle = 'context-input';
            } else if (inputKey === 'prompt' || inputKey === 'prompt-input') {
              targetHandle = 'prompt-input';
            }
          } else if (isKnowledgeNode) {
            if (inputKey === 'passage' || inputKey === 'input') {
              targetHandle = 'passage';
            }
          } else if (isMessageNode) {
            if (inputKey.startsWith('message') || inputKey === 'input') {
              targetHandle = 'message';
            }
          } else if (isExtractDataNode) {
            if (
              inputKey === 'context_to_extract_from' ||
              inputKey === 'input'
            ) {
              targetHandle = 'context-input';
            }
          } else if (isQOCAAimNode) {
            if (inputKey === 'context' || inputKey === 'input') {
              targetHandle = 'input';
            }
          }

          const edgeId = `${inputValue.node_id}-${node.id}-${inputKey}-${
            inputValue.output_name || 'output'
          }`;

          console.log(
            `創建連接: ${edgeId}, 從 ${inputValue.node_id} 到 ${node.id}:${targetHandle}`
          );

          const targetNode = nodes.find((n) => n.id === node.id);
          if (!targetNode) {
            console.warn(`找不到目標節點 ${node.id}，跳過邊緣創建`);
            return;
          }

          const edge = {
            id: edgeId,
            source: inputValue.node_id,
            sourceHandle: inputValue.output_name || 'output',
            target: node.id,
            targetHandle: targetHandle,
            type: 'custom-edge'
          };

          if (inputValue.return_name) {
            edge.label = inputValue.return_name;
            console.log(
              `邊緣 ${edgeId} 添加 return_name: ${inputValue.return_name}`
            );
          }

          console.log('創建的邊緣詳情:', {
            id: edge.id,
            source: edge.source,
            target: edge.target,
            sourceHandle: edge.sourceHandle,
            targetHandle: edge.targetHandle,
            label: edge.label
          });

          edges.push(edge);
        });
      }
    });
  }
  /**
   * 將 API 節點數據轉換為 ReactFlow 節點數據
   * @param {Object} node - API 格式節點
   * @returns {Object} - ReactFlow 格式節點數據
   */
  static transformNodeDataToReactFlow(node) {
    const baseData = {
      label: WorkflowMappingService.getNodeLabel(node),
      category: node.category,
      operator: node.operator,
      version: node.version,
      node_input: node.node_input,
      node_output: node.node_output
    };

    if (node.operator === 'browser_extension_output') {
      baseData.onAddOutput = (newInputHandles) => {
        // 類似於 handleAddBrowserExtensionOutput 中的邏輯
        console.log(`更新節點的 handle：`, newInputHandles);
        // 實現更新邏輯
      };

      baseData.onRemoveHandle = (handleId) => {
        // 實現移除 handle 的邏輯
        console.log(`準備移除 handle：${handleId}`);
      };
    }
    if (node.operator === 'webhook_output') {
      baseData.onAddOutput = (newInputHandles) => {
        // 類似於 handleAddWebhookOutput 中的邏輯
        console.log(`更新節點的 handle：`, newInputHandles);
        // 實現更新邏輯
      };

      baseData.onRemoveHandle = (handleId) => {
        // 實現移除 handle 的邏輯
        console.log(`準備移除 handle：${handleId}`);
      };
    }

    // 根據節點類型轉換參數
    switch (node.operator) {
      case 'router_switch': {
        // Router Switch 節點的數據轉換
        const routersData = node.parameters?.routers?.data || [];

        return {
          ...baseData,
          llm_id: node.parameters?.llm_id?.data?.toString() || '1',
          routers: Array.isArray(routersData) ? routersData : []
        };
      }
      case 'schedule_trigger': {
        // Schedule Trigger 節點的數據轉換 - 支持新舊格式
        return {
          ...baseData,
          schedule_type:
            node.parameters?.schedule_type?.data ||
            node.parameters?.schedule_type ||
            'cron',
          cron_expression:
            node.parameters?.cron_expression?.data ||
            node.parameters?.cron_expression ||
            '',
          execute_at:
            node.parameters?.execute_at?.data ||
            node.parameters?.execute_at ||
            null,
          timezone:
            node.parameters?.timezone?.data ||
            node.parameters?.timezone ||
            'Asia/Taipei',
          enabled:
            node.parameters?.enabled?.data ?? node.parameters?.enabled ?? true,
          description:
            node.parameters?.description?.data ||
            node.parameters?.description ||
            ''
        };
      }
      case 'http_request':
        // HTTP Request 節點的數據轉換
        return {
          ...baseData,
          url: node.parameters?.url?.data || '',
          method: node.parameters?.method?.data || 'GET',
          headers: node.parameters?.headers?.data || [{ key: '', value: '' }],
          body: node.parameters?.body?.data || ''
        };
      case 'extract_data': {
        // Extract Data 節點的數據轉換
        const columnsData = node.parameters?.columns?.data || [];
        const columns = Array.isArray(columnsData) ? columnsData : [];

        return {
          ...baseData,
          model: node.parameters?.llm_id?.data?.toString() || '1',
          columns: columns
        };
      }
      case 'line_webhook_input':
        console.log('處理 line 節點數據轉換:', node);
        return {
          ...baseData,
          external_service_config_id:
            node.parameters?.external_service_config_id?.data || '',
          webhook_url: node.parameters?.webhook_url?.data || '',
          // 從 node_output 推斷輸出 handles
          output_handles: node.node_output
            ? Object.keys(node.node_output).filter((key) => key !== 'node_id')
            : ['text', 'image']
        };
      case 'browser_extension_input':
        return {
          ...baseData,
          type: 'browserExtensionInput',
          browser_extension_url: node.parameters?.browser_extension_url?.data,
          items:
            node.parameters?.functions?.map((func) => ({
              id: func.func_id,
              name: func.func_name,
              icon: func.func_icon || 'document'
            })) || []
        };

      case 'browser_extension_output': {
        // 從 node_input 提取 handle，但只有在有連線時才提取
        let inputHandles = [];

        // 檢查是否有 node_input 數據
        if (
          node.node_input &&
          typeof node.node_input === 'object' &&
          Object.keys(node.node_input).length > 0
        ) {
          console.log(
            `處理瀏覽器擴展輸出節點 ${node.id} 的輸入:`,
            node.node_input
          );

          // 從 node_input 提取所有 handle ID
          inputHandles = Object.keys(node.node_input).map((handleId) => {
            console.log(`從 node_input 提取 handle ID: ${handleId}`);
            return { id: handleId };
          });

          console.log(
            `節點 ${node.id} 從 node_input 提取的 handle:`,
            inputHandles
          );
        } else {
          console.log(`節點 ${node.id} 沒有 node_input 數據，不創建 handle`);
        }

        return {
          ...baseData,
          type: 'browserExtensionOutput',
          inputHandles: inputHandles
        };
      }

      case 'webook_output': {
        // 從 node_input 提取 handle，但只有在有連線時才提取
        let inputHandles = [];

        // 檢查是否有 node_input 數據
        if (
          node.node_input &&
          typeof node.node_input === 'object' &&
          Object.keys(node.node_input).length > 0
        ) {
          console.log(
            `處理瀏覽器擴展輸出節點 ${node.id} 的輸入:`,
            node.node_input
          );

          // 從 node_input 提取所有 handle ID
          inputHandles = Object.keys(node.node_input).map((handleId) => {
            console.log(`從 node_input 提取 handle ID: ${handleId}`);
            return { id: handleId };
          });

          console.log(
            `節點 ${node.id} 從 node_input 提取的 handle:`,
            inputHandles
          );
        } else {
          console.log(`節點 ${node.id} 沒有 node_input 數據，不創建 handle`);
        }

        return {
          ...baseData,
          type: 'webhook_output',
          inputHandles: inputHandles
        };
      }

      case 'webhook':
        return {
          ...baseData,
          webhookUrl: node.parameters?.webhook_url?.data || ''
        };

      case 'ask_ai': {
        // 獲取模型ID，確保處理可能的undefined或null值 // 優先使用 llm_id，如果不存在則使用 model
        const rawModelId =
          node.parameters?.llm_id?.data !== undefined
            ? node.parameters.llm_id.data
            : node.parameters?.model?.data !== undefined
            ? node.parameters.model.data
            : '1';

        // 確保模型ID是字符串類型
        const modelId =
          rawModelId !== null && rawModelId !== undefined
            ? rawModelId.toString()
            : '1';

        // 提取 prompt 文本
        const promptText = node.parameters?.prompt?.data || '';

        return {
          ...baseData,
          model: modelId,
          promptText: promptText
        };
      }

      case 'basic_input': {
        // 提取參數中的欄位
        // const fields = [];
        // 修改: 使用固定參數名稱而不是索引
        // 有可能有舊資料， input_name_0, default_value_0, 也要多判斷
        const field = {
          inputName:
            node.parameters?.input_name?.data ||
            node.parameters?.input_name_0?.data ||
            'input_name',
          defaultValue:
            node.parameters?.default_value?.data ||
            node.parameters?.default_value_0?.data ||
            ''
        };

        console.log(`處理 basic_input 節點:`, {
          inputName: field.inputName,
          defaultValue: field.defaultValue
        });
        // const paramKeys = Object.keys(node.parameters || {});

        // console.log(`處理 basic_input 節點，參數鍵:`, paramKeys);

        // // 查找所有輸入欄位對
        // const fieldIndicies = new Set();

        // paramKeys.forEach((key) => {
        //   if (
        //     key.startsWith('input_name_') ||
        //     key.startsWith('default_value_')
        //   ) {
        //     const match = key.match(/_(\d+)$/);
        //     if (match && match[1]) {
        //       fieldIndicies.add(parseInt(match[1]));
        //     }
        //   }
        // });

        // const sortedIndicies = Array.from(fieldIndicies).sort((a, b) => a - b);
        // console.log(`找到欄位索引: ${sortedIndicies.join(', ')}`);

        // // 處理每個欄位
        // sortedIndicies.forEach((i) => {
        //   const field = {
        //     inputName:
        //       node.parameters?.[`input_name_${i}`]?.data || `input_${i}`,
        //     defaultValue: node.parameters?.[`default_value_${i}`]?.data || ''
        //   };
        //   fields.push(field);
        //   console.log(`添加欄位 ${i}:`, field);
        // });

        // // 確保至少有一個欄位
        // if (fields.length === 0) {
        //   const defaultField = {
        //     inputName: 'default_input',
        //     defaultValue: 'Enter value here'
        //   };
        //   fields.push(defaultField);
        //   console.log('添加一個默認欄位:', defaultField);
        // }

        // 返回完整的資料結構，不包含回調函數
        // 回調函數將在 updateNodeFunctions 中添加
        return {
          ...baseData,
          fields: [field]
        };
      }

      case 'ifElse':
        return {
          ...baseData,
          variableName: node.parameters?.variable?.data || '',
          operator: node.parameters?.operator?.data || 'equals',
          compareValue: node.parameters?.compare_value?.data || ''
        };

      case 'combine_text': {
        return {
          ...baseData,
          textToCombine: node.parameters?.text_to_combine?.data || '',
          editorHtmlContent: node.parameters?.editor_html_content?.data || '',
          activeTab: node.parameters?.active_tab?.data || 'editor'
        };
      }

      case 'knowledge_retrieval':
        return {
          ...baseData,
          selectedFile: node.parameters?.knowledge_base_id?.data || '',
          topK: node.parameters?.top_k?.data || 5,
          threshold: node.parameters?.threshold?.data || 0.7,
          availableFiles: [
            { id: 'icdcode', name: 'ICDCode.csv' },
            { id: 'cardiology', name: 'Cardiology_Diagnoses.csv' }
          ]
        };

      case 'http':
        return {
          ...baseData,
          url: node.parameters?.url?.data || '',
          method: node.parameters?.method?.data || 'GET'
        };

      case 'timer':
        return {
          ...baseData,
          hours: node.parameters?.hours?.data || 0,
          minutes: node.parameters?.minutes?.data || 0,
          seconds: node.parameters?.seconds?.data || 0
        };

      case 'event':
        return {
          ...baseData,
          eventType: node.parameters?.event_type?.data || 'message',
          eventSource: node.parameters?.event_source?.data || ''
        };

      case 'end':
        return {
          ...baseData,
          outputText: node.parameters?.output_text?.data || ''
        };
      case 'aim_ml': {
        console.log(
          'transformNodeDataToReactFlow - aim_ml 節點參數:',
          node.parameters
        );

        // 確保正確讀取所有參數
        const nodeData = {
          ...baseData,
          selectedAim: node.parameters?.aim_ml_id?.data || '',
          trainingId: node.parameters?.training_id?.data || 0,
          simulatorId: node.parameters?.simulator_id?.data || '',
          enableExplain: node.parameters?.enable_explain?.data ?? true,
          llmId: node.parameters?.llm_id?.data || 0,
          promptText: node.parameters?.prompt?.data || '',
          modelFieldsInfo: node.parameters?.model_fields_info?.data || ''
        };

        console.log('QOCA AIM 節點轉換後的數據:', nodeData);

        return nodeData;
      }
      default: {
        // 對於未明確處理的節點類型，保留原始參數
        const transformedParams = {};
        Object.entries(node.parameters || {}).forEach(([key, value]) => {
          transformedParams[key] = value.data;
        });
        return {
          ...baseData,
          ...transformedParams
        };
      }
    }
  }

  /**
   * 自動布局節點（如果所有節點都在同一位置）
   * @param {Array} nodes - ReactFlow 節點數組
   */
  static autoLayout(nodes) {
    // 檢查是否需要自動布局
    const needsLayout =
      nodes.length > 1 &&
      nodes.every((node) => node.position.x === 0 && node.position.y === 0);

    if (needsLayout) {
      console.log('執行自動節點布局');

      let currentX = 50;
      let currentY = 50;
      const xSpacing = 300;
      const ySpacing = 150;

      // 對節點進行分類
      const starterNodes = nodes.filter((node) =>
        ['browserExtensionInput', 'webhook'].includes(node.type)
      );

      const inputNodes = nodes.filter((node) =>
        ['customInput', 'input'].includes(node.type)
      );

      const processingNodes = nodes.filter((node) =>
        [
          'aiCustomInput',
          'ai',
          'ifElse',
          'knowledgeRetrieval',
          'http',
          'timer',
          'event',
          'extract_data'
        ].includes(node.type)
      );

      const outputNodes = nodes.filter((node) =>
        ['browserExtensionOutput', 'line', 'end'].includes(node.type)
      );

      // 布局開始節點
      starterNodes.forEach((node, index) => {
        node.position.x = currentX;
        node.position.y = currentY + index * ySpacing;
      });

      // 布局輸入節點
      currentX += xSpacing;
      inputNodes.forEach((node, index) => {
        node.position.x = currentX;
        node.position.y = currentY + index * ySpacing;
      });

      // 布局處理節點
      currentX += xSpacing;
      processingNodes.forEach((node, index) => {
        node.position.x = currentX;
        node.position.y = currentY + index * ySpacing;
      });

      // 布局輸出節點
      currentX += xSpacing;
      outputNodes.forEach((node, index) => {
        node.position.x = currentX;
        node.position.y = currentY + index * ySpacing;
      });

      console.log('自動布局完成');
    }
  }

  /**
   * 修改 WorkflowDataConverter 中的 convertReactFlowToAPI 方法，修復 'nodes is not defined' 錯誤
   */
  static convertReactFlowToAPI(reactFlowData) {
    console.log('開始轉換 ReactFlow 格式為 API 格式');

    // 從 reactFlowData 中提取節點和邊緣
    const { nodes, edges } = reactFlowData;

    if (!nodes || !Array.isArray(nodes)) {
      console.error('缺少有效的節點數據');
      return null;
    }

    // 轉換節點
    const flowPipeline = nodes.map((node) => {
      console.log(`處理節點 ${node.id}, 類型: ${node.type}`);

      // 提取節點輸入連接 - 現在傳遞所有節點作為參數
      const nodeInput = WorkflowMappingService.extractNodeInputForAPI(
        node.id,
        edges,
        nodes
      );

      // 提取節點輸出連接
      const nodeOutput = WorkflowMappingService.extractNodeOutputForAPI(node);

      // 轉換節點數據
      const parameters = this.transformNodeDataToAPI(node);

      return {
        id: node.id,
        category: WorkflowMappingService.getCategoryFromType(node.type),
        operator: WorkflowMappingService.getOperatorFromType(node.type),
        parameters,
        position_x: node.position.x,
        position_y: node.position.y,
        version: node.data?.version || '0.0.1',
        node_input: nodeInput,
        node_output: nodeOutput
      };
    });

    // 創建最終 API 數據結構
    const apiData = {
      flow_name: reactFlowData.title || '未命名流程',
      flow_id: reactFlowData.id || `flow_${Date.now()}`,
      content: {
        flow_type: 'NORMAL',
        headers: reactFlowData.headers || {
          Authorization: 'Bearer your-token-here',
          'Content-Type': 'application/json'
        }
      },
      flow_pipeline: flowPipeline
    };

    console.log('轉換為 API 格式完成');
    return apiData;
  }

  /**
   * 統一 AI 節點輸入鍵的格式
   * @param {string} key - 原始輸入鍵
   * @param {number} index - 如果是上下文連接，提供的索引
   * @returns {string} - 統一格式的輸入鍵
   */
  static normalizeAIInputKey(key, index = 0) {
    // 處理 prompt 相關的鍵
    if (key === 'prompt-input' || key === 'prompt') {
      return 'prompt';
    }

    // 處理 context 相關的鍵
    if (key === 'context-input') {
      // 單一 context 連接
      return 'context0';
    } else if (key.startsWith('context-input_')) {
      // 舊版多連接格式：context-input_0, context-input_1
      const oldIndex = key.split('_')[1];
      return `context${oldIndex}`;
    } else if (key.match(/^context\d+$/)) {
      // 新版格式：已經是 context0, context1 等
      return key;
    } else if (key.startsWith('context')) {
      // 其他 context 開頭的格式
      return `context${index}`;
    }

    // 其他鍵保持不變
    return key;
  }

  /**
   * 將 ReactFlow 節點數據轉換為 API 參數格式
   * @param {Object} node - ReactFlow 節點
   * @returns {Object} - API 格式參數
   */
  static transformNodeDataToAPI(node) {
    const parameters = {};
    console.log(`轉換節點 ${node.id} 數據為 API 參數`);
    switch (node.type) {
      case 'router_switch': {
        // Router Switch 節點參數轉換
        if (node.data.llm_id) {
          const modelValue = node.data.llm_id || '1';
          const safeModelValue =
            typeof modelValue !== 'string'
              ? modelValue.toString()
              : modelValue;
          parameters.llm_id = { data: Number(safeModelValue) };
        }

        // 處理 routers 數據
        if (node.data.routers && Array.isArray(node.data.routers)) {
          parameters.routers = { data: node.data.routers };
        } else {
          // 預設結構
          parameters.routers = {
            data: [
              {
                router_id: 'router0',
                router_name: 'Router',
                ai_condition: ''
              },
              {
                router_id: 'default_router',
                router_name: 'Other',
                ai_condition: ''
              }
            ]
          };
        }
        break;
      }
      case 'schedule_trigger': {
        // Schedule Trigger 節點參數轉換 - 直接使用值而不包裝在 data 中
        if (node.data.schedule_type) {
          parameters.schedule_type = node.data.schedule_type;
        }

        if (node.data.cron_expression) {
          parameters.cron_expression = node.data.cron_expression;
        }

        if (node.data.execute_at) {
          parameters.execute_at = node.data.execute_at;
        }

        if (node.data.timezone) {
          parameters.timezone = node.data.timezone;
        }

        if (node.data.enabled !== undefined) {
          parameters.enabled = node.data.enabled;
        }

        if (node.data.description) {
          parameters.description = node.data.description;
        }

        break;
      }
      case 'httpRequest':
        // HTTP Request 節點參數轉換
        if (node.data.url) {
          parameters.url = { data: node.data.url };
        }

        if (node.data.method) {
          parameters.method = { data: node.data.method };
        }

        // Headers 處理 - 只有非空的 headers 才加入
        if (node.data.headers && Array.isArray(node.data.headers)) {
          const validHeaders = node.data.headers.filter(
            (header) => header.key && header.value
          );
          if (validHeaders.length > 0) {
            parameters.headers = { data: validHeaders };
          }
        }

        // Body 處理 - 只有在支援 body 的方法且有內容時才加入
        if (
          ['POST', 'PUT', 'PATCH'].includes(node.data.method) &&
          node.data.body
        ) {
          parameters.body = { data: node.data.body };
        }
        break;
      case 'line_webhook_input':
      case 'line':
        console.log('處理 line 節點 API 轉換:', node.data);
        // Line Webhook 節點參數
        if (node.data.external_service_config_id) {
          parameters.external_service_config_id = {
            data:
              parseInt(node.data.external_service_config_id) ||
              node.data.external_service_config_id
          };
        }
        if (node.data.webhook_url) {
          parameters.webhook_url = {
            data: node.data.webhook_url
          };
        }
        break;
      case 'customInput':
      case 'input':
        // if (node.data.fields && node.data.fields.length > 0) {
        //   node.data.fields.forEach((field, index) => {
        //     parameters[`input_name_${index}`] = { data: field.inputName || '' };
        //     parameters[`default_value_${index}`] = {
        //       data: field.defaultValue || ''
        //     };
        //   });
        //   console.log(`處理 ${node.data.fields.length} 個輸入欄位`);
        // } else {
        //   console.warn(`節點 ${node.id} 沒有欄位資料`);
        // }

        // 修改: 使用固定參數名稱而不是索引
        // 使用第一個欄位的資料，或是空字串
        if (node.data.fields && node.data.fields.length > 0) {
          const field = node.data.fields[0]; // 只使用第一個欄位
          parameters.input_name = { data: field.inputName || '' };
          parameters.default_value = { data: field.defaultValue || '' };
          console.log(
            `處理輸入節點參數: input_name=${field.inputName}, default_value=${field.defaultValue}`
          );
        } else {
          // 如果沒有欄位資料，提供默認值
          parameters.input_name = { data: 'input_name' };
          parameters.default_value = { data: 'Summary the input text' };
          console.warn(`節點 ${node.id} 沒有欄位資料，使用默認值`);
        }
        break;

      case 'aiCustomInput':
      case 'ai': {
        // 處理可能的無效model值
        const modelValue = node.data.model || '1';

        // 確保值為字符串
        const safeModelValue =
          typeof modelValue !== 'string'
            ? modelValue.toString()
            : modelValue;

        // 使用model作為llm_id - 現在存的是ID值而非名稱
        parameters.llm_id = { data: Number(safeModelValue) };

        // 新增處理 promptText - 當有直接輸入的提示文本時
        // 兼容舊版：不覆蓋已有的 prompt 參數
        if (node.data.promptText && !parameters.prompt) {
          parameters.prompt = { data: node.data.promptText };
        }

        break;
      }

      case 'browserExtensionInput':
      case 'browserExtInput':
        if (node.data.browser_extension_url) {
          parameters.browser_extension_url = {
            data: node.data.browser_extension_url
          };
        }
        if (node.data.items && node.data.items.length > 0) {
          parameters.functions = node.data.items.map((item, index) => ({
            func_id: item.id || `a${index + 1}`,
            func_name: item.name || '',
            func_icon: item.icon || 'document'
          }));
        }
        break;

      case 'webhook':
        if (node.data.webhookUrl) {
          parameters.webhook_url = { data: node.data.webhookUrl };
        }
        break;

      case 'knowledgeRetrieval':
      case 'knowledge_retrieval':
        if (node.data.selectedFile) {
          parameters.knowledge_base_id = { data: node.data.selectedFile };
        }
        // 添加 top_k 參數
        parameters.top_k = { data: node.data.topK || 5 };
        // 添加 threshold 參數
        parameters.threshold = {
          type: 'float',
          data: node.data.threshold || 0.7
        };
        break;
      case 'ifElse':
        if (node.data.variableName) {
          parameters.variable = { data: node.data.variableName };
        }
        if (node.data.operator) {
          parameters.operator = { data: node.data.operator };
        }
        if (node.data.compareValue !== undefined) {
          parameters.compare_value = { data: node.data.compareValue };
        }
        break;

      case 'http':
        if (node.data.url) {
          parameters.url = { data: node.data.url };
        }
        if (node.data.method) {
          parameters.method = { data: node.data.method };
        }
        break;

      case 'timer':
        parameters.hours = { data: node.data.hours || 0 };
        parameters.minutes = { data: node.data.minutes || 0 };
        parameters.seconds = { data: node.data.seconds || 0 };
        break;

      case 'event':
        parameters.event_type = { data: node.data.eventType || 'message' };
        if (node.data.eventSource) {
          parameters.event_source = { data: node.data.eventSource };
        }
        break;

      case 'end':
        if (node.data.outputText !== undefined) {
          parameters.output_text = { data: node.data.outputText };
        }
        break;

      case 'browserExtensionOutput':
        // 重要：保存所有 inputHandles 到 parameters
        if (
          node.data &&
          node.data.inputHandles &&
          Array.isArray(node.data.inputHandles)
        ) {
          // 從實際的 inputHandles 獲取 handle ID 列表
          const handleIds = node.data.inputHandles.map((h) => h.id);

          // 儲存 handle ID 列表到 parameters
          parameters.inputHandles = {
            data: handleIds
          };

          console.log(
            `保存節點 ${node.id} 的 ${handleIds.length} 個 handle 到 parameters:`,
            handleIds
          );

          // 🔧 修復：驗證 node_input 與 inputHandles 的一致性
          if (node.data.node_input) {
            const nodeInputKeys = Object.keys(node.data.node_input);
            const missingInNodeInput = handleIds.filter(
              (id) => !nodeInputKeys.includes(id)
            );
            const extraInNodeInput = nodeInputKeys.filter(
              (id) => !handleIds.includes(id)
            );

            if (missingInNodeInput.length > 0) {
              console.warn(
                `節點 ${node.id} 的 node_input 缺少 handles:`,
                missingInNodeInput
              );
            }

            if (extraInNodeInput.length > 0) {
              console.warn(
                `節點 ${node.id} 的 node_input 有多餘的 handles:`,
                extraInNodeInput
              );
            }

            // 🔧 修復：確保 node_input 包含所有 inputHandles 中的 handle
            handleIds.forEach((handleId) => {
              if (!node.data.node_input[handleId]) {
                console.log(
                  `為節點 ${node.id} 添加缺少的 node_input 項目: ${handleId}`
                );
                node.data.node_input[handleId] = {
                  node_id: '',
                  output_name: '',
                  type: 'string',
                  data: '',
                  is_empty: true,
                  return_name: ''
                };
              }
            });
          }
        } else {
          console.warn(`節點 ${node.id} 沒有有效的 inputHandles 資料`);
          // 提供默認值
          parameters.inputHandles = {
            data: ['output0']
          };
        }
        break;
      case 'webhook_output':
        // 重要：保存所有 inputHandles 到 parameters
        if (
          node.data &&
          node.data.inputHandles &&
          Array.isArray(node.data.inputHandles)
        ) {
          // 從實際的 inputHandles 獲取 handle ID 列表
          const handleIds = node.data.inputHandles.map((h) => h.id);

          // 儲存 handle ID 列表到 parameters
          parameters.inputHandles = {
            data: handleIds
          };

          console.log(
            `保存節點 ${node.id} 的 ${handleIds.length} 個 handle 到 parameters:`,
            handleIds
          );

          // 🔧 修復：驗證 node_input 與 inputHandles 的一致性
          if (node.data.node_input) {
            const nodeInputKeys = Object.keys(node.data.node_input);
            const missingInNodeInput = handleIds.filter(
              (id) => !nodeInputKeys.includes(id)
            );
            const extraInNodeInput = nodeInputKeys.filter(
              (id) => !handleIds.includes(id)
            );

            if (missingInNodeInput.length > 0) {
              console.warn(
                `節點 ${node.id} 的 node_input 缺少 handles:`,
                missingInNodeInput
              );
            }

            if (extraInNodeInput.length > 0) {
              console.warn(
                `節點 ${node.id} 的 node_input 有多餘的 handles:`,
                extraInNodeInput
              );
            }

            // 🔧 修復：確保 node_input 包含所有 inputHandles 中的 handle
            handleIds.forEach((handleId) => {
              if (!node.data.node_input[handleId]) {
                console.log(
                  `為節點 ${node.id} 添加缺少的 node_input 項目: ${handleId}`
                );
                node.data.node_input[handleId] = {
                  node_id: '',
                  output_name: '',
                  type: 'string',
                  data: '',
                  is_empty: true,
                  return_name: ''
                };
              }
            });
          }
        } else {
          console.warn(`節點 ${node.id} 沒有有效的 inputHandles 資料`);
          // 提供默認值
          parameters.inputHandles = {
            data: ['text0']
          };
        }
        break;

      case 'extract_data':
      case 'extractData':
        // Extract Data 節點參數
        if (node.data.model) {
          const modelValue = node.data.model || '1';
          const safeModelValue =
            typeof modelValue !== 'string'
              ? modelValue.toString()
              : modelValue;
          parameters.llm_id = { data: Number(safeModelValue) };
        }

        // 處理 columns 數據
        if (node.data.columns && Array.isArray(node.data.columns)) {
          parameters.columns = { data: node.data.columns };

          // 生成 example JSON 字符串
          const exampleObj = {};
          node.data.columns.forEach((column) => {
            switch (column.type) {
              case 'number':
                exampleObj[column.name] = 0;
                break;
              case 'boolean':
                exampleObj[column.name] = false;
                break;
              default: // text
                exampleObj[column.name] = '';
                break;
            }
          });
          parameters.example = { data: JSON.stringify(exampleObj) };
        } else {
          // 預設 columns 和 example
          parameters.columns = {
            data: [
              {
                name: 'fasting_blood_sugar',
                type: 'text',
                description: '> 120 mg/dl'
              }
            ]
          };
          parameters.example = { data: '{"fasting_blood_sugar": ""}' };
        }
        break;
      case 'aim_ml': {
        // QOCA AIM 節點參數轉換
        // aim_ml 參數
        if (node.data.selectedAim || node.data.aim_ml_id) {
          const aimValue =
            node.data.selectedAim || node.data.aim_ml_id?.data || '';
          if (aimValue) {
            parameters.aim_ml_id = { data: aimValue };
          }
        }

        // training_id 參數
        if (node.data.trainingId !== undefined || node.data.training_id) {
          const trainingValue =
            node.data.trainingId ?? node.data.training_id?.data ?? 0;
          parameters.training_id = { data: trainingValue };
        }

        // simulator_id 參數
        if (node.data.simulatorId || node.data.simulator_id) {
          const simulatorValue =
            node.data.simulatorId || node.data.simulator_id?.data || '';
          parameters.simulator_id = { data: simulatorValue };
        }

        // enable_explain 參數 (預設為 true)
        const enableExplainValue =
          node.data.enableExplain ?? node.data.enable_explain?.data ?? true;
        parameters.enable_explain = { data: enableExplainValue };

        if (
          node.data.modelFieldsInfo !== undefined ||
          node.data.model_fields_info
        ) {
          const modelFieldsInfoValue =
            node.data.modelFieldsInfo ||
            node.data.model_fields_info?.data ||
            '';
          parameters.model_fields_info = { data: modelFieldsInfoValue };
        }

        // 只有當 enable_explain 為 true 時才處理以下參數
        if (enableExplainValue) {
          // llm_id 參數 - 現在支援 LLM Vision 模型 ID
          if (node.data.llmId !== undefined || node.data.llm_id) {
            const llmValue = node.data.llmId ?? node.data.llm_id?.data ?? 1;
            // 確保 llmValue 是數字類型，適用於 LLM Vision API 的 id 欄位
            const numericLlmValue =
              typeof llmValue === 'string' ? parseInt(llmValue) : llmValue;
            parameters.llm_id = { data: numericLlmValue };
          }

          // prompt 參數
          if (node.data.promptText || node.data.prompt) {
            const promptValue =
              node.data.promptText || node.data.prompt?.data || '';
            parameters.prompt = {
              type: 'string',
              data: promptValue,
              node_id: node.id || ''
            };
          }
        }

        console.log('QOCA AIM 節點轉換後的參數:', parameters);
        break;
      }
      case 'combine_text': {
        console.log('將 combine_text 節點資料轉換為 API 格式:', node.data);

        // Combine Text 節點參數轉換
        if (node.data.textToCombine !== undefined) {
          parameters.text_to_combine = { data: node.data.textToCombine };
        }

        // 保存編輯器 HTML 內容
        if (node.data.editorHtmlContent !== undefined) {
          parameters.editor_html_content = {
            data: node.data.editorHtmlContent
          };
        }

        // 保存當前 tab 狀態
        if (node.data.activeTab !== undefined) {
          parameters.active_tab = { data: node.data.activeTab };
        }

        // 保存輸入 handles 信息
        if (node.data.inputHandles && Array.isArray(node.data.inputHandles)) {
          const handleIds = node.data.inputHandles.map((h) => h.id);
          parameters.inputHandles = { data: handleIds };
        }

        console.log('combine_text 節點轉換後的參數:', parameters);
        break;
      }
      default:
        // 對於其他類型，直接轉換非系統屬性
        if (node.data) {
          Object.entries(node.data).forEach(([key, value]) => {
            // 排除系統屬性和函數
            if (
              ![
                'label',
                'category',
                'operator',
                'version',
                'node_input',
                'node_output',
                'onSelect',
                'updateNodeData',
                'addField',
                'updateFieldInputName',
                'updateFieldDefaultValue'
              ].includes(key) &&
              typeof value !== 'function'
            ) {
              parameters[key] = { data: value };
            }
          });
        }
    }

    return parameters;
  }
}

/**
 * 圖標上傳服務 - 處理與圖標上傳相關的 API 請求
 */
class IconUploadService {
  constructor() {
    this.cache = {}; // 緩存上傳過的圖標
  }

  /**
   * 上傳圖標文件到服務器
   * @param {File} file - 要上傳的文件對象
   * @returns {Promise<Object>} - 包含上傳結果的 Promise，成功時返回 {success: true, url: "圖標URL"}
   */
  async uploadIcon(file) {
    if (!file) {
      throw new Error('未提供文件');
    }

    // 檢查文件類型
    if (!file.type.startsWith('image/')) {
      throw new Error('僅支持圖片文件');
    }

    try {
      console.log(`開始上傳圖標: ${file.name}`);

      // 創建 FormData 對象
      const formData = new FormData();
      formData.append('file', file); // 使用正確的欄位名稱 'file'

      // 發送 POST 請求
      const options = tokenService.createAuthHeader({
        method: 'POST',
        headers: {
          accept: 'application/json'
          // 注意：不要設置 'Content-Type': 'multipart/form-data'，
          // fetch 會自動設置正確的 boundary
        },
        body: formData
      });

      const url = tokenService.createUrlWithWorkspace(
        `${API_CONFIG.BASE_URL}/agent_designer/icons/`
      );
      const response = await fetch(url, options);

      if (!response.ok) {
        throw new Error(`上傳失敗: ${response.status} ${response.statusText}`);
      }

      // 解析 API 回傳的資料
      const data = await response.json();
      console.log('圖標上傳成功:', data);

      if (!data.url) {
        throw new Error('API 未回傳圖標 URL');
      }

      // 將 URL 加入緩存
      this.cache[file.name] = data.url;

      return {
        success: true,
        url: data.url
      };
    } catch (error) {
      console.error('上傳圖標時發生錯誤:', error);
      return {
        success: false,
        error: error.message || '上傳圖標失敗',
        details: error
      };
    }
  }

  /**
   * 檢查圖標 URL 是否有效
   * @param {string} iconValue - 圖標值，可能是 URL 或預設圖標名稱
   * @returns {boolean} - 如果是有效的圖標 URL 返回 true
   */
  isIconUrl(iconValue) {
    return (
      typeof iconValue === 'string' &&
      (iconValue.startsWith('http://') || iconValue.startsWith('https://'))
    );
  }

  /**
   * 從緩存中獲取圖標 URL
   * @param {string} fileName - 文件名
   * @returns {string|null} - 如果存在則返回 URL，否則返回 null
   */
  getCachedIconUrl(fileName) {
    return this.cache[fileName] || null;
  }
}

/**
 * AIM模型服務 - 處理與AIM模型和LLM Vision模型相關的API請求
 */
class AIMService {
  constructor() {
    // AIM模型相關緩存
    this.aimModelsCache = null;
    this.aimLastFetchTime = null;

    // LLM Vision模型相關緩存
    this.llmVisionModelsCache = null;
    this.llmVisionLastFetchTime = null;

    // AIM 欄位資訊緩存
    this.aimFieldInfoCache = new Map(); // 使用 Map 以 training_id 為 key
    this.aimFieldInfoLastFetchTime = new Map(); // 每個 training_id 的最後獲取時間

    this.cacheExpiryTime = 10 * 60 * 1000; // 10分鐘cache過期
    this.aimPendingRequest = null; // 用於追蹤進行中的AIM請求
    this.llmVisionPendingRequest = null; // 用於追蹤進行中的LLM Vision請求
    this.aimFieldInfoPendingRequests = new Map(); // 追蹤進行中的欄位資訊請求
  }

  /**
   * 獲取 AIM 模型的欄位資訊
   * @param {number} trainingId - 訓練模型 ID
   * @returns {Promise<string>} 欄位資訊字串
   */
  async getAIMFieldInfo(trainingId) {
    try {
      // 驗證 trainingId
      if (!trainingId || trainingId === 0) {
        console.log('trainingId 無效，跳過欄位資訊獲取');
        return '';
      }

      const trainingIdStr = trainingId.toString();

      // 檢查是否有有效的快取
      const now = Date.now();
      const lastFetchTime = this.aimFieldInfoLastFetchTime.get(trainingIdStr);
      const cachedData = this.aimFieldInfoCache.get(trainingIdStr);

      if (
        cachedData &&
        lastFetchTime &&
        now - lastFetchTime < this.cacheExpiryTime
      ) {
        console.log(`使用快取的 AIM 欄位資訊 (training_id: ${trainingId})`);
        return cachedData;
      }

      // 如果已經有相同 training_id 的請求在進行中，則返回該請求
      if (this.aimFieldInfoPendingRequests.has(trainingIdStr)) {
        console.log(
          `已有進行中的 AIM 欄位資訊請求 (training_id: ${trainingId})，使用相同請求`
        );
        return this.aimFieldInfoPendingRequests.get(trainingIdStr);
      }

      // 創建新請求
      console.log(`獲取 AIM 欄位資訊 (training_id: ${trainingId})...`);
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(
            `嘗試獲取 AIM 欄位資訊，第 ${
              retryCount + 1
            } 次嘗試 (training_id: ${trainingId})`
          );

          // 使用新的方法創建帶 workspace_id 的 URL
          const url = tokenService.createUrlWithWorkspace(
            `${API_CONFIG.BASE_URL}/agent_designer/aim/field-info`,
            { training_id: trainingId }
          );

          const response = await fetch(url, options);

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          let fieldInfo = await response.text(); // 使用 text() 因為後端回覆 string
          console.log(
            `API返回 AIM 欄位資訊原始內容 (training_id: ${trainingId}):`,
            fieldInfo
          );

          // 檢查 API 是否回傳了已經被 JSON 序列化的字串
          // 如果字串以 " 開頭和結尾，表示它是一個被序列化的 JSON 字串
          if (fieldInfo.startsWith('"') && fieldInfo.endsWith('"')) {
            try {
              // 解析掉外層的 JSON 序列化，獲得真正的字串內容
              fieldInfo = JSON.parse(fieldInfo);
              console.log(
                `解析後的 AIM 欄位資訊 (training_id: ${trainingId}):`,
                fieldInfo
              );
            } catch (parseError) {
              console.warn(
                '無法解析 API 回傳的 JSON 字串，使用原始值:',
                parseError
              );
            }
          }

          return fieldInfo;
        } catch (error) {
          console.error(
            `第 ${retryCount + 1} 次嘗試失敗 (training_id: ${trainingId}):`,
            error
          );

          // 如果還有重試次數，進行重試
          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            // 添加延遲，避免立即重試
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          // 所有重試都失敗，返回空字串
          console.error(
            `所有重試都失敗 (training_id: ${trainingId})，返回空字串`
          );
          return '';
        }
      };

      const pendingRequest = attemptFetch()
        .then((fieldInfo) => {
          // 更新快取
          this.aimFieldInfoCache.set(trainingIdStr, fieldInfo);
          this.aimFieldInfoLastFetchTime.set(trainingIdStr, now);
          this.aimFieldInfoPendingRequests.delete(trainingIdStr); // 清除進行中的請求

          return fieldInfo;
        })
        .catch((error) => {
          console.error(
            `獲取 AIM 欄位資訊過程中發生意外錯誤 (training_id: ${trainingId}):`,
            error
          );
          this.aimFieldInfoPendingRequests.delete(trainingIdStr); // 清除進行中的請求，即使出錯

          // 返回空字串
          return '';
        });

      // 記錄進行中的請求
      this.aimFieldInfoPendingRequests.set(trainingIdStr, pendingRequest);

      return pendingRequest;
    } catch (error) {
      console.error(
        `獲取 AIM 欄位資訊過程中出錯 (training_id: ${trainingId}):`,
        error
      );
      this.aimFieldInfoPendingRequests.delete(trainingId?.toString());

      // 返回空字串
      return '';
    }
  }

  /**
   * 獲取所有可用的AIM模型
   * @returns {Promise<Array>} AIM模型列表
   */
  async getAIMModels() {
    try {
      // 檢查是否有有效的快取
      const now = Date.now();
      if (
        this.aimModelsCache &&
        this.aimLastFetchTime &&
        now - this.aimLastFetchTime < this.cacheExpiryTime
      ) {
        console.log('使用快取的AIM模型列表');
        return this.aimModelsCache;
      }

      // 如果已經有一個請求在進行中，則返回該請求
      if (this.aimPendingRequest) {
        console.log('已有進行中的AIM模型請求，使用相同請求');
        return this.aimPendingRequest;
      }

      // 創建新請求
      console.log('獲取AIM模型列表...');
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(`嘗試獲取AIM模型，第 ${retryCount + 1} 次嘗試`);

          const response = await fetch(
            `${API_CONFIG.BASE_URL}/agent_designer/aim/info`,
            options
          );

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          let data = await response.json();
          console.log('API返回原始AIM模型數據:', data);

          // 檢查數據是否為數組
          if (!Array.isArray(data)) {
            console.warn('API返回的AIM模型數據不是陣列');
            // 嘗試從可能的非數組格式中提取數據
            if (
              data &&
              typeof data === 'object' &&
              data.models &&
              Array.isArray(data.models)
            ) {
              data = data.models;
              console.log('從API回應中提取models陣列:', data);
            } else {
              // 如果無法提取合理的數據，返回空陣列
              console.warn('無法從API回應中提取合理的AIM模型數據，返回空陣列');
              return [];
            }
          }

          // 檢查每個模型對象，確保結構正確
          const processedData = data
            .map((model, index) => {
              if (!model || typeof model !== 'object') {
                console.warn(`AIM模型 ${index} 無效，跳過該模型`);
                return null; // 標記為無效，稍後過濾掉
              }

              // 確保模型有必要的屬性
              if (!model.aim_ml_id) {
                console.warn(`AIM模型 ${index} 缺少aim_ml_id，跳過該模型`);
                return null;
              }

              if (!model.model_name) {
                console.warn(`AIM模型 ${index} 缺少model_name，跳過該模型`);
                return null;
              }

              // training_id 和 simulator_id 可以是可選的
              return {
                aim_ml_id: model.aim_ml_id,
                training_id: model.training_id || 0,
                simulator_id: model.simulator_id || '',
                model_name: model.model_name
              };
            })
            .filter((model) => model !== null); // 過濾掉無效模型

          console.log('處理後的AIM模型數據:', processedData);
          return processedData;
        } catch (error) {
          console.error(`第 ${retryCount + 1} 次嘗試失敗:`, error);

          // 如果還有重試次數，進行重試
          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            // 添加延遲，避免立即重試
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          // 所有重試都失敗，返回空陣列
          console.error('所有重試都失敗，返回空陣列');
          return [];
        }
      };

      this.aimPendingRequest = attemptFetch()
        .then((processedData) => {
          // 更新快取
          this.aimModelsCache = processedData;
          this.aimLastFetchTime = now;
          this.aimPendingRequest = null; // 清除進行中的請求

          return processedData;
        })
        .catch((error) => {
          console.error('獲取AIM模型過程中發生意外錯誤:', error);
          this.aimPendingRequest = null; // 清除進行中的請求，即使出錯

          // 返回空陣列
          return [];
        });

      return this.aimPendingRequest;
    } catch (error) {
      console.error('獲取AIM模型過程中出錯:', error);
      this.aimPendingRequest = null;

      // 返回空陣列，而不是預設模型
      return [];
    }
  }

  /**
   * 獲取所有可用的LLM Vision模型
   * @returns {Promise<Array>} LLM Vision模型列表
   */
  async getLLMVisionModels() {
    try {
      // 檢查是否有有效的快取
      const now = Date.now();
      if (
        this.llmVisionModelsCache &&
        this.llmVisionLastFetchTime &&
        now - this.llmVisionLastFetchTime < this.cacheExpiryTime
      ) {
        console.log('使用快取的LLM Vision模型列表');
        return this.llmVisionModelsCache;
      }

      // 如果已經有一個請求在進行中，則返回該請求
      if (this.llmVisionPendingRequest) {
        console.log('已有進行中的LLM Vision模型請求，使用相同請求');
        return this.llmVisionPendingRequest;
      }

      // 創建新請求
      console.log('獲取LLM Vision模型列表...');
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(`嘗試獲取LLM Vision模型，第 ${retryCount + 1} 次嘗試`);

          // 使用新的方法創建帶 workspace_id 的 URL
          const url = tokenService.createUrlWithWorkspace(
            `${API_CONFIG.BASE_URL}/agent_designer/llm/vision`
          );

          const response = await fetch(url, options);

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          const data = await response.json();
          console.log('API返回原始LLM Vision模型數據:', data);

          // 檢查數據是否為數組
          if (!Array.isArray(data)) {
            console.warn('API返回的LLM Vision模型數據不是陣列');
            return [];
          }

          // 檢查每個模型對象，確保結構正確
          const processedData = data
            .map((model, index) => {
              if (!model || typeof model !== 'object') {
                console.warn(`LLM Vision模型 ${index} 無效，跳過該模型`);
                return null;
              }

              // 確保模型有必要的屬性
              if (model.id === undefined || model.id === null) {
                console.warn(`LLM Vision模型 ${index} 缺少id，跳過該模型`);
                return null;
              }

              if (!model.display_name) {
                console.warn(
                  `LLM Vision模型 ${index} 缺少display_name，跳過該模型`
                );
                return null;
              }

              return {
                id: model.id,
                display_name: model.display_name,
                description: model.description || '',
                provider: model.provider || ''
              };
            })
            .filter((model) => model !== null); // 過濾掉無效模型

          console.log('處理後的LLM Vision模型數據:', processedData);
          return processedData;
        } catch (error) {
          console.error(`第 ${retryCount + 1} 次嘗試失敗:`, error);

          // 如果還有重試次數，進行重試
          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            // 添加延遲，避免立即重試
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          // 所有重試都失敗，返回空陣列
          console.error('所有重試都失敗，返回空陣列');
          return [];
        }
      };

      this.llmVisionPendingRequest = attemptFetch()
        .then((processedData) => {
          // 更新快取
          this.llmVisionModelsCache = processedData;
          this.llmVisionLastFetchTime = now;
          this.llmVisionPendingRequest = null; // 清除進行中的請求

          return processedData;
        })
        .catch((error) => {
          console.error('獲取LLM Vision模型過程中發生意外錯誤:', error);
          this.llmVisionPendingRequest = null; // 清除進行中的請求，即使出錯

          // 返回空陣列
          return [];
        });

      return this.llmVisionPendingRequest;
    } catch (error) {
      console.error('獲取LLM Vision模型過程中出錯:', error);
      this.llmVisionPendingRequest = null;

      // 返回空陣列
      return [];
    }
  }

  /**
   * 獲取格式化後的AIM模型選項，適用於下拉選單
   * @returns {Promise<Array>} 格式化的AIM模型選項
   */
  async getAIMModelOptions() {
    try {
      const models = await this.getAIMModels();
      console.log('API返回的AIM模型數據:', models);

      // 檢查模型數據是否有效
      if (!models || !Array.isArray(models)) {
        console.warn('AIM模型數據無效或不是陣列，返回空陣列');
        return [];
      }

      if (models.length === 0) {
        console.warn('API返回的AIM模型陣列為空，返回空陣列');
        return [];
      }

      // 檢查第一個模型的結構，確認關鍵屬性
      const sampleModel = models[0];
      console.log('AIM模型數據結構示例:', sampleModel);

      // 將API返回的AIM模型數據轉換為select選項格式
      const options = models
        .map((model, index) => {
          // 確保模型對象存在
          if (!model) {
            console.warn(`遇到無效的AIM模型數據，索引: ${index}，跳過該模型`);
            return null; // 標記為無效，稍後過濾掉
          }

          // 記錄每個模型的關鍵屬性，幫助診斷
          console.log(`處理AIM模型 ${index}:`, {
            aim_ml_id: model.aim_ml_id,
            model_name: model.model_name,
            training_id: model.training_id,
            simulator_id: model.simulator_id
          });

          // 使用 aim_ml_id 作為 value，model_name 作為 label
          const modelValue = model.aim_ml_id;
          const modelLabel = model.model_name;

          // 如果缺少必要欄位，跳過該模型
          if (!modelValue || !modelLabel) {
            console.warn(`AIM模型 ${index} 缺少必要欄位，跳過該模型`);
            return null;
          }

          return {
            value: modelValue,
            label: modelLabel,
            training_id: model.training_id,
            simulator_id: model.simulator_id
          };
        })
        .filter((option) => option !== null); // 過濾掉無效選項

      console.log('最終格式化的AIM模型選項:', options);
      return options;
    } catch (error) {
      console.error('獲取AIM模型選項失敗:', error);
      // 返回空陣列，以防API失敗
      return [];
    }
  }

  /**
   * 獲取格式化後的LLM Vision模型選項，適用於下拉選單
   * @returns {Promise<Array>} 格式化的LLM Vision模型選項
   */
  async getLLMVisionModelOptions() {
    try {
      const models = await this.getLLMVisionModels();
      console.log('API返回的LLM Vision模型數據:', models);

      // 檢查模型數據是否有效
      if (!models || !Array.isArray(models)) {
        console.warn('LLM Vision模型數據無效或不是陣列，返回空陣列');
        return [];
      }

      if (models.length === 0) {
        console.warn('API返回的LLM Vision模型陣列為空，返回空陣列');
        return [];
      }

      // 檢查第一個模型的結構，確認關鍵屬性
      const sampleModel = models[0];
      console.log('LLM Vision模型數據結構示例:', sampleModel);

      // 將API返回的LLM Vision模型數據轉換為select選項格式
      const options = models
        .map((model, index) => {
          // 確保模型對象存在
          if (!model) {
            console.warn(
              `遇到無效的LLM Vision模型數據，索引: ${index}，跳過該模型`
            );
            return null;
          }

          // 記錄每個模型的關鍵屬性，幫助診斷
          console.log(`處理LLM Vision模型 ${index}:`, {
            id: model.id,
            display_name: model.display_name,
            description: model.description,
            provider: model.provider
          });

          // 使用 id 作為 value，display_name 作為 label
          const modelValue = model.id;
          const modelLabel = model.display_name;

          // 如果缺少必要欄位，跳過該模型
          if (modelValue === undefined || modelValue === null || !modelLabel) {
            console.warn(`LLM Vision模型 ${index} 缺少必要欄位，跳過該模型`);
            return null;
          }

          return {
            value: modelValue,
            label: modelLabel,
            description: model.description,
            provider: model.provider
          };
        })
        .filter((option) => option !== null); // 過濾掉無效選項

      console.log('最終格式化的LLM Vision模型選項:', options);
      return options;
    } catch (error) {
      console.error('獲取LLM Vision模型選項失敗:', error);
      // 返回空陣列，以防API失敗
      return [];
    }
  }

  /**
   * 預加載所有模型數據，通常在應用啟動時呼叫
   */
  preloadData() {
    console.log('預加載AIM和LLM Vision模型列表');

    // 預加載AIM模型
    this.getAIMModels().catch((err) => {
      console.log('預加載AIM模型失敗:', err);
    });

    // 預加載LLM Vision模型
    this.getLLMVisionModels().catch((err) => {
      console.log('預加載LLM Vision模型失敗:', err);
    });
  }

  /**
   * 清除所有快取
   */
  clearCache() {
    // 清除AIM模型快取
    this.aimModelsCache = null;
    this.aimLastFetchTime = null;
    this.aimPendingRequest = null;

    // 清除LLM Vision模型快取
    this.llmVisionModelsCache = null;
    this.llmVisionLastFetchTime = null;
    this.llmVisionPendingRequest = null;

    // 清除AIM欄位資訊快取
    this.aimFieldInfoCache.clear();
    this.aimFieldInfoLastFetchTime.clear();
    this.aimFieldInfoPendingRequests.clear();

    console.log('AIM和LLM Vision模型快取已清除');
  }

  /**
   * 只清除AIM模型快取
   */
  clearAIMCache() {
    this.aimModelsCache = null;
    this.aimLastFetchTime = null;
    this.aimPendingRequest = null;
    console.log('AIM模型快取已清除');
  }

  /**
   * 只清除LLM Vision模型快取
   */
  clearLLMVisionCache() {
    this.llmVisionModelsCache = null;
    this.llmVisionLastFetchTime = null;
    this.llmVisionPendingRequest = null;
    console.log('LLM Vision模型快取已清除');
  }

  /**
   * 只清除AIM欄位資訊快取
   */
  clearAIMFieldInfoCache() {
    this.aimFieldInfoCache.clear();
    this.aimFieldInfoLastFetchTime.clear();
    this.aimFieldInfoPendingRequests.clear();
    console.log('AIM欄位資訊快取已清除');
  }

  /**
   * 清除特定 training_id 的AIM欄位資訊快取
   * @param {number} trainingId - 要清除的 training_id
   */
  clearAIMFieldInfoCacheById(trainingId) {
    const trainingIdStr = trainingId.toString();
    this.aimFieldInfoCache.delete(trainingIdStr);
    this.aimFieldInfoLastFetchTime.delete(trainingIdStr);
    this.aimFieldInfoPendingRequests.delete(trainingIdStr);
    console.log(`AIM欄位資訊快取已清除 (training_id: ${trainingId})`);
  }
}

/**
 * Schedule Trigger 模型服務 - 處理與 Schedule Trigger 相關的API請求
 */
class ScheduleTriggerService {
  constructor() {
    // 時區列表相關快取
    this.timezonesCache = null;
    this.timezonesLastFetchTime = null;

    // 時區地區相關快取
    this.regionsCache = null;
    this.regionsLastFetchTime = null;

    // 預設描述選項相關快取
    this.defaultDescriptionsCache = null;
    this.defaultDescriptionsLastFetchTime = null;

    // 預設調度設定相關快取
    this.defaultScheduleConfigsCache = null;
    this.defaultScheduleConfigsLastFetchTime = null;

    // 特定時區詳細資訊快取
    this.timezoneDetailsCache = new Map(); // 使用 Map 以 timezone_id 為 key
    this.timezoneDetailsLastFetchTime = new Map(); // 每個 timezone_id 的最後獲取時間

    this.cacheExpiryTime = 10 * 60 * 1000; // 10分鐘cache過期

    // 追蹤進行中的請求，避免重複請求
    this.timezonesPendingRequest = null;
    this.regionsPendingRequest = null;
    this.defaultDescriptionsPendingRequest = null;
    this.defaultScheduleConfigsPendingRequest = null;
    this.timezoneDetailsPendingRequests = new Map(); // 追蹤進行中的時區詳細資訊請求
  }

  /**
   * 生成 schedule node 設定 - 將自然語言時間描述轉換為標準調度配置 JSON
   * @param {Object} requestData - 請求數據
   * @param {string} requestData.current_date - 當前日期 (格式: YYYY-MM-DD)
   * @param {number} requestData.llm_id - LLM 模型 ID
   * @param {string} requestData.task_description - 任務描述
   * @param {string} requestData.timezone - 時區 (例: Asia/Taipei)
   * @param {string} requestData.user_input - 用戶自然語言輸入
   * @returns {Promise<Object>} 調度配置結果
   */
  async generateScheduleTime(requestData) {
    try {
      console.log('生成 schedule 時間配置，請求數據:', requestData);

      // 驗證必要參數
      const requiredFields = [
        'current_date',
        'llm_id',
        'task_description',
        'timezone',
        'user_input'
      ];
      for (const field of requiredFields) {
        if (!requestData[field]) {
          throw new Error(`缺少必要參數: ${field}`);
        }
      }

      const options = tokenService.createAuthHeader({
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        },
        body: JSON.stringify(requestData)
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(
            `嘗試生成 schedule 時間配置，第 ${retryCount + 1} 次嘗試`
          );

          const url = tokenService.createUrlWithWorkspace(
            `${API_CONFIG.BASE_URL}/agent_designer/ai/schedule-time-generator`
          );

          const response = await fetch(url, options);

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          const data = await response.json();
          console.log('API返回 schedule 時間配置結果:', data);

          // 檢查 API 回應格式
          if (!data.success) {
            throw new Error(`API 回應失敗: ${data.error || '未知錯誤'}`);
          }

          return data;
        } catch (error) {
          console.error(`第 ${retryCount + 1} 次嘗試失敗:`, error);

          // 如果還有重試次數，進行重試
          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          // 所有重試都失敗，拋出錯誤
          throw error;
        }
      };

      return await attemptFetch();
    } catch (error) {
      console.error('生成 schedule 時間配置過程中出錯:', error);
      throw error;
    }
  }

  /**
   * 獲取時區列表
   * @param {Object} params - 查詢參數
   * @param {string} params.region - 篩選特定地區的時區 (可選)
   * @param {string} params.search - 搜尋時區名稱或城市名稱 (可選)
   * @param {string} params.format - 回應格式: simple 或 detailed (預設: detailed)
   * @returns {Promise<Object>} 時區列表
   */
  async getTimezonesList(params = {}) {
    try {
      const { region, search, format = 'detailed' } = params;

      // 為快取創建唯一鍵
      const cacheKey = JSON.stringify({ region, search, format });

      // 檢查是否有有效的快取
      const now = Date.now();
      if (
        this.timezonesCache &&
        this.timezonesCache[cacheKey] &&
        this.timezonesLastFetchTime &&
        this.timezonesLastFetchTime[cacheKey] &&
        now - this.timezonesLastFetchTime[cacheKey] < this.cacheExpiryTime
      ) {
        console.log('使用快取的時區列表', params);
        return this.timezonesCache[cacheKey];
      }

      // 如果已經有相同參數的請求在進行中，則返回該請求
      if (
        this.timezonesPendingRequest &&
        this.timezonesPendingRequest[cacheKey]
      ) {
        console.log('已有進行中的時區列表請求，使用相同請求', params);
        return this.timezonesPendingRequest[cacheKey];
      }

      console.log('獲取時區列表...', params);

      // 構建查詢參數
      const queryParams = new URLSearchParams();
      if (region) queryParams.append('region', region);
      if (search) queryParams.append('search', search);
      queryParams.append('format', format);

      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(`嘗試獲取時區列表，第 ${retryCount + 1} 次嘗試`);

          const url = tokenService.createUrlWithWorkspace(
            `${
              API_CONFIG.BASE_URL
            }/agent_designer/schedule_node/timezone/list?${queryParams.toString()}`
          );

          const response = await fetch(url, options);

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          const data = await response.json();
          console.log('API返回時區列表數據:', data);

          // 檢查 API 回應格式
          if (!data.success) {
            throw new Error(`API 回應失敗: ${data.error || '未知錯誤'}`);
          }

          return data;
        } catch (error) {
          console.error(`第 ${retryCount + 1} 次嘗試失敗:`, error);

          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          throw error;
        }
      };

      // 初始化快取和進行中請求的結構
      if (!this.timezonesPendingRequest) {
        this.timezonesPendingRequest = {};
      }

      const pendingRequest = attemptFetch()
        .then((data) => {
          // 更新快取
          if (!this.timezonesCache) {
            this.timezonesCache = {};
          }
          if (!this.timezonesLastFetchTime) {
            this.timezonesLastFetchTime = {};
          }

          this.timezonesCache[cacheKey] = data;
          this.timezonesLastFetchTime[cacheKey] = now;
          delete this.timezonesPendingRequest[cacheKey]; // 清除進行中的請求

          return data;
        })
        .catch((error) => {
          console.error('獲取時區列表過程中發生意外錯誤:', error);
          if (this.timezonesPendingRequest) {
            delete this.timezonesPendingRequest[cacheKey];
          }
          throw error;
        });

      // 記錄進行中的請求
      this.timezonesPendingRequest[cacheKey] = pendingRequest;

      return pendingRequest;
    } catch (error) {
      console.error('獲取時區列表過程中出錯:', error);
      throw error;
    }
  }

  /**
   * 獲取所有可用的時區地區列表
   * @returns {Promise<Object>} 時區地區列表
   */
  async getTimezoneRegions() {
    try {
      // 檢查是否有有效的快取
      const now = Date.now();
      if (
        this.regionsCache &&
        this.regionsLastFetchTime &&
        now - this.regionsLastFetchTime < this.cacheExpiryTime
      ) {
        console.log('使用快取的時區地區列表');
        return this.regionsCache;
      }

      // 如果已經有一個請求在進行中，則返回該請求
      if (this.regionsPendingRequest) {
        console.log('已有進行中的時區地區請求，使用相同請求');
        return this.regionsPendingRequest;
      }

      console.log('獲取時區地區列表...');
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(`嘗試獲取時區地區列表，第 ${retryCount + 1} 次嘗試`);

          const url = tokenService.createUrlWithWorkspace(
            `${API_CONFIG.BASE_URL}/agent_designer/schedule_node/timezone/regions`
          );

          const response = await fetch(url, options);

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          const data = await response.json();
          console.log('API返回時區地區數據:', data);

          // 檢查 API 回應格式
          if (!data.success) {
            throw new Error(`API 回應失敗: ${data.error || '未知錯誤'}`);
          }

          return data;
        } catch (error) {
          console.error(`第 ${retryCount + 1} 次嘗試失敗:`, error);

          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          throw error;
        }
      };

      this.regionsPendingRequest = attemptFetch()
        .then((data) => {
          // 更新快取
          this.regionsCache = data;
          this.regionsLastFetchTime = now;
          this.regionsPendingRequest = null; // 清除進行中的請求

          return data;
        })
        .catch((error) => {
          console.error('獲取時區地區列表過程中發生意外錯誤:', error);
          this.regionsPendingRequest = null; // 清除進行中的請求，即使出錯
          throw error;
        });

      return this.regionsPendingRequest;
    } catch (error) {
      console.error('獲取時區地區列表過程中出錯:', error);
      this.regionsPendingRequest = null;
      throw error;
    }
  }

  /**
   * 根據時區 ID 獲取特定時區的詳細資訊
   * @param {string} timezoneId - 時區 ID (例: Asia/Taipei)
   * @returns {Promise<Object>} 時區詳細資訊
   */
  async getTimezoneDetails(timezoneId) {
    try {
      // 驗證 timezoneId
      if (!timezoneId) {
        throw new Error('時區 ID 不能為空');
      }

      // 檢查是否有有效的快取
      const now = Date.now();
      const lastFetchTime = this.timezoneDetailsLastFetchTime.get(timezoneId);
      const cachedData = this.timezoneDetailsCache.get(timezoneId);

      if (
        cachedData &&
        lastFetchTime &&
        now - lastFetchTime < this.cacheExpiryTime
      ) {
        console.log(`使用快取的時區詳細資訊 (timezone_id: ${timezoneId})`);
        return cachedData;
      }

      // 如果已經有相同 timezone_id 的請求在進行中，則返回該請求
      if (this.timezoneDetailsPendingRequests.has(timezoneId)) {
        console.log(
          `已有進行中的時區詳細資訊請求 (timezone_id: ${timezoneId})，使用相同請求`
        );
        return this.timezoneDetailsPendingRequests.get(timezoneId);
      }

      console.log(`獲取時區詳細資訊 (timezone_id: ${timezoneId})...`);
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(
            `嘗試獲取時區詳細資訊，第 ${
              retryCount + 1
            } 次嘗試 (timezone_id: ${timezoneId})`
          );

          // URL encode timezone_id，因為它可能包含特殊字符如 '/'
          const encodedTimezoneId = encodeURIComponent(timezoneId);
          const url = tokenService.createUrlWithWorkspace(
            `${API_CONFIG.BASE_URL}/agent_designer/schedule_node/timezone/${encodedTimezoneId}`
          );

          const response = await fetch(url, options);

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          const data = await response.json();
          console.log(
            `API返回時區詳細資訊 (timezone_id: ${timezoneId}):`,
            data
          );

          // 檢查 API 回應格式
          if (!data.success) {
            throw new Error(`API 回應失敗: ${data.error || '未知錯誤'}`);
          }

          return data;
        } catch (error) {
          console.error(
            `第 ${retryCount + 1} 次嘗試失敗 (timezone_id: ${timezoneId}):`,
            error
          );

          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          throw error;
        }
      };

      const pendingRequest = attemptFetch()
        .then((data) => {
          // 更新快取
          this.timezoneDetailsCache.set(timezoneId, data);
          this.timezoneDetailsLastFetchTime.set(timezoneId, now);
          this.timezoneDetailsPendingRequests.delete(timezoneId); // 清除進行中的請求

          return data;
        })
        .catch((error) => {
          console.error(
            `獲取時區詳細資訊過程中發生意外錯誤 (timezone_id: ${timezoneId}):`,
            error
          );
          this.timezoneDetailsPendingRequests.delete(timezoneId); // 清除進行中的請求，即使出錯
          throw error;
        });

      // 記錄進行中的請求
      this.timezoneDetailsPendingRequests.set(timezoneId, pendingRequest);

      return pendingRequest;
    } catch (error) {
      console.error(
        `獲取時區詳細資訊過程中出錯 (timezone_id: ${timezoneId}):`,
        error
      );
      this.timezoneDetailsPendingRequests.delete(timezoneId);
      throw error;
    }
  }

  /**
   * 獲取調度時間產生器的預設描述選項
   * @returns {Promise<Object>} 預設描述選項列表
   */
  async getDefaultDescriptions() {
    try {
      // 檢查是否有有效的快取
      const now = Date.now();
      if (
        this.defaultDescriptionsCache &&
        this.defaultDescriptionsLastFetchTime &&
        now - this.defaultDescriptionsLastFetchTime < this.cacheExpiryTime
      ) {
        console.log('使用快取的預設描述選項');
        return this.defaultDescriptionsCache;
      }

      // 如果已經有一個請求在進行中，則返回該請求
      if (this.defaultDescriptionsPendingRequest) {
        console.log('已有進行中的預設描述選項請求，使用相同請求');
        return this.defaultDescriptionsPendingRequest;
      }

      console.log('獲取預設描述選項...');
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(`嘗試獲取預設描述選項，第 ${retryCount + 1} 次嘗試`);

          const url = tokenService.createUrlWithWorkspace(
            `${API_CONFIG.BASE_URL}/agent_designer/schedule_node/schedule_time_generator_default_description`
          );

          const response = await fetch(url, options);

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          const data = await response.json();
          console.log('API返回預設描述選項數據:', data);

          // 檢查 API 回應格式
          if (!data.success) {
            throw new Error(`API 回應失敗: ${data.error || '未知錯誤'}`);
          }

          return data;
        } catch (error) {
          console.error(`第 ${retryCount + 1} 次嘗試失敗:`, error);

          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          throw error;
        }
      };

      this.defaultDescriptionsPendingRequest = attemptFetch()
        .then((data) => {
          // 更新快取
          this.defaultDescriptionsCache = data;
          this.defaultDescriptionsLastFetchTime = now;
          this.defaultDescriptionsPendingRequest = null; // 清除進行中的請求

          return data;
        })
        .catch((error) => {
          console.error('獲取預設描述選項過程中發生意外錯誤:', error);
          this.defaultDescriptionsPendingRequest = null; // 清除進行中的請求，即使出錯
          throw error;
        });

      return this.defaultDescriptionsPendingRequest;
    } catch (error) {
      console.error('獲取預設描述選項過程中出錯:', error);
      this.defaultDescriptionsPendingRequest = null;
      throw error;
    }
  }

  /**
   * 獲取預設的調度設定選項列表
   * @returns {Promise<Object>} 預設調度設定選項列表
   */
  async getDefaultScheduleConfigs() {
    try {
      // 檢查是否有有效的快取
      const now = Date.now();
      if (
        this.defaultScheduleConfigsCache &&
        this.defaultScheduleConfigsLastFetchTime &&
        now - this.defaultScheduleConfigsLastFetchTime < this.cacheExpiryTime
      ) {
        console.log('使用快取的預設調度設定選項');
        return this.defaultScheduleConfigsCache;
      }

      // 如果已經有一個請求在進行中，則返回該請求
      if (this.defaultScheduleConfigsPendingRequest) {
        console.log('已有進行中的預設調度設定選項請求，使用相同請求');
        return this.defaultScheduleConfigsPendingRequest;
      }

      console.log('獲取預設調度設定選項...');
      const options = tokenService.createAuthHeader({
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        }
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(`嘗試獲取預設調度設定選項，第 ${retryCount + 1} 次嘗試`);

          const url = tokenService.createUrlWithWorkspace(
            `${API_CONFIG.BASE_URL}/agent_designer/schedule_node/default_schedule_configs`
          );

          const response = await fetch(url, options);

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          const data = await response.json();
          console.log('API返回預設調度設定選項數據:', data);

          // 檢查 API 回應格式
          if (!data.success) {
            throw new Error(`API 回應失敗: ${data.error || '未知錯誤'}`);
          }

          return data;
        } catch (error) {
          console.error(`第 ${retryCount + 1} 次嘗試失敗:`, error);

          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          throw error;
        }
      };

      this.defaultScheduleConfigsPendingRequest = attemptFetch()
        .then((data) => {
          // 更新快取
          this.defaultScheduleConfigsCache = data;
          this.defaultScheduleConfigsLastFetchTime = now;
          this.defaultScheduleConfigsPendingRequest = null; // 清除進行中的請求

          return data;
        })
        .catch((error) => {
          console.error('獲取預設調度設定選項過程中發生意外錯誤:', error);
          this.defaultScheduleConfigsPendingRequest = null; // 清除進行中的請求，即使出錯
          throw error;
        });

      return this.defaultScheduleConfigsPendingRequest;
    } catch (error) {
      console.error('獲取預設調度設定選項過程中出錯:', error);
      this.defaultScheduleConfigsPendingRequest = null;
      throw error;
    }
  }

  /**
   * 啟用或停用 schedule node
   * @param {string} scheduleNodeId - Schedule Node ID
   * @param {Object} requestData - 請求數據
   * @param {boolean} requestData.enabled - 是否啟用
   * @param {string} requestData.flow_id - Flow ID
   * @returns {Promise<Object>} 更新結果
   */
  async toggleScheduleNode(scheduleNodeId, requestData) {
    try {
      // 驗證參數
      if (!scheduleNodeId) {
        throw new Error('Schedule Node ID 不能為空');
      }

      if (typeof requestData.enabled !== 'boolean') {
        throw new Error('enabled 參數必須是布林值');
      }

      if (!requestData.flow_id) {
        throw new Error('flow_id 不能為空');
      }

      console.log(
        `切換 schedule node 狀態 (id: ${scheduleNodeId})，請求數據:`,
        requestData
      );

      const options = tokenService.createAuthHeader({
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json'
        },
        body: JSON.stringify(requestData)
      });

      // 定義重試邏輯的函數
      const attemptFetch = async (retryCount = 0) => {
        try {
          console.log(
            `嘗試切換 schedule node 狀態，第 ${
              retryCount + 1
            } 次嘗試 (id: ${scheduleNodeId})`
          );

          const url = tokenService.createUrlWithWorkspace(
            `${API_CONFIG.BASE_URL}/agent_designer/schedule_node/${scheduleNodeId}/toggle`
          );

          const response = await fetch(url, options);

          if (!response.ok) {
            throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
          }

          const data = await response.json();
          console.log(
            `API返回 schedule node 切換結果 (id: ${scheduleNodeId}):`,
            data
          );

          return data;
        } catch (error) {
          console.error(
            `第 ${retryCount + 1} 次嘗試失敗 (id: ${scheduleNodeId}):`,
            error
          );

          if (retryCount < 2) {
            console.log(`準備進行第 ${retryCount + 2} 次重試...`);
            await new Promise((resolve) =>
              setTimeout(resolve, 1000 * (retryCount + 1))
            );
            return attemptFetch(retryCount + 1);
          }

          throw error;
        }
      };

      return await attemptFetch();
    } catch (error) {
      console.error(
        `切換 schedule node 狀態過程中出錯 (id: ${scheduleNodeId}):`,
        error
      );
      throw error;
    }
  }

  /**
   * 獲取格式化後的時區選項，適用於下拉選單
   * @param {Object} params - 查詢參數 (同 getTimezonesList)
   * @returns {Promise<Array>} 格式化的時區選項
   */
  async getTimezoneOptions(params = {}) {
    try {
      const response = await this.getTimezonesList({
        ...params,
        format: 'detailed'
      });
      console.log('API返回的時區數據:', response);

      // 檢查數據是否有效
      if (
        !response.success ||
        !response.data ||
        !Array.isArray(response.data.timezones)
      ) {
        console.warn('時區數據無效或不是陣列，返回空陣列');
        return [];
      }

      const timezones = response.data.timezones;

      if (timezones.length === 0) {
        console.warn('API返回的時區陣列為空，返回空陣列');
        return [];
      }

      // 將API返回的時區數據轉換為select選項格式
      const options = timezones
        .map((timezone, index) => {
          // 確保時區對象存在
          if (!timezone) {
            console.warn(`遇到無效的時區數據，索引: ${index}，跳過該時區`);
            return null;
          }

          // 使用 id 作為 value，display_name 作為 label
          const timezoneValue = timezone.id;
          const timezoneLabel = timezone.display_name;

          // 如果缺少必要欄位，跳過該時區
          if (!timezoneValue || !timezoneLabel) {
            console.warn(`時區 ${index} 缺少必要欄位，跳過該時區`);
            return null;
          }

          return {
            value: timezoneValue,
            label: timezoneLabel,
            region: timezone.region,
            country: timezone.country,
            utc_offset: timezone.utc_offset,
            description: timezone.description
          };
        })
        .filter((option) => option !== null); // 過濾掉無效選項

      return options;
    } catch (error) {
      console.error('獲取時區選項失敗:', error);
      return [];
    }
  }

  /**
   * 獲取格式化後的預設描述選項，適用於下拉選單或建議列表
   * @returns {Promise<Array>} 格式化的預設描述選項
   */
  async getDefaultDescriptionOptions() {
    try {
      const response = await this.getDefaultDescriptions();
      console.log('API返回的預設描述數據:', response);

      // 檢查數據是否有效
      if (
        !response.success ||
        !response.data ||
        !Array.isArray(response.data.descriptions)
      ) {
        console.warn('預設描述數據無效或不是陣列，返回空陣列');
        return [];
      }

      const descriptions = response.data.descriptions;

      if (descriptions.length === 0) {
        console.warn('API返回的預設描述陣列為空，返回空陣列');
        return [];
      }

      // 將API返回的描述數據轉換為選項格式
      const options = descriptions
        .map((description, index) => {
          // 確保描述是字串
          if (typeof description !== 'string' || !description.trim()) {
            console.warn(`遇到無效的預設描述，索引: ${index}，跳過該描述`);
            return null;
          }

          return {
            value: description,
            label: description,
            index: index
          };
        })
        .filter((option) => option !== null); // 過濾掉無效選項

      console.log('最終格式化的預設描述選項:', options);
      return options;
    } catch (error) {
      console.error('獲取預設描述選項失敗:', error);
      return [];
    }
  }

  /**
   * 獲取格式化後的預設調度設定選項，適用於下拉選單
   * @returns {Promise<Array>} 格式化的預設調度設定選項
   */
  async getDefaultScheduleConfigOptions() {
    try {
      const response = await this.getDefaultScheduleConfigs();
      console.log('API返回的預設調度設定數據:', response);

      // 檢查數據是否有效
      if (
        !response.success ||
        !response.data ||
        !Array.isArray(response.data.schedule_configs)
      ) {
        console.warn('預設調度設定數據無效或不是陣列，返回空陣列');
        return [];
      }

      const scheduleConfigs = response.data.schedule_configs;

      if (scheduleConfigs.length === 0) {
        console.warn('API返回的預設調度設定陣列為空，返回空陣列');
        return [];
      }

      // 將API返回的調度設定數據轉換為選項格式
      const options = scheduleConfigs
        .map((config, index) => {
          // 確保調度設定對象存在且包含必要欄位
          if (!config || !config.value || !config.label) {
            console.warn(`遇到無效的預設調度設定，索引: ${index}，跳過該設定`);
            return null;
          }

          return {
            value: config.value,
            label: config.label,
            description: config.description || '',
            cronExpression: config.cron_expression || '',
            index: index
          };
        })
        .filter((option) => option !== null); // 過濾掉無效選項

      console.log('最終格式化的預設調度設定選項:', options);
      return options;
    } catch (error) {
      console.error('獲取預設調度設定選項失敗:', error);
      return [];
    }
  }

  /**
   * 預加載所有常用數據，通常在應用啟動時呼叫
   */
  preloadData() {
    console.log('預加載 Schedule Trigger 相關數據');

    // 預加載時區地區列表
    this.getTimezoneRegions().catch((err) => {
      console.log('預加載時區地區列表失敗:', err);
    });

    // 預加載預設描述選項
    this.getDefaultDescriptions().catch((err) => {
      console.log('預加載預設描述選項失敗:', err);
    });

    // 預加載預設調度設定選項
    this.getDefaultScheduleConfigs().catch((err) => {
      console.log('預加載預設調度設定選項失敗:', err);
    });

    // 預加載常用時區列表 (亞洲地區)
    this.getTimezonesList({ region: 'Asia', format: 'detailed' }).catch(
      (err) => {
        console.log('預加載亞洲時區列表失敗:', err);
      }
    );
  }

  /**
   * 清除所有快取
   */
  clearCache() {
    // 清除時區相關快取
    this.timezonesCache = null;
    this.timezonesLastFetchTime = null;
    this.timezonesPendingRequest = null;

    // 清除地區快取
    this.regionsCache = null;
    this.regionsLastFetchTime = null;
    this.regionsPendingRequest = null;

    // 清除預設描述快取
    this.defaultDescriptionsCache = null;
    this.defaultDescriptionsLastFetchTime = null;
    this.defaultDescriptionsPendingRequest = null;

    // 清除預設調度設定快取
    this.defaultScheduleConfigsCache = null;
    this.defaultScheduleConfigsLastFetchTime = null;
    this.defaultScheduleConfigsPendingRequest = null;

    // 清除時區詳細資訊快取
    this.timezoneDetailsCache.clear();
    this.timezoneDetailsLastFetchTime.clear();
    this.timezoneDetailsPendingRequests.clear();

    console.log('Schedule Trigger 服務快取已清除');
  }

  /**
   * 只清除時區相關快取
   */
  clearTimezoneCache() {
    this.timezonesCache = null;
    this.timezonesLastFetchTime = null;
    this.timezonesPendingRequest = null;

    this.timezoneDetailsCache.clear();
    this.timezoneDetailsLastFetchTime.clear();
    this.timezoneDetailsPendingRequests.clear();

    console.log('時區相關快取已清除');
  }

  /**
   * 只清除地區快取
   */
  clearRegionCache() {
    this.regionsCache = null;
    this.regionsLastFetchTime = null;
    this.regionsPendingRequest = null;
    console.log('時區地區快取已清除');
  }

  /**
   * 只清除預設描述快取
   */
  clearDefaultDescriptionsCache() {
    this.defaultDescriptionsCache = null;
    this.defaultDescriptionsLastFetchTime = null;
    this.defaultDescriptionsPendingRequest = null;
    console.log('預設描述選項快取已清除');
  }

  /**
   * 只清除預設調度設定快取
   */
  clearDefaultScheduleConfigsCache() {
    this.defaultScheduleConfigsCache = null;
    this.defaultScheduleConfigsLastFetchTime = null;
    this.defaultScheduleConfigsPendingRequest = null;
    console.log('預設調度設定選項快取已清除');
  }

  /**
   * 清除特定時區的詳細資訊快取
   * @param {string} timezoneId - 要清除的時區 ID
   */
  clearTimezoneDetailsCacheById(timezoneId) {
    this.timezoneDetailsCache.delete(timezoneId);
    this.timezoneDetailsLastFetchTime.delete(timezoneId);
    this.timezoneDetailsPendingRequests.delete(timezoneId);
    console.log(`時區詳細資訊快取已清除 (timezone_id: ${timezoneId})`);
  }
}

// 創建並導出單例實例
const scheduleTriggerService = new ScheduleTriggerService();

// services/WebhookService.js

class WebhookService {
  /**
   * 創建 Webhook URL
   * @param {string} flowId - Flow ID
   * @param {string} webhookInputNodeId - Webhook Input Node ID
   * @returns {Promise<Object>} - 包含 curl_example 的回應
   */
  static async createWebhookUrl(flowId, webhookInputNodeId) {
    try {
      console.log(
        `創建 Webhook URL: flowId=${flowId}, nodeId=${webhookInputNodeId}`
      );

      // 構建完整的 API URL
      const apiUrl = `${API_CONFIG.BASE_URL}/agent_designer/webhook/url/${flowId}/${webhookInputNodeId}`;

      // 創建帶有 workspace_id 的 URL
      // const urlWithWorkspace = tokenService.createUrlWithWorkspace(apiUrl);

      const response = await fetch(apiUrl, {
        method: 'GET',
        ...tokenService.createAuthHeader({
          headers: {
            'Content-Type': 'application/json'
          }
        })
      });

      const data = await response.json();

      console.log('Webhook URL 創建成功:', data);

      // 檢查回應格式
      if (
        data.success &&
        data.status === 'COMPLETED' &&
        data.data?.curl_example
      ) {
        return {
          success: true,
          curl_example: data.data.curl_example,
          webhook_url: data.data.webhook_url,
          'X-QOCA-Agent-Api-Key': data.data['X-QOCA-Agent-Api-Key']
        };
      } else {
        throw new Error('回應格式不正確或缺少 curl_example');
      }
    } catch (error) {
      console.error('創建 Webhook URL 失敗:', error);
      throw new Error(`創建 Webhook 失敗: ${error.message}`);
    }
  }

  /**
   * 創建 Webhook URL (實例方法)
   * @param {string} flowId - Flow ID
   * @param {string} webhookInputNodeId - Webhook Input Node ID
   * @returns {Promise<Object>} - 包含 curl_example 的回應
   */
  async createWebhook(flowId, webhookInputNodeId) {
    return WebhookService.createWebhookUrl(flowId, webhookInputNodeId);
  }
}

// 主要導出文件 - 集中管理所有服務和工具類的導出


// 創建單例實例
const workflowAPIService = new WorkflowAPIService();
const llmService = new LLMService();
const externalService = new ExternalService();
const iconUploadService = new IconUploadService();
const aimService = new AIMService();

/**
 * Prompt 生成器 API 服務
 */
class PromptGeneratorService {
  /**
   * 生成優化的 Prompt
   * @param {number} llmId - LLM 模型 ID
   * @param {string} originalPrompt - 原始 Prompt
   * @returns {Promise<Object>} API 回應
   */
  static async generateOptimizedPrompt(llmId, originalPrompt) {
    try {
      const options = tokenService.createAuthHeader({
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          llm_id: llmId,
          prompt: originalPrompt
        })
      });
      const url = tokenService.createUrlWithWorkspace(
        `${API_CONFIG.BASE_URL}/agent_designer/ai/prompt-generator`
      );
      const response = await fetch(url, options);

      if (!response.ok) {
        throw new Error(`HTTP 錯誤! 狀態: ${response.status}`);
      }

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error || '生成優化 Prompt 失敗');
      }
      return data;
    } catch (error) {
      console.error('生成優化 Prompt 失敗:', error);
      throw error;
    }
  }

  /**
   * 驗證 Prompt 生成器的參數
   * @param {number} llmId - LLM 模型 ID
   * @param {string} prompt - Prompt 文字
   * @returns {Object} 驗證結果
   */
  static validateParameters(llmId, prompt) {
    const errors = [];

    // 驗證 LLM ID
    if (!llmId || typeof llmId !== 'number') {
      errors.push('LLM ID 必須是有效的數字');
    }

    // 驗證 Prompt
    if (!prompt || typeof prompt !== 'string' || prompt.trim().length === 0) {
      errors.push('Prompt 不能為空');
    }

    // if (prompt && prompt.length < 5) {
    //   errors.push('Prompt 長度至少需要 5 個字符');
    // }

    // if (prompt && prompt.length > 10000) {
    //   errors.push('Prompt 長度不能超過 10000 個字符');
    // }

    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

const InsertIcon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwBAMAAAClLOS0AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAASUExURUdwTP///////////////////4gZPH8AAAAFdFJOUwCAGe/X/ZSAIQAAAGtJREFUOMtjYBgBQDQUDQRCJUIxACEdgwioKGDxoACIJwCXQHgggIGBydUIuw5GXN5TDg1WwCauaBoaaqiAXTw01BFTxhVilwOmDrAMLrPg4ijORXYVigeR/YGig8nUCVfSECAcuqNJdPAAAF0aRLwMTRusAAAAAElFTkSuQmCC";

const CopytIncon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAMAAABg3Am1AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAACEUExURUdwTHfO6EHP3jLP2ljP40nP32jO5RrP1yjP2jXP3CvO2RTO1UbP4AnP03/O6TLO20vP4FrP4nvO6n3N6X3O6nzO6H/N6X7O6X/N6knO4E/O4TbO3ETO31XO4jDP2yHO2D/O3hjO1inO2TvO3V/O5FrO4w/P1GTO5W3O5nLO6GjO5XnO6Z7gXIcAAAAZdFJOUwCA22B/IYB//n/ds5nl33DvRe9ov7+v35/+eYC1AAABqUlEQVRIx83W2ZqCIBQA4EZzwk+darZvUkPFNJf3f79hOUCyaJdxzd9ZOEK73auuKA3y/Hq9dt3tdr/fp2kYhnEc5/nz+8u1P75c8twt5vkjsveX5YUTEDchRp+I6tIlJiV+DZC2dc3FKd2L9Q7rDZYBAgqoOIXPtqhoW0qC6OmeFlTI/efj3pnWOVoAKng+4UlV3sleye7+aYKpCER7Xd21zwPjok3Y79flutAA45h1y30eAydMyCkhApxp6eVqjB8JEAdH3l1byDGhkygBIQzE/Dw8UyKEBoQDdh5GjGV3AVQIASjsrGDchZCgIuRAAS5cMR4rV6ASYFNoUAmAIStfdwE0ABBejzEp0HBwIGRDaNAAeBDOrDRoOEBbwgAVIRtZAeglQHStxpCgB1AtYjgmUYFeglXRSZBRwUBjCqsOAIkEmwLAUQEQyCd2OicAXCDvCarbOFOgWa1c398JA71H6BjLG/PQa4HclVvgMYar8iUI+x4IxDC/jzwwHiK531t5alz7iQrhEdZbl/kFyyq2X2tTiC8KCxG7HqMwyYwYUHmQRi/7r+QfNo2tdAXm1y8AAAAASUVORK5CYII=";

const React$q = await importShared('react');
const {useState: useState$p,useEffect: useEffect$j,useRef: useRef$f} = React$q;
const ScrollableTextArea = ({ children, className }) => {
  const scrollRef = useRef$f(null);
  const [isFocused, setIsFocused] = useState$p(false);
  useEffect$j(() => {
    const scrollArea = scrollRef.current;
    if (!scrollArea) return;
    const handleFocus = () => setIsFocused(true);
    const handleBlur = () => setIsFocused(false);
    scrollArea.addEventListener("focus", handleFocus, true);
    scrollArea.addEventListener("blur", handleBlur, true);
    return () => {
      scrollArea.removeEventListener("focus", handleFocus, true);
      scrollArea.removeEventListener("blur", handleBlur, true);
    };
  }, []);
  useEffect$j(() => {
    const scrollArea = scrollRef.current;
    if (!scrollArea) return;
    const handleWheelCapture = (e) => {
      if (scrollArea.contains(e.target)) {
        e.stopPropagation();
        const isAtTop = scrollArea.scrollTop <= 0;
        const isAtBottom = Math.abs(
          scrollArea.scrollTop + scrollArea.clientHeight - scrollArea.scrollHeight
        ) <= 1;
        if (isAtTop && e.deltaY < 0 || isAtBottom && e.deltaY > 0) {
          e.preventDefault();
        }
      }
    };
    const preventZoom = (e) => {
      if ((e.ctrlKey || e.metaKey) && scrollArea.contains(e.target)) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    document.addEventListener("wheel", handleWheelCapture, {
      passive: false,
      capture: true
    });
    document.addEventListener("wheel", preventZoom, {
      passive: false,
      capture: true
    });
    return () => {
      document.removeEventListener("wheel", handleWheelCapture, {
        passive: false,
        capture: true
      });
      document.removeEventListener("wheel", preventZoom, {
        passive: false,
        capture: true
      });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: scrollRef,
      className,
      tabIndex: 0,
      children
    }
  );
};
const SelectableTextArea = ({ children, className }) => {
  const scrollRef = useRef$f(null);
  useEffect$j(() => {
    const scrollArea = scrollRef.current;
    if (!scrollArea) return;
    const handleWheelCapture = (e) => {
      if (scrollArea.contains(e.target)) {
        e.stopPropagation();
        const isAtTop = scrollArea.scrollTop <= 0;
        const isAtBottom = Math.abs(
          scrollArea.scrollTop + scrollArea.clientHeight - scrollArea.scrollHeight
        ) <= 1;
        if (isAtTop && e.deltaY < 0 || isAtBottom && e.deltaY > 0) {
          e.preventDefault();
        }
      }
    };
    const preventZoom = (e) => {
      if ((e.ctrlKey || e.metaKey) && scrollArea.contains(e.target)) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    const handleMouseDown = (e) => {
      if (scrollArea.contains(e.target)) {
        e.stopPropagation();
      }
    };
    const handleMouseMove = (e) => {
      if (scrollArea.contains(e.target) && e.buttons === 1) {
        e.stopPropagation();
      }
    };
    const handleMouseUp = (e) => {
      if (scrollArea.contains(e.target)) {
        e.stopPropagation();
      }
    };
    document.addEventListener("wheel", handleWheelCapture, {
      passive: false,
      capture: true
    });
    document.addEventListener("wheel", preventZoom, {
      passive: false,
      capture: true
    });
    scrollArea.addEventListener("mousedown", handleMouseDown, true);
    scrollArea.addEventListener("mousemove", handleMouseMove, true);
    scrollArea.addEventListener("mouseup", handleMouseUp, true);
    return () => {
      document.removeEventListener("wheel", handleWheelCapture, {
        passive: false,
        capture: true
      });
      document.removeEventListener("wheel", preventZoom, {
        passive: false,
        capture: true
      });
      scrollArea.removeEventListener("mousedown", handleMouseDown, true);
      scrollArea.removeEventListener("mousemove", handleMouseMove, true);
      scrollArea.removeEventListener("mouseup", handleMouseUp, true);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref: scrollRef,
      className,
      children
    }
  );
};
const RefinePromptOverlay = ({
  isOpen,
  onClose,
  originalPrompt,
  llmId,
  onOptimizedPromptApply,
  onOptimizedPromptCopy,
  nodePosition = { x: 0, y: 0 },
  offsetX = 330,
  // 可動態傳入的 X 軸偏移量，默認 330
  offsetY = -200
  // 也讓 Y 軸偏移量可配置，默認 -200
}) => {
  const [isLoading, setIsLoading] = useState$p(false);
  const [optimizedPrompt, setOptimizedPrompt] = useState$p("");
  const [promptExpanded, setPromptExpanded] = useState$p(false);
  const [error, setError] = useState$p(null);
  const [apiResponse, setApiResponse] = useState$p(null);
  const overlayRef = useRef$f(null);
  const lastParamsRef = useRef$f({ prompt: "", llmId: null });
  useEffect$j(() => {
    if (isOpen) {
      const currentParams = { prompt: originalPrompt, llmId };
      const lastParams = lastParamsRef.current;
      if (currentParams.prompt !== lastParams.prompt || currentParams.llmId !== lastParams.llmId) {
        setOptimizedPrompt("");
        setApiResponse(null);
        setError(null);
        lastParamsRef.current = currentParams;
      }
    }
  }, [isOpen, originalPrompt, llmId]);
  const generateOptimizedPrompt = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await PromptGeneratorService.generateOptimizedPrompt(
        llmId,
        originalPrompt
      );
      setOptimizedPrompt(data.optimized_prompt);
      setApiResponse(data);
    } catch (err) {
      console.error("生成優化提示失敗:", err);
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };
  const copyToClipboard = async () => {
    try {
      const selection = window.getSelection();
      let textToCopy = "";
      let copyType = "";
      if (selection && selection.toString().trim()) {
        textToCopy = selection.toString();
        copyType = "選取內容";
      } else {
        textToCopy = optimizedPrompt;
        copyType = "全部內容";
      }
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(textToCopy);
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `已複製${copyType}到剪貼板`,
              type: "success",
              duration: 2e3
            });
          }
          if (onOptimizedPromptCopy) {
            onOptimizedPromptCopy(textToCopy);
          }
          return;
        } catch (clipboardError) {
          console.warn("Clipboard API 失敗，嘗試 fallback:", clipboardError);
        }
      }
      const textArea = document.createElement("textarea");
      textArea.value = textToCopy;
      textArea.style.cssText = "position:fixed;top:0;left:0;opacity:0;pointer-events:none;";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      const successful = document.execCommand("copy");
      document.body.removeChild(textArea);
      if (successful) {
        if (typeof window !== "undefined" && window.notify) {
          window.notify({
            message: `已複製${copyType}到剪貼板`,
            type: "success",
            duration: 2e3
          });
        }
        if (onOptimizedPromptCopy) {
          onOptimizedPromptCopy(textToCopy);
        }
      } else {
        throw new Error("所有複製方法都失敗");
      }
    } catch (error2) {
      console.error("複製失敗:", error2);
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "複製失敗，請手動複製 Prompt",
          type: "error",
          duration: 3e3
        });
      }
    }
  };
  const applyOptimizedPrompt = () => {
    if (onOptimizedPromptApply) {
      onOptimizedPromptApply(optimizedPrompt);
    }
    onClose();
  };
  const handleGeneratePrompt = () => {
    generateOptimizedPrompt();
  };
  const getOriginalPromptDisplayContent = () => {
    if (!originalPrompt) return "";
    if (promptExpanded) {
      return originalPrompt;
    } else {
      const maxChars = 100;
      if (originalPrompt.length <= maxChars) {
        return originalPrompt;
      }
      return originalPrompt.substring(0, maxChars) + "...";
    }
  };
  const shouldShowExpandButton = () => {
    if (!originalPrompt) return false;
    const hasLongContent = originalPrompt.length > 100;
    const hasMultipleLines = originalPrompt.includes("\n");
    return hasLongContent || hasMultipleLines;
  };
  const getOverlayPosition = () => {
    return {
      left: nodePosition.x + offsetX,
      top: Math.max(nodePosition.y + offsetY, 20)
      // 確保不會超出視窗頂部
    };
  };
  const getOverlayHeight = () => {
    const headerHeight = 70;
    const originalPromptHeight = promptExpanded ? 400 : 160;
    const buttonAreaHeight = 80;
    const paddingAndMargins = 40;
    let contentHeight = 200;
    if (optimizedPrompt) {
      contentHeight = Math.max(150, 250);
    }
    const totalHeight = headerHeight + originalPromptHeight + contentHeight + buttonAreaHeight + paddingAndMargins;
    const maxHeight = 800;
    return Math.min(totalHeight, maxHeight);
  };
  if (!isOpen) return null;
  const position = getOverlayPosition();
  const overlayHeight = getOverlayHeight();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed inset-0 z-[9999]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "absolute inset-0 bg-transparent pointer-events-auto",
        onClick: (e) => {
          console.log("背景層被點擊，關閉對話框");
          onClose();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        ref: overlayRef,
        className: "absolute bg-white rounded-lg shadow-xl w-96 flex flex-col pointer-events-auto border border-gray-200 z-10",
        style: {
          left: `${position.left}px`,
          top: `${position.top}px`,
          height: `${overlayHeight}px`,
          maxHeight: "800px"
        },
        onClick: (e) => {
          e.stopPropagation();
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b border-gray-200 rounded-t-lg flex-shrink-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 bg-cyan-100 rounded flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "prompt" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold text-gray-900", children: "Refine Prompt" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: onClose,
                className: "text-gray-400 hover:text-gray-600 transition-colors",
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "svg",
                  {
                    xmlns: "http://www.w3.org/2000/svg",
                    width: "20",
                    height: "20",
                    viewBox: "0 0 24 24",
                    fill: "none",
                    stroke: "currentColor",
                    strokeWidth: "2",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "line",
                        {
                          x1: "18",
                          y1: "6",
                          x2: "6",
                          y2: "18"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "line",
                        {
                          x1: "6",
                          y1: "6",
                          x2: "18",
                          y2: "18"
                        }
                      )
                    ]
                  }
                )
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-b border-gray-100 flex-shrink-0", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "relative flex items-center justify-between mt-2 cursor-pointer transition-colors",
                onClick: () => setPromptExpanded(!promptExpanded),
                children: shouldShowExpandButton() && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    className: `absolute right-7 top-3 w-5 h-5 text-gray-400 transition-transform duration-200 ${promptExpanded ? "rotate-180" : ""}`,
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    xmlns: "http://www.w3.org/2000/svg",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "path",
                      {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        strokeWidth: 2,
                        d: "M19 9l-7 7-7-7"
                      }
                    )
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `overflow-hidden transition-all duration-300 ease-in-out ${promptExpanded ? "max-h-80 opacity-100" : "opacity-100"}`,
                style: {
                  height: promptExpanded ? "auto" : "120px"
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 pb-2 h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ScrollableTextArea,
                  {
                    className: `text-gray-400 text-sm leading-relaxed overflow-y-auto p-3 pl-1 pr-7 ${promptExpanded ? "max-h-64" : "h-full"}`,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "whitespace-pre-wrap font-sans", children: getOriginalPromptDisplayContent() })
                  }
                ) })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 p-4 overflow-hidden flex flex-col min-h-0 justify-center", children: [
            !optimizedPrompt && !isLoading && !error && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center py-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleGeneratePrompt,
                disabled: !originalPrompt || !llmId,
                className: "px-4 py-2 text-white rounded-md bg-[#00ced1] hover:bg-[#00b8bb] disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors",
                children: "優化 Prompt"
              }
            ) }),
            isLoading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center py-8", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-cyan-600" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-3 text-gray-600", children: "正在優化 Prompt..." })
            ] }),
            error && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-red-50 border border-red-200 rounded-md p-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-red-800 text-sm mb-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "錯誤：" }),
                " ",
                error
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: handleGeneratePrompt,
                  className: "px-3 py-1 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors text-sm",
                  children: "重新嘗試"
                }
              )
            ] }),
            optimizedPrompt && !isLoading && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col h-full min-h-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between mb-3 flex-shrink-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-bold text-gray-600", children: "優化後的 Prompt：" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "flex-1 mb-3",
                  style: { minHeight: "150px" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectableTextArea, { className: "h-full border border-gray-200 rounded-md p-3 overflow-y-auto bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "text-sm text-gray-800 whitespace-pre-wrap font-sans leading-relaxed select-text cursor-text", children: optimizedPrompt }) })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2 justify-end flex-shrink-0", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      onClick: applyOptimizedPrompt,
                      className: "px-3 py-1 bg-[#00ced1] hover:bg-[#00b8bb] text-white rounded-md transition-colors text-sm flex items-center space-x-1",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "img",
                          {
                            src: InsertIcon,
                            alt: "Replace Icon",
                            className: "text-white",
                            width: 16,
                            height: 16
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "取代" })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-800 rounded shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-[10000]", children: [
                    "取代",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-800" })
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: copyToClipboard,
                      className: "px-3 py-1  text-white rounded-md transition-colors text-sm flex items-center space-x-1",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "img",
                        {
                          src: CopytIncon,
                          alt: "Copy Icon",
                          className: "text-white",
                          width: 16,
                          height: 16
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-800 rounded shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-[10000]", children: [
                    "複製",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-800" })
                  ] })
                ] })
              ] })
            ] })
          ] })
        ]
      }
    )
  ] });
};

const promptDisabledIcon = "data:image/svg+xml,%3csvg%20width='60'%20height='61'%20viewBox='0%200%2060%2061'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20width='60'%20height='61'%20rx='12'%20fill='%23F5F5F5'/%3e%3cpath%20d='M27.647%2030.324a1.576%201.576%200%200%201%202.248%200l.547.553c.62.63.62%201.649%200%202.277L15.919%2047.861a1.576%201.576%200%200%201-2.248%200l-.547-.553a1.625%201.625%200%200%201%200-2.277l14.523-14.707zM36.141%2017.204c0%20.663-.53%201.201-1.186%201.201a1.194%201.194%200%200%201-1.186-1.2V13.2c0-.663.531-1.201%201.186-1.201.655%200%201.186.538%201.186%201.201v4.003zM30.384%2018.785c.463.47.463%201.23%200%201.699a1.175%201.175%200%200%201-1.677%200l-2.796-2.831a1.212%201.212%200%200%201%200-1.698%201.175%201.175%200%200%201%201.677%200l2.796%202.83zM27.05%2024.81c.654%200%201.185.538%201.185%201.201s-.53%201.201-1.186%201.201h-3.953a1.193%201.193%200%200%201-1.186-1.2c0-.664.531-1.202%201.186-1.202h3.953zM46.814%2024.81c.655%200%201.186.538%201.186%201.201s-.53%201.201-1.186%201.201h-3.953a1.193%201.193%200%200%201-1.186-1.2c0-.664.531-1.202%201.186-1.202h3.953zM42.841%2015.955a1.175%201.175%200%200%201%201.677%200c.463.469.463%201.229%200%201.698l-2.795%202.83a1.175%201.175%200%200%201-1.677%200%201.212%201.212%200%200%201%200-1.698l2.795-2.83zM43.824%2033.197c.463.469.463%201.23%200%201.698a1.175%201.175%200%200%201-1.677%200l-2.795-2.83a1.212%201.212%200%200%201%200-1.699%201.175%201.175%200%200%201%201.677%200l2.795%202.83zM36.141%2038.02c0%20.664-.53%201.202-1.186%201.202a1.194%201.194%200%200%201-1.186-1.201v-4.004c0-.663.531-1.2%201.186-1.2.655%200%201.186.537%201.186%201.2v4.004zM34.745%2021.223a.236.236%200%200%201%20.421%200l1.499%202.953c.022.045.058.081.102.104l2.917%201.517a.242.242%200%200%201%200%20.428l-2.917%201.517a.238.238%200%200%200-.102.104l-1.499%202.953a.236.236%200%200%201-.421%200l-1.499-2.953a.24.24%200%200%200-.102-.104l-2.917-1.517a.242.242%200%200%201%200-.428l2.917-1.517a.24.24%200%200%200%20.102-.104l1.498-2.953z'%20fill='%23D9D9D9'/%3e%3c/svg%3e";

const React$p = await importShared('react');
const {memo: memo$h,useState: useState$o,useEffect: useEffect$i,useCallback: useCallback$i,useRef: useRef$e} = React$p;
const AICustomInputNode = ({ data, isConnectable, id }) => {
  const [modelOptions, setModelOptions] = useState$o([
    { value: "1", label: "O3-mini" },
    { value: "2", label: "O3-plus" },
    { value: "3", label: "O3-mega" },
    { value: "4", label: "O3-ultra" }
  ]);
  const [showRefinePrompt, setShowRefinePrompt] = useState$o(false);
  const edges = useEdges();
  const contextConnectionCount = edges.filter(
    (edge) => edge.target === id && edge.targetHandle === "context-input"
  ).length;
  edges.some(
    (edge) => edge.target === id && edge.targetHandle === "prompt-input"
  );
  const [isLoadingModels, setIsLoadingModels] = useState$o(false);
  const [modelLoadError, setModelLoadError] = useState$o(null);
  const [localModel, setLocalModel] = useState$o(data?.model || "1");
  const [promptText, setPromptText] = useState$o(data?.promptText || "");
  const isComposingRef = useRef$e(false);
  const updateTimeoutRef = useRef$e(null);
  const lastExternalValueRef = useRef$e(data?.promptText || "");
  const isUserInputRef = useRef$e(false);
  useEffect$i(() => {
    console.log("AICustomInputNode 數據同步更新:", {
      "data.model": data?.model,
      "data.promptText": data?.promptText,
      "current promptText": promptText,
      isUserInput: isUserInputRef.current,
      isComposing: isComposingRef.current
    });
    if (data?.model && data.model !== localModel) {
      setLocalModel(data.model);
    }
    if (data?.promptText !== void 0 && data.promptText !== lastExternalValueRef.current && !isComposingRef.current && !isUserInputRef.current) {
      setPromptText(data.promptText);
      lastExternalValueRef.current = data.promptText;
    }
  }, [data?.model, data?.promptText, localModel, promptText]);
  const loadModels = async () => {
    if (isLoadingModels) return;
    setIsLoadingModels(true);
    setModelLoadError(null);
    try {
      const options = await llmService.getModelOptions();
      if (options && options.length > 0) {
        setModelOptions(options);
        const isCurrentModelValid = options.some(
          (opt) => opt.value === localModel
        );
        if (!isCurrentModelValid) {
          let defaultModel = options[0].value;
          const defaultOption = options.find((opt) => opt.isDefault);
          if (defaultOption) {
            defaultModel = defaultOption.value;
          }
          setLocalModel(defaultModel);
          updateParentState("model", defaultModel);
        }
      }
    } catch (error) {
      console.error("加載模型失敗:", error);
      if (!(error.message && (error.message.includes("已有進行中的LLM模型請求") || error.message.includes("進行中的請求") || error.message.includes("使用相同請求")))) {
        setModelLoadError("無法載入模型列表，請稍後再試");
      }
    } finally {
      setIsLoadingModels(false);
    }
  };
  useEffect$i(() => {
    loadModels();
  }, []);
  const updateParentState = useCallback$i(
    (key, value) => {
      if (data && typeof data.updateNodeData === "function") {
        data.updateNodeData(key, value);
        return true;
      }
      if (data) {
        data[key] = value;
        return true;
      }
      return false;
    },
    [data]
  );
  const handleModelChange = useCallback$i(
    (e) => {
      const newModelValue = e.target.value;
      setLocalModel(newModelValue);
      updateParentState("model", newModelValue);
    },
    [updateParentState]
  );
  const handlePromptTextChange = useCallback$i(
    (e) => {
      const newText = e.target.value;
      isUserInputRef.current = true;
      setPromptText(newText);
      lastExternalValueRef.current = newText;
      if (updateTimeoutRef.current) {
        clearTimeout(updateTimeoutRef.current);
      }
      if (!isComposingRef.current) {
        updateTimeoutRef.current = setTimeout(() => {
          updateParentState("promptText", newText);
          setTimeout(() => {
            isUserInputRef.current = false;
          }, 100);
        }, 150);
      }
    },
    [updateParentState]
  );
  const handleCompositionStart = useCallback$i(() => {
    isComposingRef.current = true;
    isUserInputRef.current = true;
    if (updateTimeoutRef.current) {
      clearTimeout(updateTimeoutRef.current);
      updateTimeoutRef.current = null;
    }
  }, []);
  const handleCompositionEnd = useCallback$i(
    (e) => {
      isComposingRef.current = false;
      const finalText = e.target.value;
      setPromptText(finalText);
      lastExternalValueRef.current = finalText;
      updateParentState("promptText", finalText);
      setTimeout(() => {
        isUserInputRef.current = false;
      }, 200);
    },
    [updateParentState]
  );
  const handleKeyDown = useCallback$i((e) => {
    if (e.key === "Backspace" || e.key === "Delete") {
      isUserInputRef.current = true;
      setTimeout(() => {
        isUserInputRef.current = false;
      }, 300);
    }
  }, []);
  useEffect$i(() => {
    return () => {
      if (updateTimeoutRef.current) {
        clearTimeout(updateTimeoutRef.current);
      }
    };
  }, []);
  const handleRefinePromptClick = useCallback$i(() => {
    const validation = PromptGeneratorService.validateParameters(
      parseInt(localModel),
      promptText
    );
    if (!validation.isValid) {
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: validation.errors[0],
          type: "error",
          duration: 3e3
        });
      }
      return;
    }
    setShowRefinePrompt(true);
  }, [localModel, promptText]);
  const handleOptimizedPromptApply = useCallback$i(
    (optimizedPrompt) => {
      setPromptText(optimizedPrompt);
      lastExternalValueRef.current = optimizedPrompt;
      updateParentState("promptText", optimizedPrompt);
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "優化 Prompt 已應用",
          type: "success",
          duration: 2e3
        });
      }
    },
    [updateParentState]
  );
  const handleOptimizedPromptCopy = useCallback$i(() => {
    console.log("優化後的 Prompt 已複製到剪貼板");
  }, []);
  const closeRefinePrompt = useCallback$i(() => {
    setShowRefinePrompt(false);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-64", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-orange-50 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 rounded-full bg-orange-400 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "ai" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "AI" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-t border-gray-200" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "model" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              className: `w-full border border-gray-300 rounded p-2 text-sm bg-white appearance-none
                 ${isLoadingModels ? "opacity-70 cursor-wait" : ""} 
                 ${modelLoadError ? "border-red-300" : ""}
                 ${showRefinePrompt ? "opacity-50 cursor-not-allowed" : ""}`,
              value: localModel,
              onChange: handleModelChange,
              disabled: isLoadingModels || showRefinePrompt,
              children: [
                " ",
                modelOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "option",
                  {
                    value: option.value,
                    children: option.label
                  },
                  option.value
                ))
              ]
            }
          ),
          isLoadingModels ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-2 top-1/2 transform -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-b-2 border-gray-500" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "16",
              height: "16",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
            }
          ) })
        ] }),
        modelLoadError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-red-500 mt-1", children: modelLoadError })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 font-bold", children: "Prompt" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: handleRefinePromptClick,
              disabled: !promptText || promptText.trim().length === 0,
              className: "group w-6 h-6 disabled:cursor-not-allowed rounded flex items-center justify-center transition-colors",
              title: "Refine prompt",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: promptIcon,
                    width: 18,
                    height: 18,
                    style: {
                      maxWidth: "100%",
                      maxHeight: "100%",
                      objectFit: "contain"
                    },
                    className: "max-w-full max-h-full object-contain group-disabled:hidden"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: promptDisabledIcon,
                    width: 18,
                    height: 18,
                    style: {
                      maxWidth: "100%",
                      maxHeight: "100%",
                      objectFit: "contain"
                    },
                    className: "max-w-full max-h-full object-contain hidden group-disabled:block"
                  }
                )
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          AutoResizeTextarea,
          {
            value: promptText,
            onChange: handlePromptTextChange,
            onCompositionStart: handleCompositionStart,
            onCompositionEnd: handleCompositionEnd,
            onKeyDown: handleKeyDown,
            placeholder: "輸入您的提示",
            className: "w-full border border-gray-300 rounded p-2 text-sm pr-10",
            disabled: showRefinePrompt
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700 mr-2 font-bold", children: "Context" }),
        contextConnectionCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded-full", children: [
          contextConnectionCount,
          " 個連線"
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "prompt-input",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          left: "-6px",
          top: "70%",
          transform: "translateY(-50%)"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "context-input",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          left: "-6px",
          top: "92%",
          transform: "translateY(-50%)"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "output",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          right: "-6px"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RefinePromptOverlay,
      {
        isOpen: showRefinePrompt,
        onClose: closeRefinePrompt,
        originalPrompt: promptText,
        llmId: parseInt(localModel),
        onOptimizedPromptApply: handleOptimizedPromptApply,
        onOptimizedPromptCopy: handleOptimizedPromptCopy,
        nodePosition: { x: data?.position?.x || 0, y: data?.position?.y || 0 },
        offsetX: 265,
        offsetY: -150
      }
    )
  ] });
};
const AICustomInputNode$1 = memo$h(AICustomInputNode);

const add = "data:image/svg+xml,%3csvg%20width='16'%20height='16'%20viewBox='0%200%2016%2016'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23l9ob8qnlxa)'%3e%3cpath%20d='M8%200a8%208%200%200%200-8%208%208%208%200%200%200%208%208%208%208%200%200%200%208-8%208%208%200%200%200-8-8zm4.666%208.666A.664.664%200%200%201%2012%209.33H9.334V12a.664.664%200%200%201-.665.666H7.334A.666.666%200%200%201%206.67%2012V9.334H4a.666.666%200%200%201-.666-.665V7.334c0-.368.297-.665.666-.665h2.666V4c0-.369.296-.666.665-.666h1.335c.368%200%20.665.3.665.666v2.666H12c.369%200%20.666.3.666.665v1.335z'%20fill='%23fff'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='l9ob8qnlxa'%3e%3cpath%20fill='%23fff'%20d='M0%200h16v16H0z'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";

await importShared('react');
const Add = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `flex items-center justify-center`,
      style: {
        width: "14px",
        height: "14px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: add,
          width: 32,
          height: 32,
          className: "max-w-full max-h-full object-contain",
          style: {
            maxWidth: "100%",
            maxHeight: "100%",
            objectFit: "contain"
          }
        }
      )
    }
  );
};

const React$o = await importShared('react');
const {memo: memo$g,useEffect: useEffect$h,useState: useState$n,useRef: useRef$d,useCallback: useCallback$h} = React$o;
const BrowserExtensionOutputNode = ({ id, data, isConnectable }) => {
  const [inputs, setInputs] = useState$n([]);
  const [handleLabels, setHandleLabels] = useState$n({});
  const updateNodeInternals = useUpdateNodeInternals();
  const initAttempts = useRef$d(0);
  const nodeId = id || "unknown";
  const isUpdating = useRef$d(false);
  const isInitialized = useRef$d(false);
  const handleHeight = 40;
  const getNodeHeight = useCallback$h(() => {
    const headerHeight = 50;
    const buttonAreaHeight = 48;
    const textAreaHeight = 40;
    const bottomPadding = 30;
    return headerHeight + inputs.length * handleHeight + buttonAreaHeight + textAreaHeight + bottomPadding;
  }, [inputs.length]);
  const edges = useEdges();
  const processHandleId = (handleId) => {
    if (!handleId) return "";
    const match = handleId && handleId.match(/^(output\d+)(?:_\d+)?$/);
    if (match && match[1]) {
      return match[1];
    }
    if (handleId === "input") {
      return "output0";
    }
    return handleId;
  };
  const loadLabelsFromNodeInput = useCallback$h(() => {
    if (!data.node_input) return {};
    const labels = {};
    Object.entries(data.node_input).forEach(([key, value]) => {
      if (value && value.return_name) {
        const baseHandleId = processHandleId(key);
        labels[baseHandleId] = value.return_name;
      }
    });
    return labels;
  }, [data.node_input]);
  useEffect$h(() => {
    if (isUpdating.current || isInitialized.current) return;
    isUpdating.current = true;
    initAttempts.current += 1;
    console.log(
      `初始化 BrowserExtensionOutputNode ${nodeId}，嘗試 #${initAttempts.current}`
    );
    const handleSet = /* @__PURE__ */ new Set();
    if (data.node_input && typeof data.node_input === "object") {
      const inputKeys = Object.keys(data.node_input);
      console.log(`從 node_input 載入 handle (${nodeId}):`, inputKeys);
      inputKeys.forEach((key) => {
        const baseHandleId = processHandleId(key);
        if (baseHandleId) {
          handleSet.add(baseHandleId);
        }
      });
    }
    if (data.inputHandles && Array.isArray(data.inputHandles)) {
      console.log(
        `從 inputHandles 屬性載入 ${data.inputHandles.length} 個 handle`
      );
      data.inputHandles.forEach((handle) => {
        if (handle && handle.id) {
          const baseHandleId = processHandleId(handle.id);
          if (baseHandleId) {
            handleSet.add(baseHandleId);
          }
        }
      });
    }
    if (data.parameters && data.parameters.inputHandles && data.parameters.inputHandles.data) {
      console.log(`從參數中載入 handle`);
      const paramHandles = data.parameters.inputHandles.data;
      if (Array.isArray(paramHandles)) {
        paramHandles.forEach((handleId) => {
          const baseHandleId = processHandleId(handleId);
          if (baseHandleId) {
            handleSet.add(baseHandleId);
          }
        });
      }
    }
    if (handleSet.size === 0) {
      handleSet.add("output0");
      console.log(`添加默認 handle: output0`);
    }
    const handles = Array.from(handleSet).map((id2) => ({ id: String(id2) }));
    console.log(`最終設置節點 ${nodeId} 的 inputs:`, handles);
    setInputs(handles);
    if (data.node_input) {
      const nodeInput = { ...data.node_input };
      const handleMapping = {};
      Object.keys(nodeInput).forEach((key) => {
        const baseHandleId = processHandleId(key);
        if (!handleMapping[baseHandleId]) {
          handleMapping[baseHandleId] = [];
        }
        handleMapping[baseHandleId].push(key);
      });
      handles.forEach((handle) => {
        const baseHandleId = handle.id;
        if (!handleMapping[baseHandleId] || handleMapping[baseHandleId].length === 0) {
          nodeInput[baseHandleId] = {
            node_id: "",
            output_name: "",
            type: "string",
            data: "",
            is_empty: true,
            return_name: ""
            // 確保有 return_name 屬性
          };
        } else if (handleMapping[baseHandleId]) {
          handleMapping[baseHandleId].forEach((key) => {
            if (!Object.prototype.hasOwnProperty.call(
              nodeInput[key],
              "return_name"
            )) {
              nodeInput[key].return_name = "";
            }
          });
        }
      });
      data.node_input = nodeInput;
    }
    if (data.inputHandles) {
      data.inputHandles = handles;
    }
    const initialLabels = loadLabelsFromNodeInput();
    if (Object.keys(initialLabels).length > 0) {
      setHandleLabels(initialLabels);
      console.log("設置初始標籤:", initialLabels);
    }
    console.log(`節點 ${nodeId} 完整資料:`, {
      handles,
      node_input: data.node_input || {},
      inputHandles: data.inputHandles || [],
      labels: initialLabels
    });
    isInitialized.current = true;
    const updateTimes = [0, 50, 150, 300, 600, 1e3, 1500];
    updateTimes.forEach((delay) => {
      setTimeout(() => {
        try {
          updateNodeInternals(nodeId);
        } catch (error) {
          console.error(`更新節點內部結構時出錯:`, error);
        }
      }, delay);
    });
    setTimeout(() => {
      isUpdating.current = false;
    }, 200);
  }, [nodeId, data, updateNodeInternals, loadLabelsFromNodeInput]);
  useEffect$h(() => {
    if (inputs.length > 0) {
      console.log(`inputs 更新為 ${inputs.length} 個 handle，更新內部結構`);
      setTimeout(() => {
        try {
          updateNodeInternals(nodeId);
        } catch (error) {
          console.error(`更新節點內部結構時出錯:`, error);
        }
      }, 50);
    }
  }, [inputs, nodeId, updateNodeInternals]);
  const handleAddOutput = useCallback$h(() => {
    let maxIndex = -1;
    inputs.forEach((input) => {
      if (input.id && input.id.startsWith("output")) {
        const indexStr = input.id.substring(6);
        const index = parseInt(indexStr, 10);
        if (!isNaN(index) && index > maxIndex) {
          maxIndex = index;
        }
      }
    });
    const newIndex = maxIndex + 1;
    const newInputId = `output${newIndex}`;
    const newInputs = [...inputs, { id: newInputId }];
    console.log(`新增 handle (${nodeId}):`, newInputId);
    const currentLabels = { ...handleLabels };
    setInputs(newInputs);
    if (data.node_input) {
      data.node_input[newInputId] = {
        node_id: "",
        output_name: "",
        type: "string",
        data: "",
        is_empty: true,
        return_name: ""
        // 確保有 return_name 屬性
      };
    }
    if (data.inputHandles) {
      data.inputHandles = newInputs;
    } else {
      data.inputHandles = newInputs;
    }
    if (data.parameters && data.parameters.inputHandles) {
      data.parameters.inputHandles.data = newInputs.map((h) => h.id);
    }
    if (data.updateNodeData) {
      try {
        data.updateNodeData("inputHandles", newInputs);
        data.updateNodeData("node_input", data.node_input);
      } catch (err) {
        console.warn("同步更新節點數據時出錯:", err);
      }
    }
    setTimeout(() => {
      setHandleLabels((prevLabels) => {
        const mergedLabels = { ...currentLabels, ...prevLabels };
        return mergedLabels;
      });
    }, 0);
    if (data.onAddOutput) {
      try {
        data.onAddOutput(newInputs);
      } catch (err) {
        console.warn(`調用 onAddOutput 時出錯:`, err);
      }
    } else {
      console.warn(`節點 ${nodeId} 沒有 onAddOutput 回調函數`);
    }
  }, [inputs, data, nodeId, handleLabels]);
  const handleDeleteInput = useCallback$h(
    (handleId) => {
      const newInputs = inputs.filter((input) => input.id !== handleId);
      const currentLabels = { ...handleLabels };
      delete currentLabels[handleId];
      setInputs(newInputs);
      if (data.node_input) {
        const updatedNodeInput = { ...data.node_input };
        Object.keys(updatedNodeInput).forEach((key) => {
          const baseHandleId = processHandleId(key);
          if (baseHandleId === handleId) {
            delete updatedNodeInput[key];
          }
        });
        data.node_input = updatedNodeInput;
      }
      data.inputHandles = newInputs;
      if (data.parameters && data.parameters.inputHandles) {
        data.parameters.inputHandles.data = newInputs.map((h) => h.id);
      }
      setHandleLabels(currentLabels);
      if (data.updateNodeData) {
        try {
          data.updateNodeData("inputHandles", newInputs);
          data.updateNodeData("node_input", data.node_input);
        } catch (err) {
          console.warn("同步更新節點數據時出錯:", err);
        }
      }
      if (typeof window !== "undefined" && window.deleteEdgesByHandle) {
        window.deleteEdgesByHandle(nodeId, handleId);
      }
      if (data.onRemoveHandle) {
        try {
          data.onRemoveHandle(handleId);
        } catch (err) {
          console.warn(`調用 onRemoveHandle 時出錯:`, err);
        }
      }
    },
    [inputs, data, nodeId, handleLabels]
  );
  const handleLabelChange = useCallback$h(
    (handleId, newLabel) => {
      setHandleLabels((prev) => {
        if (prev[handleId] === newLabel) return prev;
        const updatedLabels = { ...prev, [handleId]: newLabel };
        console.log("更新標籤狀態:", updatedLabels);
        return updatedLabels;
      });
      if (data.node_input) {
        Object.keys(data.node_input).forEach((key) => {
          const baseKey = processHandleId(key);
          if (baseKey === handleId) {
            data.node_input[key].return_name = newLabel;
            data.node_input[key].has_return_name = true;
          }
        });
        const baseHandleExists = Object.keys(data.node_input).some(
          (key) => processHandleId(key) === handleId
        );
        if (!baseHandleExists) {
          data.node_input[handleId] = {
            node_id: "",
            output_name: "",
            type: "string",
            data: "",
            is_empty: true,
            return_name: newLabel,
            has_return_name: true
            // 標記為有 return_name
          };
        }
      }
      if (data.updateNodeData && data.node_input) {
        try {
          const updatedNodeInput = JSON.parse(JSON.stringify(data.node_input));
          Object.keys(updatedNodeInput).forEach((key) => {
            const baseKey = processHandleId(key);
            if (baseKey === handleId) {
              updatedNodeInput[key].return_name = newLabel;
              updatedNodeInput[key].has_return_name = true;
            }
          });
          if (!Object.keys(updatedNodeInput).some(
            (key) => processHandleId(key) === handleId
          )) {
            updatedNodeInput[handleId] = {
              node_id: "",
              output_name: "",
              type: "string",
              data: "",
              is_empty: true,
              return_name: newLabel,
              has_return_name: true
            };
          }
          data.updateNodeData("node_input", updatedNodeInput);
        } catch (err) {
          console.warn("更新節點數據時出錯:", err);
        }
      }
    },
    [data]
  );
  const nodeStyle = {
    height: `${getNodeHeight()}px`,
    transition: "height 0.3s ease"
  };
  const cleanupOrphanNodeInputs = useCallback$h(() => {
    if (!data.node_input) return;
    const currentEdges = window.currentEdges || [];
    const nodeInputKeys = Object.keys(data.node_input);
    const connectedHandles = /* @__PURE__ */ new Set();
    currentEdges.filter((edge) => edge.target === nodeId).forEach((edge) => {
      if (edge.targetHandle) {
        const baseHandle = edge.targetHandle.split("_")[0];
        connectedHandles.add(baseHandle);
      }
    });
    let hasOrphans = false;
    const cleanedNodeInput = { ...data.node_input };
    nodeInputKeys.forEach((key) => {
      const baseKey = key.split("_")[0];
      const inputData = data.node_input[key];
      if (inputData.node_id && !connectedHandles.has(baseKey)) {
        console.log(`發現孤兒 node_input 項目: ${key}，準備清理`);
        delete cleanedNodeInput[key];
        hasOrphans = true;
      }
    });
    if (hasOrphans) {
      console.log(`清理了孤兒 node_input 項目，更新節點數據`);
      if (data.updateNodeData) {
        data.updateNodeData("node_input", cleanedNodeInput);
      }
    }
  }, [data, nodeId]);
  useEffect$h(() => {
    const handleRouterDeleted = () => {
      setTimeout(() => {
        cleanupOrphanNodeInputs();
      }, 100);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("routerDeleted", handleRouterDeleted);
    }
    return () => {
      if (typeof window !== "undefined") {
        window.removeEventListener("routerDeleted", handleRouterDeleted);
      }
    };
  }, [cleanupOrphanNodeInputs]);
  useEffect$h(() => {
    const timeoutId = setTimeout(() => {
      cleanupOrphanNodeInputs();
    }, 200);
    return () => clearTimeout(timeoutId);
  }, [edges, cleanupOrphanNodeInputs]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "rounded-lg shadow-md overflow-visible w-64 bg-white",
      style: nodeStyle,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "p-3 rounded-t-lg",
            style: { backgroundColor: "#f3f4f6" },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 rounded-md bg-teal-500 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "browser" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-base", children: "Browser Extension output" })
            ] })
          }
        ),
        inputs.map((input, index) => {
          const startY = 65;
          const topPosition = startY + index * handleHeight;
          const handleStyle = {
            background: "#e5e7eb",
            borderColor: "#D3D3D3",
            width: "12px",
            height: "12px",
            left: "-6px",
            top: `${topPosition + 14}px`,
            border: "1px solid #D3D3D3"
          };
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$o.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Handle$1,
              {
                type: "target",
                position: Position.Left,
                id: String(input.id),
                style: handleStyle,
                isConnectable
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "absolute flex items-center",
                style: { left: "10px", top: `${topPosition}px` },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      className: "text-sm border border-gray-300 rounded px-2 py-1 focus:ring-1 focus:ring-teal-500 focus:border-teal-500 focus:outline-none",
                      placeholder: "請輸入",
                      value: handleLabels[input.id] || "",
                      onChange: (e) => handleLabelChange(input.id, e.target.value),
                      title: `輸入 ${input.id} 的標籤（將儲存為 return_name）`,
                      style: {
                        height: "30px",
                        lineHeight: "28px",
                        fontSize: "14px",
                        width: "210px"
                        // 調整寬度為刪除按鈕留空間
                      }
                    }
                  ),
                  inputs.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => handleDeleteInput(input.id),
                      className: "ml-2 text-gray-500 hover:text-teal-600 text-sm p-1 w-6 h-6 flex items-center justify-center",
                      title: "刪除此輸入",
                      children: "✕"
                    }
                  )
                ]
              }
            )
          ] }, `handle-${input.id}`);
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "p-4 absolute bottom-1 left-1 right-1 rounded-b-lg",
            style: {
              backgroundColor: "white",
              borderTop: "1px solid #f0f0f0"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  className: "w-full bg-teal-500 hover:bg-teal-600 text-white rounded-md p-2 flex justify-center items-center",
                  onClick: handleAddOutput,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Add, {})
                }
              ),
              inputs.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-600 mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                "已有 ",
                inputs.length,
                " 個輸入點"
              ] }) })
            ]
          }
        )
      ]
    }
  );
};
const BrowserExtensionOutputNode$1 = memo$g(BrowserExtensionOutputNode);

const uploadIcon = "data:image/svg+xml,%3csvg%20width='52'%20height='52'%20viewBox='0%200%2052%2052'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%235gywebmwoa)'%3e%3cpath%20d='M18.428%2018.428H7V7h11.428v11.428zm-8.57-2.857h5.715V9.858H9.858v5.713z'%20fill='url(%23jptftkcuhb)'/%3e%3cpath%20d='M47%2047H35.572V35.572H47V47zm-8.57-2.858h5.715v-5.715h-5.716v5.715z'%20fill='url(%23w0z875nvvc)'/%3e%3cpath%20d='M32.714%2042.715H15.571a8.572%208.572%200%201%201%200-17.144v2.858a5.716%205.716%200%201%200%200%2011.428h17.143v2.858z'%20fill='url(%23h5lpzhsc6d)'/%3e%3cpath%20d='M38.43%2028.429V25.57a5.716%205.716%200%200%200%200-11.428H21.285v-2.858h17.143a8.572%208.572%200%200%201%200%2017.144z'%20fill='url(%23w6mtwnzzve)'/%3e%3cpath%20d='M31.28%2019.858h-8.567l-4.285%205.716%208.57%208.57%208.571-8.57-4.29-5.716z'%20fill='url(%23xyoyqawnmf)'/%3e%3c/g%3e%3cdefs%3e%3clinearGradient%20id='jptftkcuhb'%20x1='7'%20y1='18.428'%20x2='18.428'%20y2='7'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%2300CED1'/%3e%3cstop%20offset='1'%20stop-color='%2387CEEB'/%3e%3c/linearGradient%3e%3clinearGradient%20id='w0z875nvvc'%20x1='35.572'%20y1='47'%20x2='47'%20y2='35.572'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%2300CED1'/%3e%3cstop%20offset='1'%20stop-color='%2387CEEB'/%3e%3c/linearGradient%3e%3clinearGradient%20id='h5lpzhsc6d'%20x1='6.999'%20y1='42.715'%20x2='22.824'%20y2='18.977'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%2300CED1'/%3e%3cstop%20offset='1'%20stop-color='%2387CEEB'/%3e%3c/linearGradient%3e%3clinearGradient%20id='w6mtwnzzve'%20x1='21.286'%20y1='28.429'%20x2='37.11'%20y2='4.692'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%2300CED1'/%3e%3cstop%20offset='1'%20stop-color='%2387CEEB'/%3e%3c/linearGradient%3e%3clinearGradient%20id='xyoyqawnmf'%20x1='18.428'%20y1='34.144'%20x2='32.48'%20y2='17.284'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%2300CED1'/%3e%3cstop%20offset='1'%20stop-color='%2387CEEB'/%3e%3c/linearGradient%3e%3cclipPath%20id='5gywebmwoa'%3e%3cpath%20fill='%23fff'%20transform='translate(7%207)'%20d='M0%200h40v40H0z'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";

const React$n = await importShared('react');
const {memo: memo$f,useState: useState$m,useEffect: useEffect$g,useCallback: useCallback$g,useRef: useRef$c} = React$n;
const BrowserExtensionInputNode = ({ data, isConnectable, id }) => {
  const [localItems, setLocalItems] = useState$m(data?.items || []);
  const [isUploading, setIsUploading] = useState$m(false);
  const [uploadError, setUploadError] = useState$m(null);
  const fileInputRef = useRef$c(null);
  const activeItemRef = useRef$c(null);
  useEffect$g(() => {
    console.log("BrowserExtensionInputNode 數據同步檢查:", {
      "data.items": data?.items,
      localItems,
      "node.id": id
    });
    if (Array.isArray(data?.items) && JSON.stringify(data.items) !== JSON.stringify(localItems)) {
      console.log("同步 items 數據到本地狀態");
      setLocalItems([...data.items]);
    }
  }, [data?.items]);
  const updateParentState = useCallback$g(
    (key, value) => {
      console.log(`嘗試更新父組件狀態 ${key}=`, value);
      if (key === "items" && data && typeof data.updateItems === "function") {
        data.updateItems(value);
        return true;
      }
      if (data && typeof data.updateNodeData === "function") {
        data.updateNodeData(key, value);
        return true;
      }
      if (data) {
        data[key] = value;
        return true;
      }
      console.warn(`無法更新父組件的 ${key}`);
      return false;
    },
    [data]
  );
  const handleIconClick = useCallback$g((index) => {
    console.log(`點擊項目 ${index} 的圖標，準備上傳新圖標`);
    activeItemRef.current = index;
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  }, []);
  const handleFileSelect = useCallback$g(
    async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      const itemIndex = activeItemRef.current;
      if (itemIndex === null || itemIndex < 0 || itemIndex >= localItems.length) {
        console.warn("沒有找到活動項目索引或索引超出範圍");
        return;
      }
      setIsUploading(true);
      setUploadError(null);
      try {
        const result = await iconUploadService.uploadIcon(file);
        if (result.success && result.url) {
          console.log("圖標上傳成功:", result.url);
          handleIconChange(itemIndex, result.url);
        } else {
          throw new Error(result.error || "上傳失敗");
        }
      } catch (error) {
        console.error("上傳或處理圖標時發生錯誤:", error);
        setUploadError(error.message || "上傳圖標失敗");
      } finally {
        setIsUploading(false);
        event.target.value = "";
      }
    },
    [localItems]
  );
  const getIconComponent = useCallback$g(
    (iconValue, index) => {
      if (iconUploadService.isIconUrl(iconValue)) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "cursor-pointer",
            onClick: () => handleIconClick(index),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: iconValue,
                alt: "Custom Icon",
                className: "w-7 h-7 object-contain"
              }
            )
          }
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "cursor-pointer",
          onClick: () => handleIconClick(index),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: uploadIcon,
              width: 32,
              height: 32
            }
          )
        }
      );
    },
    [handleIconClick]
  );
  const handleIconChange = useCallback$g(
    (index, iconValue) => {
      console.log(`更新項目 ${index} 的圖標為`, iconValue);
      if (index < 0 || index >= localItems.length) {
        console.warn(`項目索引 ${index} 超出範圍`);
        return;
      }
      const updatedItems = localItems.map(
        (item, idx) => idx === index ? { ...item, icon: iconValue } : item
      );
      setLocalItems(updatedItems);
      updateParentState("items", updatedItems);
    },
    [localItems, updateParentState]
  );
  const handleNameChange = useCallback$g(
    (index, value) => {
      console.log(`修改項目 ${index} 的名稱為 "${value}"`);
      console.log("當前 items:", localItems);
      if (index < 0 || index >= localItems.length) {
        console.warn(`項目索引 ${index} 超出範圍`);
        return;
      }
      if (typeof data?.updateItemName === "function") {
        console.log("使用 updateItemName 回調函數");
        data.updateItemName(index, value);
      }
      console.log("使用自定義方法更新項目名稱");
      const updatedItems = localItems.map(
        (item, idx) => idx === index ? { ...item, name: value } : item
      );
      console.log("更新後的 items:", updatedItems);
      setLocalItems(updatedItems);
      updateParentState("items", updatedItems);
    },
    [data, localItems, updateParentState]
  );
  const handleDeleteItem = useCallback$g(
    (index) => {
      console.log(`準備刪除項目 ${index}`);
      if (index < 0 || index >= localItems.length) {
        console.warn(`項目索引 ${index} 超出範圍`);
        return;
      }
      if (localItems.length <= 1) {
        console.warn("不能刪除最後一個項目");
        if (typeof window !== "undefined" && window.notify) {
          window.notify({
            message: "至少需要保留一個項目",
            type: "warning",
            duration: 3e3
          });
        }
        return;
      }
      const itemToDelete = localItems[index];
      const itemOutputKey = itemToDelete.id || `a${index + 1}`;
      console.log(`刪除項目: ${itemToDelete.name}, 輸出鍵: ${itemOutputKey}`);
      if (typeof window !== "undefined" && window.deleteEdgesBySourceHandle) {
        window.deleteEdgesBySourceHandle(id, itemOutputKey);
      }
      const updatedItems = localItems.filter((_, idx) => idx !== index);
      console.log("刪除後的項目列表:", updatedItems);
      setLocalItems(updatedItems);
      updateParentState("items", updatedItems);
      if (typeof data?.deleteItem === "function") {
        console.log("通知 deleteItem 回調函數 (已處理標記)");
        data.deleteItem(-1);
      }
    },
    [localItems, updateParentState, data, id]
  );
  const handleAddItem = useCallback$g(() => {
    console.log("添加新項目");
    if (typeof data?.addItem === "function") {
      console.log("使用 addItem 回調函數");
      data.addItem();
      return;
    }
    console.log("使用自定義方法添加項目");
    const newItem = { name: "", icon: "upload" };
    const updatedItems = [...localItems, newItem];
    setLocalItems(updatedItems);
    updateParentState("items", updatedItems);
  }, [data, localItems, updateParentState]);
  const calculateHandlePosition = useCallback$g((index) => {
    const headerHeight = 46;
    const contentPadding = 16;
    const itemHeight = 140;
    return headerHeight + contentPadding + index * itemHeight + itemHeight / 2;
  }, []);
  const getOutputKey = useCallback$g((item, index) => {
    return item.id || `a${index + 1}`;
  }, []);
  const items = Array.isArray(localItems) && localItems.length > 0 ? localItems : Array.isArray(data?.items) ? data.items : [];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shadow-md w-64 relative", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "file",
        ref: fileInputRef,
        style: { display: "none" },
        accept: "image/*",
        onChange: handleFileSelect
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg overflow-hidden", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-100 p-4 border-b border-gray-100", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 rounded-md bg-teal-500 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "browser" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Browser Extension input" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-2", children: [
        items.map((item, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "mb-4 last:mb-2 relative border border-gray-200 bg-gray-50 rounded p-2",
            children: [
              items.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handleDeleteItem(idx),
                  className: "absolute top-1 right-0 text-gray-400 hover:text-teal-500 text-sm p-1 w-6 h-6 flex items-center justify-center z-10",
                  title: "刪除此項目",
                  style: { fontSize: "14px" },
                  children: "✕"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "name" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    className: "w-full border border-gray-300 rounded p-2 text-sm",
                    value: item.name || "",
                    onChange: (e) => {
                      console.log(`輸入框 ${idx} 值變更為:`, e.target.value);
                      handleNameChange(idx, e.target.value);
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mr-4 font-bold", children: "icon" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 flex justify-center items-center mt-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: `w-7 h-7 flex justify-center items-center border border-gray-300 rounded ${isUploading && activeItemRef.current === idx ? "opacity-50" : ""}`,
                    title: "點擊上傳自定義圖標",
                    children: isUploading && activeItemRef.current === idx ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-6 w-6" }) : getIconComponent(item.icon, idx)
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-5" })
              ] }),
              uploadError && activeItemRef.current === idx && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-red-500 mt-1 mb-2", children: uploadError })
            ]
          },
          idx
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "w-full bg-teal-500 hover:bg-teal-600 text-white rounded-md p-2 flex justify-center items-center mt-4",
            onClick: handleAddItem,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Add, {})
          }
        )
      ] })
    ] }),
    items.map((item, idx) => {
      const outputKey = getOutputKey(item, idx);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Handle$1,
        {
          type: "source",
          position: Position.Right,
          id: outputKey,
          style: {
            background: "#e5e7eb",
            border: "1px solid #D3D3D3",
            width: "12px",
            height: "12px",
            right: "-7px",
            top: calculateHandlePosition(idx),
            transform: "translateY(-50%)",
            // Only center vertically
            zIndex: 1e3
          },
          isConnectable
        },
        `handle-${idx}`
      );
    })
  ] });
};
const BrowserExtensionInputNode$1 = memo$f(BrowserExtensionInputNode);

const React$m = await importShared('react');
const {memo: memo$e} = React$m;
const IfElseNode = ({ data, isConnectable }) => {
  const operators = [
    { value: "equals", label: "[Text] Equals" },
    { value: "contains", label: "[Text] Contains" },
    { value: "startsWith", label: "[Text] Starts With" },
    { value: "endsWith", label: "[Text] Ends With" },
    { value: "greaterThan", label: "[Number] Greater Than" },
    { value: "lessThan", label: "[Number] Less Than" }
  ];
  const handleFieldChange = (field, value) => {
    if (data.updateNodeData) {
      data.updateNodeData(field, value);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-64", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-purple-100 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 rounded-md bg-purple-500 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "If / Else" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-t border-gray-200" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1", children: "If" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            className: "w-full border border-gray-300 rounded p-2 text-sm",
            placeholder: "formate_value",
            value: data.variableName || "",
            onChange: (e) => handleFieldChange("variableName", e.target.value)
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "select",
        {
          className: "w-full border border-gray-300 rounded p-2 text-sm",
          value: data.operator || "equals",
          onChange: (e) => handleFieldChange("operator", e.target.value),
          children: operators.map((op) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "option",
            {
              value: op.value,
              children: op.label
            },
            op.value
          ))
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          className: "w-full border border-gray-300 rounded p-2 text-sm",
          placeholder: "Value to compare",
          value: data.compareValue || "",
          onChange: (e) => handleFieldChange("compareValue", e.target.value)
        }
      ) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "input",
        style: {
          background: "#555",
          width: "8px",
          height: "8px",
          left: "-4px"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "true",
        style: {
          background: "#10B981",
          // green color for "true"
          width: "8px",
          height: "8px",
          right: "-4px",
          top: "35%"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "false",
        style: {
          background: "#EF4444",
          // red color for "false"
          width: "8px",
          height: "8px",
          right: "-4px",
          top: "65%"
        },
        isConnectable
      }
    )
  ] });
};
const IfElseNode$1 = memo$e(IfElseNode);

const React$l = await importShared('react');
const {memo: memo$d,useState: useState$l,useEffect: useEffect$f,useCallback: useCallback$f} = React$l;
const KnowledgeRetrievalNode = ({ data, isConnectable, id }) => {
  const [isLoadingKnowledgeBases, setIsLoadingKnowledgeBases] = useState$l(false);
  const [knowledgeBaseLoadError, setKnowledgeBaseLoadError] = useState$l(null);
  const [dataKnowledgeBases, setDataKnowledgeBases] = useState$l(
    data?.availableKnowledgeBases || [
      {
        id: "1",
        value: "1",
        name: "產品文檔知識庫",
        label: "產品文檔知識庫",
        description: "存放所有產品相關文檔和規格",
        fileCount: 3,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      },
      {
        id: "2",
        value: "2",
        name: "技術手冊知識庫",
        label: "技術手冊知識庫",
        description: "技術相關文檔和手冊",
        fileCount: 1,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    ]
  );
  const [localSelectedKnowledgeBase, setLocalSelectedKnowledgeBase] = useState$l(
    data?.selectedKnowledgeBase || data?.selectedFile || ""
  );
  const [topK, setTopK] = useState$l(data?.topK || 5);
  const [threshold, setThreshold] = useState$l(data?.threshold || 0.7);
  const updateParentState = useCallback$f(
    (key, value) => {
      console.log(`嘗試更新父組件狀態 ${key}=${value}`);
      if (data && typeof data.updateNodeData === "function") {
        data.updateNodeData(key, value);
        console.log(`使用 updateNodeData 更新 ${key}`);
        return true;
      }
      if (data) {
        data[key] = value;
        console.log(`直接修改 data.${key} = ${value}`);
        return true;
      }
      console.warn(`無法更新父組件的 ${key}`);
      return false;
    },
    [data]
  );
  const handleKnowledgeBaseSelect = useCallback$f(
    (event) => {
      const knowledgeBaseId = event.target.value;
      console.log(`選擇知識庫: ${knowledgeBaseId}`);
      if (knowledgeBaseId !== localSelectedKnowledgeBase) {
        setLocalSelectedKnowledgeBase(knowledgeBaseId);
        updateParentState("selectedKnowledgeBase", knowledgeBaseId);
        updateParentState("selectedFile", knowledgeBaseId);
      }
    },
    [localSelectedKnowledgeBase, updateParentState]
  );
  const handleTopKSelect = useCallback$f(
    (event) => {
      const newTopK = parseInt(event.target.value, 10);
      if (newTopK !== topK) {
        setTopK(newTopK);
        updateParentState("topK", newTopK);
      }
    },
    [topK, updateParentState]
  );
  const handleThresholdChange = useCallback$f(
    (event) => {
      const newThreshold = parseFloat(event.target.value);
      if (newThreshold >= 0 && newThreshold <= 1 && !isNaN(newThreshold)) {
        setThreshold(newThreshold);
        updateParentState("threshold", newThreshold);
        console.log(`更新相關性閾值: ${newThreshold}`);
      }
    },
    [updateParentState]
  );
  const getCurrentSelectedKnowledgeBase = useCallback$f(() => {
    return data?.selectedKnowledgeBase || data?.selectedFile || localSelectedKnowledgeBase;
  }, [
    data?.selectedKnowledgeBase,
    data?.selectedFile,
    localSelectedKnowledgeBase
  ]);
  const loadKnowledgeBases = useCallback$f(async () => {
    if (isLoadingKnowledgeBases) return;
    console.log("開始加載知識庫列表...");
    setIsLoadingKnowledgeBases(true);
    setKnowledgeBaseLoadError(null);
    try {
      const options = await llmService.getKnowledgeBaseOptions();
      if (options && options.length > 0) {
        console.log("已獲取知識庫選項:", options);
        setDataKnowledgeBases(options);
        const currentKB = getCurrentSelectedKnowledgeBase();
        const isCurrentKBValid = options.some(
          (opt) => opt.id === currentKB || opt.value === currentKB
        );
        if (!currentKB || !isCurrentKBValid) {
          const firstKBId = options[0].id || options[0].value;
          console.log(`自動選擇第一個知識庫: ${firstKBId}`);
          setLocalSelectedKnowledgeBase(firstKBId);
          updateParentState("selectedKnowledgeBase", firstKBId);
          updateParentState("selectedFile", firstKBId);
        }
      }
    } catch (error) {
      console.error("加載知識庫失敗:", error);
      if (error.message && (error.message.includes("已有進行中的") || error.message.includes("進行中的請求") || error.message.includes("使用相同請求"))) {
        console.log("正在等待其他相同請求完成...");
      } else {
        setKnowledgeBaseLoadError("無法載入知識庫列表，請稍後再試");
      }
    } finally {
      setIsLoadingKnowledgeBases(false);
    }
  }, [
    isLoadingKnowledgeBases,
    getCurrentSelectedKnowledgeBase,
    updateParentState
  ]);
  useEffect$f(() => {
    const parentSelected = data?.selectedKnowledgeBase || data?.selectedFile;
    if (parentSelected && parentSelected !== localSelectedKnowledgeBase) {
      setLocalSelectedKnowledgeBase(parentSelected);
    }
  }, [data?.selectedKnowledgeBase, data?.selectedFile, id]);
  useEffect$f(() => {
    if (data?.topK && data.topK !== topK) {
      console.log(`同步 topK 值從 ${topK} 到 ${data.topK}`);
      setTopK(data.topK);
    }
  }, [data?.topK]);
  useEffect$f(() => {
    if (data?.threshold !== void 0 && data.threshold !== threshold) {
      console.log(`同步 threshold 值從 ${threshold} 到 ${data.threshold}`);
      setThreshold(data.threshold);
    }
  }, [data?.threshold]);
  useEffect$f(() => {
    loadKnowledgeBases();
  }, []);
  const handleSelectFocus = useCallback$f(() => {
    if (dataKnowledgeBases.length === 0 && !isLoadingKnowledgeBases) {
      loadKnowledgeBases();
    }
  }, [dataKnowledgeBases.length, isLoadingKnowledgeBases, loadKnowledgeBases]);
  const formatKnowledgeBaseLabel = useCallback$f((kb) => {
    const baseLabel = kb.name || kb.label;
    const fileCount = kb.fileCount !== void 0 ? ` (${kb.fileCount} 個檔案)` : "";
    return `${baseLabel}${fileCount}`;
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-visible w-64", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-cyan-400 p-4 rounded-t-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 bg-white rounded-md flex items-center justify-center mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "knowledge" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-white", children: "知識檢索" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 rounded-b-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "Data Source" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                className: `w-full border ${knowledgeBaseLoadError ? "border-red-300" : "border-gray-300"} rounded-md p-2 text-sm bg-white appearance-none ${isLoadingKnowledgeBases ? "opacity-70 cursor-wait" : ""}`,
                value: getCurrentSelectedKnowledgeBase(),
                onChange: handleKnowledgeBaseSelect,
                onFocus: handleSelectFocus,
                disabled: isLoadingKnowledgeBases,
                style: {
                  paddingRight: "2rem",
                  textOverflow: "ellipsis"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: "",
                      disabled: true,
                      children: "Select file..."
                    }
                  ),
                  dataKnowledgeBases.map((kb) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: kb.id || kb.value,
                      title: kb.description,
                      children: formatKnowledgeBaseLabel(kb)
                    },
                    kb.id || kb.value
                  ))
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none", children: isLoadingKnowledgeBases ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-b-2 border-gray-500" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
              }
            ) })
          ] }),
          knowledgeBaseLoadError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-red-500 mt-1", children: knowledgeBaseLoadError })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "檢索筆數" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "block text-gray-500 mb-3 text-xs", children: "顯示1至5筆搜尋結果" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "select",
            {
              className: "w-full border border-gray-300 rounded-md p-2 text-sm bg-white appearance-none",
              value: topK,
              onChange: handleTopKSelect,
              style: {
                paddingRight: "2rem"
              },
              children: [1, 2, 3, 4, 5].map((num) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "option",
                {
                  value: num,
                  children: num
                },
                num
              ))
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "16",
              height: "16",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
            }
          ) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "相關性" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "number",
            className: "w-full border border-gray-300 rounded-md p-2 text-sm bg-white",
            value: threshold,
            onChange: handleThresholdChange,
            min: "0",
            max: "1",
            step: "0.1",
            placeholder: "1.0",
            style: {
              paddingRight: "1rem"
            }
          }
        ) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "passage",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          left: "-6px"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "output",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          right: "-6px"
        },
        isConnectable
      }
    )
  ] });
};
const KnowledgeRetrievalNode$1 = memo$d(KnowledgeRetrievalNode);

const React$k = await importShared('react');
const {memo: memo$c} = React$k;
const EndNode = ({ data, isConnectable }) => {
  const handleFieldChange = (field, value) => {
    if (data.updateNodeData) {
      data.updateNodeData(field, value);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-64", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-green-100 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 flex items-center justify-center mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          xmlns: "http://www.w3.org/2000/svg",
          width: "24",
          height: "24",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "text-green-600",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "circle",
              {
                cx: "12",
                cy: "12",
                r: "10"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "16 12 12 8 8 12" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "line",
              {
                x1: "12",
                y1: "16",
                x2: "12",
                y2: "8"
              }
            )
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "End" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-t border-gray-200" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1", children: "Output Text" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          type: "text",
          className: "w-full border border-gray-300 rounded p-2 text-sm",
          placeholder: "Output message",
          value: data.outputText || "",
          onChange: (e) => handleFieldChange("outputText", e.target.value)
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "input",
        style: {
          background: "#555",
          width: "8px",
          height: "8px",
          left: "-4px"
        },
        isConnectable
      }
    )
  ] });
};
const EndNode$1 = memo$c(EndNode);

const React$j = await importShared('react');
const {memo: memo$b,useState: useState$k} = React$j;
const WebhookNode = ({ data, isConnectable }) => {
  const [showInput, setShowInput] = useState$k(false);
  const [tempUrl, setTempUrl] = useState$k("");
  const [showCopyAlert, setShowCopyAlert] = useState$k(false);
  const [isEditing, setIsEditing] = useState$k(false);
  const handleCreateWebhook = () => {
    setShowInput(true);
  };
  const handleConfirmWebhook = () => {
    if (tempUrl.trim()) {
      if (data.updateNodeData) {
        data.updateNodeData("webhookUrl", tempUrl);
        setShowInput(false);
        setIsEditing(false);
      }
    }
  };
  const handleCopyToClipboard = () => {
    if (data.webhookUrl) {
      navigator.clipboard.writeText(data.webhookUrl).then(() => {
        setShowCopyAlert(true);
        setTimeout(() => {
          setShowCopyAlert(false);
        }, 2e3);
      }).catch((err) => {
        console.error("Failed to copy URL: ", err);
      });
    }
  };
  const handleEditWebhook = () => {
    setTempUrl(data.webhookUrl);
    setIsEditing(true);
  };
  const handleCancelEdit = () => {
    setIsEditing(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-visible w-64", children: [
    showCopyAlert && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute -top-10 left-0 right-0 bg-green-500 text-white py-2 px-4 rounded-md text-center text-sm", children: "URL copied to clipboard!" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-visible w-64", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-red-50 p-4 rounded-t-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 bg-red-50 flex items-center justify-center mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Webhook" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-2 rounded-b-lg", children: [
        !data.webhookUrl && !showInput && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "w-full bg-red-500 hover:bg-red-600 text-white rounded-md p-2 flex justify-center items-center",
            onClick: handleCreateWebhook,
            children: "Create a webhook"
          }
        ),
        showInput && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1", children: "URL:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                className: "flex-1 border border-gray-300 rounded-l p-2 text-sm",
                placeholder: "Enter webhook URL",
                value: tempUrl,
                onChange: (e) => setTempUrl(e.target.value)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "bg-red-500 hover:bg-red-600 text-white px-3 rounded-r",
                onClick: handleConfirmWebhook,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    xmlns: "http://www.w3.org/2000/svg",
                    width: "16",
                    height: "16",
                    viewBox: "0 0 24 24",
                    fill: "none",
                    stroke: "currentColor",
                    strokeWidth: "2",
                    strokeLinecap: "round",
                    strokeLinejoin: "round",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" })
                  }
                )
              }
            )
          ] })
        ] }) })
      ] }),
      data.webhookUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white pl-4 pr-4 pb-4 rounded-b", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1", children: "URL:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: isEditing ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              className: "flex-1 border border-gray-300 rounded-t p-2 text-sm",
              value: tempUrl,
              onChange: (e) => setTempUrl(e.target.value)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between mt-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded",
                onClick: handleConfirmWebhook,
                children: "Save"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "bg-gray-300 hover:bg-gray-400 text-black px-3 py-1 rounded",
                onClick: handleCancelEdit,
                children: "Cancel"
              }
            )
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: data.webhookUrl,
              target: "_blank",
              rel: "noopener noreferrer",
              className: "text-blue-600 hover:underline truncate text-sm flex-1 pr-2",
              onClick: (e) => {
                e.preventDefault();
                handleEditWebhook();
              },
              children: data.webhookUrl
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "bg-red-500 hover:bg-red-600 text-white p-1 rounded flex-shrink-0",
              onClick: handleCopyToClipboard,
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "svg",
                {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "16",
                  height: "16",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  stroke: "currentColor",
                  strokeWidth: "2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "rect",
                      {
                        x: "9",
                        y: "9",
                        width: "13",
                        height: "13",
                        rx: "2",
                        ry: "2"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" })
                  ]
                }
              )
            }
          )
        ] }) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "input",
        style: {
          background: "#555",
          width: "8px",
          height: "8px",
          left: "-4px"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "output",
        style: {
          background: "#555",
          width: "8px",
          height: "8px",
          right: "-4px"
        },
        isConnectable
      }
    )
  ] });
};
const WebhookNode$1 = memo$b(WebhookNode);

const React$i = await importShared('react');
const {memo: memo$a,useState: useState$j,useEffect: useEffect$e,useCallback: useCallback$e,useRef: useRef$b} = React$i;
const HttpRequestNode = ({ data, isConnectable }) => {
  const [localUrl, setLocalUrl] = useState$j(data?.url || "");
  const [localMethod, setLocalMethod] = useState$j(data?.method || "GET");
  const [headers, setHeaders] = useState$j(
    data?.headers || [{ key: "", value: "" }]
  );
  const [localBody, setLocalBody] = useState$j(data?.body || "");
  const isComposingUrlRef = useRef$b(false);
  const updateUrlTimeoutRef = useRef$b(null);
  const lastExternalUrlRef = useRef$b(data?.url || "");
  const isUserInputUrlRef = useRef$b(false);
  const isComposingBodyRef = useRef$b(false);
  const updateBodyTimeoutRef = useRef$b(null);
  const lastExternalBodyRef = useRef$b(data?.body || "");
  const isUserInputBodyRef = useRef$b(false);
  const isComposingHeaderKeyRef = useRef$b({});
  const isComposingHeaderValueRef = useRef$b({});
  const updateHeaderTimeoutRef = useRef$b({});
  const isUserInputHeaderRef = useRef$b({});
  const lastExternalHeaderRef = useRef$b({});
  useEffect$e(() => {
    if (data?.url !== void 0 && data.url !== lastExternalUrlRef.current && !isComposingUrlRef.current && !isUserInputUrlRef.current) {
      setLocalUrl(data.url);
      lastExternalUrlRef.current = data.url;
    }
  }, [data?.url]);
  useEffect$e(() => {
    if (data?.method && data.method !== localMethod) {
      setLocalMethod(data.method);
    }
  }, [data?.method, localMethod]);
  useEffect$e(() => {
    if (data?.headers && JSON.stringify(data.headers) !== JSON.stringify(headers)) {
      setHeaders(data.headers);
    }
  }, [data?.headers, headers]);
  useEffect$e(() => {
    if (data?.body !== void 0 && data.body !== lastExternalBodyRef.current && !isComposingBodyRef.current && !isUserInputBodyRef.current) {
      setLocalBody(data.body);
      lastExternalBodyRef.current = data.body;
    }
  }, [data?.body]);
  const updateParentState = useCallback$e(
    (key, value) => {
      if (data && typeof data.updateNodeData === "function") {
        data.updateNodeData(key, value);
        return true;
      }
      if (data) {
        data[key] = value;
        return true;
      }
      return false;
    },
    [data]
  );
  const handleUrlChange = useCallback$e(
    (e) => {
      const newUrl = e.target.value;
      isUserInputUrlRef.current = true;
      setLocalUrl(newUrl);
      lastExternalUrlRef.current = newUrl;
      if (updateUrlTimeoutRef.current) {
        clearTimeout(updateUrlTimeoutRef.current);
      }
      if (!isComposingUrlRef.current) {
        updateUrlTimeoutRef.current = setTimeout(() => {
          updateParentState("url", newUrl);
          setTimeout(() => {
            isUserInputUrlRef.current = false;
          }, 100);
        }, 150);
      }
    },
    [updateParentState]
  );
  const handleUrlCompositionStart = useCallback$e(() => {
    isComposingUrlRef.current = true;
    isUserInputUrlRef.current = true;
    if (updateUrlTimeoutRef.current) {
      clearTimeout(updateUrlTimeoutRef.current);
      updateUrlTimeoutRef.current = null;
    }
  }, []);
  const handleUrlCompositionEnd = useCallback$e(
    (e) => {
      isComposingUrlRef.current = false;
      const finalValue = e.target.value;
      setLocalUrl(finalValue);
      lastExternalUrlRef.current = finalValue;
      updateParentState("url", finalValue);
      setTimeout(() => {
        isUserInputUrlRef.current = false;
      }, 200);
    },
    [updateParentState]
  );
  const handleUrlKeyDown = useCallback$e((e) => {
    if (e.key === "Backspace" || e.key === "Delete") {
      isUserInputUrlRef.current = true;
      setTimeout(() => {
        isUserInputUrlRef.current = false;
      }, 300);
    }
  }, []);
  const handleMethodChange = useCallback$e(
    (e) => {
      const newMethod = e.target.value;
      setLocalMethod(newMethod);
      updateParentState("method", newMethod);
    },
    [updateParentState]
  );
  const handleBodyChange = useCallback$e(
    (e) => {
      const newBody = e.target.value;
      isUserInputBodyRef.current = true;
      setLocalBody(newBody);
      lastExternalBodyRef.current = newBody;
      if (updateBodyTimeoutRef.current) {
        clearTimeout(updateBodyTimeoutRef.current);
      }
      if (!isComposingBodyRef.current) {
        updateBodyTimeoutRef.current = setTimeout(() => {
          updateParentState("body", newBody);
          setTimeout(() => {
            isUserInputBodyRef.current = false;
          }, 100);
        }, 150);
      }
    },
    [updateParentState]
  );
  const handleBodyCompositionStart = useCallback$e(() => {
    isComposingBodyRef.current = true;
    isUserInputBodyRef.current = true;
    if (updateBodyTimeoutRef.current) {
      clearTimeout(updateBodyTimeoutRef.current);
      updateBodyTimeoutRef.current = null;
    }
  }, []);
  const handleBodyCompositionEnd = useCallback$e(
    (e) => {
      isComposingBodyRef.current = false;
      const finalValue = e.target.value;
      setLocalBody(finalValue);
      lastExternalBodyRef.current = finalValue;
      updateParentState("body", finalValue);
      setTimeout(() => {
        isUserInputBodyRef.current = false;
      }, 200);
    },
    [updateParentState]
  );
  const handleBodyKeyDown = useCallback$e((e) => {
    if (e.key === "Backspace" || e.key === "Delete") {
      isUserInputBodyRef.current = true;
      setTimeout(() => {
        isUserInputBodyRef.current = false;
      }, 300);
    }
  }, []);
  const handleAddHeader = useCallback$e(() => {
    const newHeader = { key: "", value: "" };
    const newHeaders = [...headers, newHeader];
    setHeaders(newHeaders);
    updateParentState("headers", newHeaders);
  }, [headers, updateParentState]);
  const handleDeleteHeader = useCallback$e(
    (index) => {
      const newHeaders = headers.filter((_, i) => i !== index);
      setHeaders(newHeaders);
      updateParentState("headers", newHeaders);
      delete isComposingHeaderKeyRef.current[index];
      delete isComposingHeaderValueRef.current[index];
      delete updateHeaderTimeoutRef.current[`key_${index}`];
      delete updateHeaderTimeoutRef.current[`value_${index}`];
      delete isUserInputHeaderRef.current[`key_${index}`];
      delete isUserInputHeaderRef.current[`value_${index}`];
      delete lastExternalHeaderRef.current[`key_${index}`];
      delete lastExternalHeaderRef.current[`value_${index}`];
    },
    [headers, updateParentState]
  );
  const handleHeaderKeyChange = useCallback$e(
    (index, value) => {
      const fieldKey = `key_${index}`;
      isUserInputHeaderRef.current[fieldKey] = true;
      const newHeaders = [...headers];
      newHeaders[index].key = value;
      setHeaders(newHeaders);
      lastExternalHeaderRef.current[fieldKey] = value;
      if (updateHeaderTimeoutRef.current[fieldKey]) {
        clearTimeout(updateHeaderTimeoutRef.current[fieldKey]);
      }
      if (!isComposingHeaderKeyRef.current[index]) {
        updateHeaderTimeoutRef.current[fieldKey] = setTimeout(() => {
          updateParentState("headers", newHeaders);
          setTimeout(() => {
            isUserInputHeaderRef.current[fieldKey] = false;
          }, 100);
        }, 150);
      }
    },
    [headers, updateParentState]
  );
  const handleHeaderValueChange = useCallback$e(
    (index, value) => {
      const fieldKey = `value_${index}`;
      isUserInputHeaderRef.current[fieldKey] = true;
      const newHeaders = [...headers];
      newHeaders[index].value = value;
      setHeaders(newHeaders);
      lastExternalHeaderRef.current[fieldKey] = value;
      if (updateHeaderTimeoutRef.current[fieldKey]) {
        clearTimeout(updateHeaderTimeoutRef.current[fieldKey]);
      }
      if (!isComposingHeaderValueRef.current[index]) {
        updateHeaderTimeoutRef.current[fieldKey] = setTimeout(() => {
          updateParentState("headers", newHeaders);
          setTimeout(() => {
            isUserInputHeaderRef.current[fieldKey] = false;
          }, 100);
        }, 150);
      }
    },
    [headers, updateParentState]
  );
  const handleHeaderKeyCompositionStart = useCallback$e((index) => {
    isComposingHeaderKeyRef.current[index] = true;
    isUserInputHeaderRef.current[`key_${index}`] = true;
    const fieldKey = `key_${index}`;
    if (updateHeaderTimeoutRef.current[fieldKey]) {
      clearTimeout(updateHeaderTimeoutRef.current[fieldKey]);
      updateHeaderTimeoutRef.current[fieldKey] = null;
    }
  }, []);
  const handleHeaderKeyCompositionEnd = useCallback$e(
    (index, e) => {
      isComposingHeaderKeyRef.current[index] = false;
      const finalValue = e.target.value;
      const newHeaders = [...headers];
      newHeaders[index].key = finalValue;
      setHeaders(newHeaders);
      lastExternalHeaderRef.current[`key_${index}`] = finalValue;
      updateParentState("headers", newHeaders);
      setTimeout(() => {
        isUserInputHeaderRef.current[`key_${index}`] = false;
      }, 200);
    },
    [headers, updateParentState]
  );
  const handleHeaderValueCompositionStart = useCallback$e((index) => {
    isComposingHeaderValueRef.current[index] = true;
    isUserInputHeaderRef.current[`value_${index}`] = true;
    const fieldKey = `value_${index}`;
    if (updateHeaderTimeoutRef.current[fieldKey]) {
      clearTimeout(updateHeaderTimeoutRef.current[fieldKey]);
      updateHeaderTimeoutRef.current[fieldKey] = null;
    }
  }, []);
  const handleHeaderValueCompositionEnd = useCallback$e(
    (index, e) => {
      isComposingHeaderValueRef.current[index] = false;
      const finalValue = e.target.value;
      const newHeaders = [...headers];
      newHeaders[index].value = finalValue;
      setHeaders(newHeaders);
      lastExternalHeaderRef.current[`value_${index}`] = finalValue;
      updateParentState("headers", newHeaders);
      setTimeout(() => {
        isUserInputHeaderRef.current[`value_${index}`] = false;
      }, 200);
    },
    [headers, updateParentState]
  );
  const handleHeaderKeyDown = useCallback$e((index, type, e) => {
    if (e.key === "Backspace" || e.key === "Delete") {
      const fieldKey = `${type}_${index}`;
      isUserInputHeaderRef.current[fieldKey] = true;
      setTimeout(() => {
        isUserInputHeaderRef.current[fieldKey] = false;
      }, 300);
    }
  }, []);
  useEffect$e(() => {
    return () => {
      if (updateUrlTimeoutRef.current) {
        clearTimeout(updateUrlTimeoutRef.current);
      }
      if (updateBodyTimeoutRef.current) {
        clearTimeout(updateBodyTimeoutRef.current);
      }
      Object.values(updateHeaderTimeoutRef.current).forEach((timeout) => {
        if (timeout) clearTimeout(timeout);
      });
    };
  }, []);
  const methodOptions = [
    { value: "GET", label: "GET" },
    { value: "POST", label: "POST" }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-98 max-w-lg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-100 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 rounded-full bg-red-400 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "http" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "HTTP" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-t border-gray-200" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "url" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            type: "text",
            value: localUrl,
            onChange: handleUrlChange,
            onCompositionStart: handleUrlCompositionStart,
            onCompositionEnd: handleUrlCompositionEnd,
            onKeyDown: handleUrlKeyDown,
            className: "w-full border border-gray-300 rounded p-2 text-sm",
            placeholder: "url"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "Method" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "select",
            {
              className: "w-full border border-gray-300 rounded p-2 text-sm bg-white appearance-none",
              value: localMethod,
              onChange: handleMethodChange,
              children: methodOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "option",
                {
                  value: option.value,
                  children: option.label
                },
                option.value
              ))
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "16",
              height: "16",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
            }
          ) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "Header (optional)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: headers.map((header, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "grid grid-cols-12 gap-2 items-center",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-5", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-600 mb-1 font-bold", children: "Key" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    value: header.key,
                    onChange: (e) => handleHeaderKeyChange(index, e.target.value),
                    onCompositionStart: () => handleHeaderKeyCompositionStart(index),
                    onCompositionEnd: (e) => handleHeaderKeyCompositionEnd(index, e),
                    onKeyDown: (e) => handleHeaderKeyDown(index, "key", e),
                    className: "w-full border border-gray-300 rounded px-2 py-1 text-xs",
                    placeholder: "key"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-600 mb-1 font-bold", children: "Value" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    value: header.value,
                    onChange: (e) => handleHeaderValueChange(index, e.target.value),
                    onCompositionStart: () => handleHeaderValueCompositionStart(index),
                    onCompositionEnd: (e) => handleHeaderValueCompositionEnd(index, e),
                    onKeyDown: (e) => handleHeaderKeyDown(index, "value", e),
                    className: "w-full border border-gray-300 rounded px-2 py-1 text-xs",
                    placeholder: "value"
                  }
                )
              ] }),
              headers.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-1 flex justify-center items-end h-full pb-1 mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handleDeleteHeader(index),
                  className: "text-black-500 hover:text-red-600 text-sm p-1",
                  title: "刪除 Header",
                  children: "✕"
                }
              ) })
            ]
          },
          index
        )) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "w-full bg-teal-500 hover:bg-teal-600 text-white rounded-md p-2 flex justify-center items-center mb-4",
          onClick: handleAddHeader,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Add, {})
        }
      ),
      localMethod === "POST" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "Body (optional)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AutoResizeTextarea,
          {
            value: localBody,
            onChange: handleBodyChange,
            onCompositionStart: handleBodyCompositionStart,
            onCompositionEnd: handleBodyCompositionEnd,
            onKeyDown: handleBodyKeyDown,
            placeholder: '{"flow_id": "9e956c37-20ea-47a5-bcd5-3cafc35b967a", "func_id": "q1", "data":"$input"}',
            className: "text-xs font-mono bg-gray-900 text-green-400 border-gray-300",
            style: {
              fontFamily: 'Monaco, Menlo, Consolas, "Courier New", monospace'
            }
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "body",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          left: "-6px",
          transform: "translateY(-50%)"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "output",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          right: "-6px"
        },
        isConnectable
      }
    )
  ] });
};
const HTTPRequestNode = memo$a(HttpRequestNode);

const React$h = await importShared('react');
const {memo: memo$9,useState: useState$i,useEffect: useEffect$d,useCallback: useCallback$d,useRef: useRef$a} = React$h;
const LineNode = ({ data, isConnectable, id }) => {
  const [selectedConfigId, setSelectedConfigId] = useState$i(
    data?.external_service_config_id || ""
  );
  const [serviceConfigs, setServiceConfigs] = useState$i([]);
  const [configLoadError, setConfigLoadError] = useState$i(null);
  const [isLoadingConfigs, setIsLoadingConfigs] = useState$i(false);
  const [webhookUrl, setWebhookUrl] = useState$i("");
  const [isCreatingWebhook, setIsCreatingWebhook] = useState$i(false);
  const isInitialized = useRef$a(false);
  const lastSyncedConfigId = useRef$a(selectedConfigId);
  const lastSyncedWebhookUrl = useRef$a(webhookUrl);
  const isUpdating = useRef$a(false);
  const outputHandles = ["text", "image"];
  const updateParentState = useCallback$d(
    (key, value) => {
      if (isUpdating.current) {
        console.log(`跳過重複更新: ${key}=${value}`);
        return false;
      }
      console.log(`嘗試更新父組件狀態 ${key}=${value}`);
      if (data && typeof data.updateNodeData === "function") {
        isUpdating.current = true;
        try {
          data.updateNodeData(key, value);
          console.log(`使用 updateNodeData 更新 ${key} 成功`);
          if (key === "external_service_config_id") {
            lastSyncedConfigId.current = value;
          } else if (key === "webhook_url") {
            lastSyncedWebhookUrl.current = value;
          }
          return true;
        } finally {
          setTimeout(() => {
            isUpdating.current = false;
          }, 100);
        }
      }
      console.warn(`無法更新父組件的 ${key}`);
      return false;
    },
    [data]
  );
  const loadServiceConfigs = useCallback$d(async () => {
    if (isLoadingConfigs) {
      console.log("已在載入中，跳過重複載入");
      return;
    }
    setIsLoadingConfigs(true);
    setConfigLoadError(null);
    try {
      console.log("開始載入 LINE 服務配置...");
      const configs = await externalService.getServiceConfigOptions("LINE");
      console.log("載入的 LINE 服務配置:", configs);
      if (configs && configs.length > 0) {
        setServiceConfigs(configs);
        if (!isInitialized.current) {
          const currentConfigId = data?.external_service_config_id || selectedConfigId;
          if (currentConfigId) {
            const configExists = configs.some(
              (config) => config.value === currentConfigId.toString()
            );
            if (!configExists) {
              console.log(
                `當前配置 ${currentConfigId} 不在選項列表中，清空選擇`
              );
              setSelectedConfigId("");
              updateParentState("external_service_config_id", "");
            } else {
              console.log(`確認配置存在: ${currentConfigId}`);
              setSelectedConfigId(currentConfigId.toString());
              lastSyncedConfigId.current = currentConfigId.toString();
            }
          }
          isInitialized.current = true;
        }
      } else {
        console.warn("未獲取到 LINE 服務配置或配置列表為空");
        setServiceConfigs([]);
      }
    } catch (error) {
      console.error("載入 LINE 服務配置失敗:", error);
      setConfigLoadError("無法載入服務配置，請稍後再試");
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "載入 LINE 服務配置失敗",
          type: "error",
          duration: 3e3
        });
      }
    } finally {
      setIsLoadingConfigs(false);
    }
  }, []);
  useEffect$d(() => {
    loadServiceConfigs();
  }, []);
  useEffect$d(() => {
    if (isUpdating.current) return;
    let hasChanges = false;
    if (data?.external_service_config_id !== void 0 && data.external_service_config_id !== lastSyncedConfigId.current) {
      console.log(
        `同步配置ID從 ${lastSyncedConfigId.current} 到 ${data.external_service_config_id}`
      );
      setSelectedConfigId(data.external_service_config_id);
      lastSyncedConfigId.current = data.external_service_config_id;
      hasChanges = true;
    }
    if (data?.webhook_url !== void 0 && data.webhook_url !== lastSyncedWebhookUrl.current) {
      console.log(
        `同步 webhook URL 從 "${lastSyncedWebhookUrl.current}" 到 "${data.webhook_url}"`
      );
      setWebhookUrl(data.webhook_url);
      lastSyncedWebhookUrl.current = data.webhook_url;
      hasChanges = true;
    }
    if (hasChanges) {
      console.log("LineNode 數據同步完成");
    }
  }, [data?.external_service_config_id, data?.webhook_url]);
  const handleConfigChange = useCallback$d(
    (configId) => {
      if (configId === selectedConfigId || isUpdating.current) {
        console.log("配置ID未變更或正在更新中，跳過");
        return;
      }
      console.log(`配置變更為ID: ${configId}`);
      setSelectedConfigId(configId);
      updateParentState("external_service_config_id", configId);
    },
    [selectedConfigId, updateParentState]
  );
  const copyToClipboardSimple = useCallback$d(async (text) => {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(text);
          window.notify?.({
            message: "URL 已複製到剪貼板",
            type: "success",
            duration: 2e3
          });
          return;
        } catch (clipboardError) {
          console.warn("Clipboard API 失敗，嘗試 fallback:", clipboardError);
        }
      }
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.cssText = "position:fixed;top:0;left:0;opacity:0;pointer-events:none;";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      const successful = document.execCommand("copy");
      document.body.removeChild(textArea);
      if (successful) {
        window.notify?.({
          message: "URL 已複製到剪貼板",
          type: "success",
          duration: 2e3
        });
      } else {
        throw new Error("所有複製方法都失敗");
      }
    } catch (error) {
      console.error("複製失敗:", error);
      window.notify?.({
        message: "複製失敗，請手動複製 URL",
        type: "error",
        duration: 3e3
      });
    }
  }, []);
  const createWebhook = useCallback$d(
    async (flowId) => {
      setIsCreatingWebhook(true);
      try {
        const url = externalService.createWebhook(flowId);
        console.log("創建 webhook 返回的 URL:", url);
        if (url) {
          setWebhookUrl(url);
          lastSyncedWebhookUrl.current = url;
          if (data?.updateNodeData && typeof data.updateNodeData === "function") {
            data.updateNodeData("webhook_url", url);
            console.log("已將 webhook URL 更新到節點數據:", url);
          } else {
            console.warn("updateNodeData 不可用，無法保存 webhook URL");
          }
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: "Webhook URL 創建成功",
              type: "success",
              duration: 3e3
            });
          }
        } else {
          throw new Error("後端未返回有效的 webhook URL");
        }
      } catch (error) {
        console.error("創建 webhook 失敗:", error);
        if (typeof window !== "undefined" && window.notify) {
          window.notify({
            message: "創建 webhook 失敗",
            type: "error",
            duration: 3e3
          });
        }
      } finally {
        setIsCreatingWebhook(false);
      }
    },
    [data]
  );
  const handleCreateWebhook = useCallback$d(async () => {
    console.log("handleCreateWebhook 被調用");
    const flowId = data?.flowId || window.currentFlowId || data?.flow_id || localStorage.getItem("current_flow_id");
    console.log("檢查到的 flowId:", flowId);
    if (!flowId) {
      console.log("沒有 flow_id，需要先保存流程");
      const event = new CustomEvent("requestSaveFlow", {
        detail: {
          nodeId: id,
          callback: (savedFlowId) => {
            if (savedFlowId) {
              createWebhook(savedFlowId);
            }
          }
        }
      });
      window.dispatchEvent(event);
      return;
    }
    console.log("已有 flow_id，直接創建 webhook");
    await createWebhook(flowId);
  }, [data, createWebhook, id]);
  const calculateLabelWidth = (text) => {
    const baseWidth = 24;
    const charWidth = 8;
    return baseWidth + text.length * charWidth;
  };
  const getHandleColor = (handleType) => {
    const colors = {
      line: "#D3D3D3",
      node: "#00ced1"
    };
    return colors[handleType] || "#00ced1";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-80", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-100 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 bg-[#06C755] rounded-full flex items-center justify-center mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "line" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Line Webhook" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-medium", children: "連結密鑰" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                className: "w-full border border-gray-300 rounded p-2 text-sm appearance-none bg-white pr-8",
                value: selectedConfigId,
                onChange: (e) => handleConfigChange(e.target.value),
                disabled: isLoadingConfigs,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: isLoadingConfigs ? "載入中..." : "選擇連結密鑰" }),
                  serviceConfigs.map((config) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: config.value,
                      children: config.label
                    },
                    config.value
                  ))
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
              }
            ) })
          ] })
        ] }),
        !webhookUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "w-full bg-cyan-500 hover:bg-cyan-600 text-white rounded-md p-3 font-medium disabled:opacity-50 disabled:cursor-not-allowed",
            onClick: handleCreateWebhook,
            disabled: isCreatingWebhook,
            children: isCreatingWebhook ? "創建中..." : "Create a webhook"
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-medium", children: "URL:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative group flex-1 max-w-[250px]", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: webhookUrl,
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className: "block text-sm bg-gray-50 text-blue-600 hover:text-blue-800 underline truncate",
                  children: webhookUrl
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-full left-0 mb-2 px-3 py-2 bg-gray-800 text-white text-xs rounded shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-10 max-w-md break-all", children: webhookUrl })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: () => copyToClipboardSimple(webhookUrl),
                className: "bg-cyan-500 hover:bg-cyan-600 text-white p-2 rounded",
                title: "複製 URL",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    className: "w-4 h-4",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "path",
                      {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        strokeWidth: 2,
                        d: "M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a1 1 0 011 1v3M9 12l2 2 4-4"
                      }
                    )
                  }
                )
              }
            )
          ] })
        ] })
      ] })
    ] }),
    webhookUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-0 top-1/2 transform translate-x-full -translate-y-1/2 ml-2 space-y-2 pointer-events-none", children: outputHandles.map((handleType) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex items-center mb-4",
        style: { pointerEvents: "none" },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "w-3 h-3 rounded-full",
              style: {
                background: "#e5e7eb",
                border: "1px solid #D3D3D3",
                transform: "translateX(-6px)"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "w-4 h-0.5",
              style: {
                backgroundColor: getHandleColor("line"),
                transform: "translateX(-6px)"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "inline-flex items-center px-3 py-1 rounded text-xs font-medium text-white whitespace-nowrap select-none",
              style: {
                backgroundColor: getHandleColor("node"),
                transform: "translateX(-6px)"
              },
              children: handleType
            }
          )
        ]
      },
      handleType
    )) }),
    webhookUrl && outputHandles.map((handleType, index) => {
      const labelWidth = calculateLabelWidth(handleType);
      const totalWidth = labelWidth + 8;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Handle$1,
        {
          type: "source",
          position: Position.Right,
          id: handleType,
          style: {
            background: "transparent",
            border: "none",
            width: `${totalWidth}px`,
            height: "32px",
            right: `-${totalWidth + 6}px`,
            top: `calc(50% + ${(index - (outputHandles.length - 1) / 2) * 40}px)`,
            transform: "translateY(-50%)",
            cursor: "crosshair",
            zIndex: 10
          },
          isConnectable
        },
        handleType
      );
    })
  ] });
};
const LineNode$1 = memo$9(LineNode);

const React$g = await importShared('react');
const {memo: memo$8,useState: useState$h} = React$g;
const TimerNode = ({ data, isConnectable }) => {
  const [hours, setHours] = useState$h(data.hours || 0);
  const [minutes, setMinutes] = useState$h(data.minutes || 0);
  const [seconds, setSeconds] = useState$h(data.seconds || 0);
  const handleTimeChange = (type, value) => {
    if (value !== "" && !/^\d+$/.test(value)) return;
    let numValue = value === "" ? 0 : parseInt(value, 10);
    switch (type) {
      case "hours":
        numValue = Math.max(0, Math.min(99, numValue));
        setHours(numValue);
        break;
      case "minutes":
        numValue = Math.max(0, Math.min(59, numValue));
        setMinutes(numValue);
        break;
      case "seconds":
        numValue = Math.max(0, Math.min(59, numValue));
        setSeconds(numValue);
        break;
      default:
        return;
    }
    if (data.updateNodeData) {
      data.updateNodeData(type, numValue);
    }
  };
  const handleBlur = (type, value) => {
    const formattedValue = value.toString().padStart(2, "0");
    switch (type) {
      case "hours":
        setHours(parseInt(formattedValue, 10));
        break;
      case "minutes":
        setMinutes(parseInt(formattedValue, 10));
        break;
      case "seconds":
        setSeconds(parseInt(formattedValue, 10));
        break;
      default:
        return;
    }
  };
  const incrementTime = (type) => {
    switch (type) {
      case "hours":
        handleTimeChange("hours", hours + 1);
        break;
      case "minutes":
        handleTimeChange("minutes", minutes + 1);
        break;
      case "seconds":
        handleTimeChange("seconds", seconds + 1);
        break;
      default:
        return;
    }
  };
  const decrementTime = (type) => {
    switch (type) {
      case "hours":
        handleTimeChange("hours", hours - 1);
        break;
      case "minutes":
        handleTimeChange("minutes", minutes - 1);
        break;
      case "seconds":
        handleTimeChange("seconds", seconds - 1);
        break;
      default:
        return;
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-64", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-purple-100 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-6 h-6 rounded-full bg-purple-500 flex items-center justify-center text-white mr-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, {}),
        " "
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Timer" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-3", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2", children: "Set time interval" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-20", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-500 mb-1 text-center", children: "Hours" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "bg-gray-200 rounded-t text-gray-700 text-sm h-6",
                onClick: () => incrementTime("hours"),
                onMouseUp: () => document.activeElement.blur(),
                children: "+"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                inputMode: "numeric",
                pattern: "[0-9]*",
                className: "w-full border border-gray-300 rounded-none p-2 text-sm text-center",
                value: hours,
                onChange: (e) => handleTimeChange("hours", e.target.value),
                onBlur: () => handleBlur("hours", hours),
                maxLength: 2
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "bg-gray-200 rounded-b text-gray-700 text-sm h-6",
                onClick: () => decrementTime("hours"),
                onMouseUp: () => document.activeElement.blur(),
                children: "-"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-lg", children: ":" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-20", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-500 mb-1 text-center", children: "Minutes" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "bg-gray-200 rounded-t text-gray-700 text-sm h-6",
                onClick: () => incrementTime("minutes"),
                onMouseUp: () => document.activeElement.blur(),
                children: "+"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                inputMode: "numeric",
                pattern: "[0-9]*",
                className: "w-full border border-gray-300 rounded-none p-2 text-sm text-center",
                value: minutes,
                onChange: (e) => handleTimeChange("minutes", e.target.value),
                onBlur: () => handleBlur("minutes", minutes),
                maxLength: 2
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "bg-gray-200 rounded-b text-gray-700 text-sm h-6",
                onClick: () => decrementTime("minutes"),
                onMouseUp: () => document.activeElement.blur(),
                children: "-"
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-lg", children: ":" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-20", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-500 mb-1 text-center", children: "Seconds" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "bg-gray-200 rounded-t text-gray-700 text-sm h-6",
                onClick: () => incrementTime("seconds"),
                onMouseUp: () => document.activeElement.blur(),
                children: "+"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                inputMode: "numeric",
                pattern: "[0-9]*",
                className: "w-full border border-gray-300 rounded-none p-2 text-sm text-center",
                value: seconds,
                onChange: (e) => handleTimeChange("seconds", e.target.value),
                onBlur: () => handleBlur("seconds", seconds),
                maxLength: 2
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "bg-gray-200 rounded-b text-gray-700 text-sm h-6",
                onClick: () => decrementTime("seconds"),
                onMouseUp: () => document.activeElement.blur(),
                children: "-"
              }
            )
          ] })
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "input",
        style: {
          background: "#555",
          width: "8px",
          height: "8px",
          left: "-4px"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "output",
        style: {
          background: "#555",
          width: "8px",
          height: "8px",
          right: "-4px"
        },
        isConnectable
      }
    )
  ] });
};
const TimerNode$1 = memo$8(TimerNode);

const React$f = await importShared('react');
const {memo: memo$7,useState: useState$g,useEffect: useEffect$c,useCallback: useCallback$c,useRef: useRef$9} = React$f;
const LineMessageNode = ({ data, isConnectable }) => {
  const [selectedConfigId, setSelectedConfigId] = useState$g(
    data?.external_service_config_id || ""
  );
  const [serviceConfigs, setServiceConfigs] = useState$g([]);
  const [configLoadError, setConfigLoadError] = useState$g(null);
  const [isLoadingConfigs, setIsLoadingConfigs] = useState$g(false);
  const [selectedMessagingType, setSelectedMessagingType] = useState$g(
    data?.messaging_type || ""
  );
  const [messagingTypes, setMessagingTypes] = useState$g([]);
  const [messagingTypesLoadError, setMessagingTypesLoadError] = useState$g(null);
  const [isLoadingMessagingTypes, setIsLoadingMessagingTypes] = useState$g(false);
  const isInitialized = useRef$9(false);
  const lastSyncedConfigId = useRef$9(selectedConfigId);
  const lastSyncedMessagingType = useRef$9(selectedMessagingType);
  const isUpdating = useRef$9(false);
  const updateParentState = useCallback$c(
    (key, value) => {
      if (isUpdating.current) {
        console.log(`跳過重複更新: ${key}=${value}`);
        return false;
      }
      console.log(`嘗試更新父組件狀態 ${key}=${value}`);
      try {
        if (data && typeof data.updateNodeData === "function") {
          isUpdating.current = true;
          data.updateNodeData(key, value);
          console.log(`使用 updateNodeData 更新 ${key}`);
          if (key === "external_service_config_id") {
            lastSyncedConfigId.current = value;
          } else if (key === "messaging_type") {
            lastSyncedMessagingType.current = value;
          }
          return true;
        }
      } finally {
        setTimeout(() => {
          isUpdating.current = false;
        }, 100);
      }
      console.warn(`無法更新父組件的 ${key}`);
      return false;
    },
    [data]
  );
  const loadServiceConfigs = useCallback$c(async () => {
    if (isLoadingConfigs) {
      console.log("已在載入服務配置中，跳過重複載入");
      return;
    }
    setIsLoadingConfigs(true);
    setConfigLoadError(null);
    try {
      console.log("開始載入 LINE 服務配置...");
      const configs = await externalService.getServiceConfigOptions("LINE");
      console.log("載入的 LINE 服務配置:", configs);
      if (configs && configs.length > 0) {
        setServiceConfigs(configs);
        if (!isInitialized.current) {
          const currentConfigId = data?.external_service_config_id || selectedConfigId;
          if (currentConfigId) {
            const configExists = configs.some(
              (config) => config.value === currentConfigId.toString()
            );
            if (!configExists) {
              console.log(
                `當前配置 ${currentConfigId} 不在選項列表中，清空選擇`
              );
              setSelectedConfigId("");
              updateParentState("external_service_config_id", "");
            } else {
              console.log(`確認配置存在: ${currentConfigId}`);
              setSelectedConfigId(currentConfigId.toString());
              lastSyncedConfigId.current = currentConfigId.toString();
            }
          }
        }
      } else {
        console.warn("未獲取到 LINE 服務配置或配置列表為空");
        setServiceConfigs([]);
      }
    } catch (error) {
      console.error("載入 LINE 服務配置失敗:", error);
      setConfigLoadError("無法載入服務配置，請稍後再試");
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "載入 LINE 服務配置失敗",
          type: "error",
          duration: 3e3
        });
      }
    } finally {
      setIsLoadingConfigs(false);
    }
  }, []);
  const loadMessagingTypes = useCallback$c(async () => {
    if (isLoadingMessagingTypes) {
      console.log("已在載入 Messaging Types 中，跳過重複載入");
      return;
    }
    setIsLoadingMessagingTypes(true);
    setMessagingTypesLoadError(null);
    try {
      console.log("開始載入 LINE Messaging Types...");
      const types = await externalService.getMessagingTypeOptions("line");
      console.log("載入的 LINE Messaging Types:", types);
      if (types && types.length > 0) {
        setMessagingTypes(types);
        if (!isInitialized.current) {
          const currentMessagingType = data?.messaging_type || selectedMessagingType;
          if (currentMessagingType) {
            const typeExists = types.some(
              (type) => type.value === currentMessagingType
            );
            if (!typeExists) {
              console.log(
                `當前 messaging type ${currentMessagingType} 不在選項列表中，清空選擇`
              );
              setSelectedMessagingType("");
              updateParentState("messaging_type", "");
            } else {
              console.log(`確認 messaging type 存在: ${currentMessagingType}`);
              setSelectedMessagingType(currentMessagingType);
              lastSyncedMessagingType.current = currentMessagingType;
            }
          }
        }
      } else {
        console.warn("未獲取到 LINE Messaging Types，使用預設選項");
        const defaultTypes = [
          { value: "Reply Message", label: "Reply Message" },
          { value: "Push Message", label: "Push Message" }
        ];
        setMessagingTypes(defaultTypes);
      }
    } catch (error) {
      console.error("載入 LINE Messaging Types 失敗:", error);
      if (error.message && error.message.includes("404")) {
        console.warn("Messaging Types API 不存在 (404)，使用預設選項");
        setMessagingTypesLoadError("API 暫不可用，使用預設選項");
      } else {
        setMessagingTypesLoadError("無法載入 Messaging Types，使用預設選項");
        if (typeof window !== "undefined" && window.notify) {
          window.notify({
            message: "載入 LINE Messaging Types 失敗，使用預設選項",
            type: "warning",
            duration: 3e3
          });
        }
      }
      const defaultTypes = [
        { value: "Reply Message", label: "Reply Message" },
        { value: "Push Message", label: "Push Message" }
      ];
      setMessagingTypes(defaultTypes);
    } finally {
      setIsLoadingMessagingTypes(false);
    }
  }, []);
  useEffect$c(() => {
    const initializeData = async () => {
      await Promise.all([loadServiceConfigs(), loadMessagingTypes()]);
      isInitialized.current = true;
    };
    initializeData();
  }, []);
  useEffect$c(() => {
    if (isUpdating.current) return;
    let hasChanges = false;
    console.log("LineNode 數據同步更新:", {
      "data.external_service_config_id": data?.external_service_config_id,
      "data.messaging_type": data?.messaging_type,
      selectedConfigId,
      selectedMessagingType
    });
    if (data?.external_service_config_id !== void 0 && data.external_service_config_id !== selectedConfigId) {
      console.log(
        `同步配置ID從 ${selectedConfigId} 到 ${data.external_service_config_id}`
      );
      setSelectedConfigId(data.external_service_config_id);
      lastSyncedConfigId.current = data.external_service_config_id;
      hasChanges = true;
    }
    if (data?.messaging_type !== void 0 && data.messaging_type !== selectedMessagingType) {
      console.log(
        `同步 messaging type 從 ${selectedMessagingType} 到 ${data.messaging_type}`
      );
      setSelectedMessagingType(data.messaging_type);
      lastSyncedMessagingType.current = data.messaging_type;
      hasChanges = true;
    }
    if (hasChanges) {
      console.log("LineNode 數據同步完成");
    }
  }, [
    data?.external_service_config_id,
    data?.messaging_type,
    selectedConfigId,
    selectedMessagingType
  ]);
  const handleConfigChange = useCallback$c(
    (configId) => {
      if (configId === selectedConfigId || isUpdating.current) {
        console.log("配置ID未變更或正在更新中，跳過");
        return;
      }
      console.log(`配置變更為ID: ${configId}`);
      setSelectedConfigId(configId);
      updateParentState("external_service_config_id", configId);
    },
    [selectedConfigId, updateParentState]
  );
  const handleMessagingTypeChange = useCallback$c(
    (messagingType) => {
      if (messagingType === selectedMessagingType || isUpdating.current) {
        console.log("Messaging Type 未變更或正在更新中，跳過");
        return;
      }
      console.log(`Messaging Type 變更為: ${messagingType}`);
      setSelectedMessagingType(messagingType);
      updateParentState("messaging_type", messagingType);
    },
    [selectedMessagingType, updateParentState]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-80 bg-white", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-100 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 bg-[#06C755] rounded-full flex items-center justify-center mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "line" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Line Message" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-medium", children: "連結密鑰" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                className: "w-full border border-gray-300 rounded p-2 text-sm appearance-none bg-white pr-8",
                value: selectedConfigId,
                onChange: (e) => handleConfigChange(e.target.value),
                disabled: isLoadingConfigs,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: isLoadingConfigs ? "載入中..." : "選擇連結密鑰" }),
                  serviceConfigs.map((config) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: config.value,
                      children: config.label
                    },
                    config.value
                  ))
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
              }
            ) })
          ] }),
          configLoadError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-xs mt-1", children: configLoadError })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "Messaging types" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                className: "w-full border border-gray-300 rounded p-2 text-sm appearance-none bg-white pr-8",
                value: selectedMessagingType,
                onChange: (e) => handleMessagingTypeChange(e.target.value),
                disabled: isLoadingMessagingTypes,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: isLoadingMessagingTypes ? "載入中..." : "選擇 Messaging Type" }),
                  messagingTypes.map((type) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: type.value,
                      children: type.label
                    },
                    type.value
                  ))
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
              }
            ) })
          ] }),
          messagingTypesLoadError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-red-500 text-xs mt-1", children: messagingTypesLoadError })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-1 ml-3 flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-700 mr-2 font-bold block text-sm text-gray-700 mb-2 font-bold", children: "Message" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "message",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          left: "-6px",
          top: "92%",
          transform: "translateY(-50%)"
        },
        isConnectable
      }
    )
  ] });
};
const LineMessageNode$1 = memo$7(LineMessageNode);

const React$e = await importShared('react');
const {memo: memo$6,useState: useState$f,useEffect: useEffect$b,useCallback: useCallback$b} = React$e;
const ExtractDataNode = ({ data, isConnectable }) => {
  const [modelOptions, setModelOptions] = useState$f([
    {
      value: "0",
      label: "GPT-4o",
      description: "OpenAI GPT-4o 支援結構化輸出",
      provider: "AZURE_OPENAI"
    }
  ]);
  const [isLoadingModels, setIsLoadingModels] = useState$f(false);
  const [modelLoadError, setModelLoadError] = useState$f(null);
  const [localModel, setLocalModel] = useState$f(data?.model || "0");
  const [columns, setColumns] = useState$f(data?.columns || []);
  useEffect$b(() => {
    if (data?.model && data.model !== localModel) {
      setLocalModel(data.model);
    }
  }, [data?.model, localModel]);
  useEffect$b(() => {
    if (data?.columns && JSON.stringify(data.columns) !== JSON.stringify(columns)) {
      setColumns(data.columns);
    }
  }, [data?.columns, columns]);
  const loadModels = async () => {
    if (isLoadingModels) return;
    setIsLoadingModels(true);
    setModelLoadError(null);
    try {
      console.log("開始加載結構化輸出模型...");
      const options = await llmService.getStructuredOutputModelOptions();
      console.log("獲取到的結構化輸出模型選項:", options);
      if (options && options.length > 0) {
        setModelOptions(options);
        const isCurrentModelValid = options.some(
          (opt) => opt.value === localModel
        );
        if (!isCurrentModelValid) {
          const defaultModel = options[0].value;
          setLocalModel(defaultModel);
          updateParentState("model", defaultModel);
          console.log("選擇預設結構化輸出模型:", defaultModel);
        }
      }
    } catch (error) {
      console.error("加載結構化輸出模型失敗:", error);
      if (!(error.message && (error.message.includes("已有進行中的結構化輸出模型請求") || error.message.includes("進行中的請求") || error.message.includes("使用相同請求")))) {
        setModelLoadError("無法載入結構化輸出模型列表，請稍後再試");
      }
    } finally {
      setIsLoadingModels(false);
    }
  };
  useEffect$b(() => {
    loadModels();
  }, []);
  const updateParentState = useCallback$b(
    (key, value) => {
      if (data && typeof data.updateNodeData === "function") {
        data.updateNodeData(key, value);
        return true;
      }
      if (data) {
        data[key] = value;
        return true;
      }
      return false;
    },
    [data]
  );
  const handleModelChange = useCallback$b(
    (e) => {
      const newModelValue = e.target.value;
      setLocalModel(newModelValue);
      updateParentState("model", newModelValue);
      console.log("切換結構化輸出模型:", newModelValue);
    },
    [updateParentState]
  );
  const handleAddColumn = useCallback$b(() => {
    const newColumn = {
      name: "",
      type: "text",
      description: ""
    };
    const newColumns = [...columns, newColumn];
    setColumns(newColumns);
    updateParentState("columns", newColumns);
    console.log("新增欄位", newColumn);
  }, [columns, updateParentState]);
  const handleDeleteColumn = useCallback$b(
    (index) => {
      const newColumns = columns.filter((_, i) => i !== index);
      setColumns(newColumns);
      updateParentState("columns", newColumns);
      console.log("刪除欄位", index);
    },
    [columns, updateParentState]
  );
  const handleColumnNameChange = useCallback$b(
    (index, value) => {
      const newColumns = [...columns];
      newColumns[index].name = value;
      setColumns(newColumns);
      updateParentState("columns", newColumns);
    },
    [columns, updateParentState]
  );
  const handleColumnTypeChange = useCallback$b(
    (index, value) => {
      const newColumns = [...columns];
      newColumns[index].type = value;
      setColumns(newColumns);
      updateParentState("columns", newColumns);
    },
    [columns, updateParentState]
  );
  const handleColumnDescriptionChange = useCallback$b(
    (index, value) => {
      const newColumns = [...columns];
      newColumns[index].description = value;
      setColumns(newColumns);
      updateParentState("columns", newColumns);
    },
    [columns, updateParentState]
  );
  const typeOptions = [
    { value: "text", label: "text" },
    { value: "number", label: "number" },
    { value: "boolean", label: "boolean" }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-98 max-w-lg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-orange-50 p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 rounded-full bg-orange-400 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "ai" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Data Extractor" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border-t border-gray-200" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "Model" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "select",
            {
              className: `w-full border border-gray-300 rounded p-2 text-sm bg-white appearance-none
                ${isLoadingModels ? "opacity-70 cursor-wait" : ""} 
                ${modelLoadError ? "border-red-300" : ""}`,
              value: localModel,
              onChange: handleModelChange,
              disabled: isLoadingModels,
              children: modelOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "option",
                {
                  value: option.value,
                  title: option.description,
                  children: [
                    option.label,
                    " ",
                    option.provider ? `(${option.provider})` : ""
                  ]
                },
                option.value
              ))
            }
          ),
          isLoadingModels ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-2 top-1/2 transform -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-b-2 border-gray-500" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "16",
              height: "16",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
            }
          ) })
        ] }),
        modelLoadError && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xs text-red-500 mt-1", children: modelLoadError })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-bold", children: "Context" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "Data" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: columns.map((column, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "grid grid-cols-12 gap-2 items-start bg-gray-50 border border-gray-200 rounded p-2",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-600 mb-1 font-bold", children: "名稱" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    value: column.name,
                    onChange: (e) => handleColumnNameChange(index, e.target.value),
                    className: "w-full border border-gray-300 rounded px-2 py-1 text-xs",
                    placeholder: "請輸入欄位名稱..."
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-3", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-600 mb-1 font-bold", children: "類型" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "select",
                  {
                    value: column.type,
                    onChange: (e) => handleColumnTypeChange(index, e.target.value),
                    className: "w-full border border-gray-300 rounded px-2 py-1 text-xs bg-white",
                    children: typeOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "option",
                      {
                        value: option.value,
                        children: option.label
                      },
                      option.value
                    ))
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "col-span-4", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-600 mb-1 font-bold", children: "描述" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "textarea",
                  {
                    value: column.description,
                    onChange: (e) => handleColumnDescriptionChange(index, e.target.value),
                    className: "w-full border border-gray-300 rounded px-2 py-1 text-xs resize-none min-h-[24px] max-h-[60px] overflow-hidden",
                    placeholder: "請描述提取內容/規則...",
                    rows: "1",
                    style: {
                      height: `${Math.min(
                        Math.max(
                          24,
                          column.description.split("\n").length * 20 + 4
                        ),
                        60
                      )}px`
                    },
                    maxLength: "200"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-1 flex justify-center items-center h-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => handleDeleteColumn(index),
                  className: "text-black-500 hover:text-teal-600 text-sm p-1",
                  title: "刪除欄位",
                  children: "✕"
                }
              ) })
            ]
          },
          index
        )) }),
        columns.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center text-gray-500 text-sm py-4 border-2 border-dashed border-gray-300 rounded", children: "點擊下方按鈕新增資料欄位" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "w-full bg-teal-500 hover:bg-teal-600 text-white rounded-md p-2 flex justify-center items-center",
          onClick: handleAddColumn,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Add, {})
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "context-input",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          left: "-6px",
          transform: "translateY(-50%)"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "output",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          right: "-6px"
        },
        isConnectable
      }
    )
  ] });
};
const ExtractDataNode$1 = memo$6(ExtractDataNode);

const React$d = await importShared('react');
const {memo: memo$5,useState: useState$e,useEffect: useEffect$a,useCallback: useCallback$a,useRef: useRef$8} = React$d;
const QOCAAimNode = ({ data, isConnectable }) => {
  const [selectedAim, setSelectedAim] = useState$e(data?.aim_ml_id?.data || "");
  const [trainingId, setTrainingId] = useState$e(data?.training_id?.data || 0);
  const [simulatorId, setSimulatorId] = useState$e(
    data?.simulator_id?.data || ""
  );
  const [enableExplain, setEnableExplain] = useState$e(
    data?.enable_explain?.data ?? true
  );
  const [promptText, setPromptText] = useState$e(data?.prompt?.data || "");
  const [llmId, setLlmId] = useState$e(data?.llm_id?.data || 0);
  const [showRefinePrompt, setShowRefinePrompt] = useState$e(false);
  const [modelFieldsInfo, setModelFieldsInfo] = useState$e(
    data?.model_fields_info?.data || ""
  );
  const [aimOptions, setAimOptions] = useState$e([]);
  const [llmVisionOptions, setLlmVisionOptions] = useState$e([]);
  const [isLoadingAimOptions, setIsLoadingAimOptions] = useState$e(false);
  const [isLoadingLlmVisionOptions, setIsLoadingLlmVisionOptions] = useState$e(false);
  const [isLoadingFieldInfo, setIsLoadingFieldInfo] = useState$e(false);
  const isUpdating = useRef$8(false);
  const hasInitializedAim = useRef$8(false);
  const hasInitializedLlmVision = useRef$8(false);
  const isComposingRef = useRef$8(false);
  const updateTimeoutRef = useRef$8(null);
  const lastExternalValueRef = useRef$8(data?.prompt?.data || "");
  const isUserInputRef = useRef$8(false);
  const loadAimOptions = useCallback$a(async () => {
    if (isLoadingAimOptions || hasInitializedAim.current) {
      console.log("AIM 選項已在載入中或已初始化，跳過重複載入");
      return;
    }
    hasInitializedAim.current = true;
    setIsLoadingAimOptions(true);
    try {
      console.log("開始載入 AIM 模型選項...");
      const options = await aimService.getAIMModelOptions();
      console.log("載入的 AIM 模型選項:", options);
      if (options && options.length > 0) {
        setAimOptions(options);
      } else {
        console.warn("未獲取到 AIM 模型選項或選項列表為空，設置空陣列");
        setAimOptions([]);
      }
    } catch (error) {
      console.error("載入 AIM 模型選項失敗:", error);
      setAimOptions([]);
      hasInitializedAim.current = false;
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "載入 AIM 模型選項失敗",
          type: "error",
          duration: 3e3
        });
      }
    } finally {
      setIsLoadingAimOptions(false);
    }
  }, []);
  const loadLlmVisionOptions = useCallback$a(async () => {
    if (isLoadingLlmVisionOptions || hasInitializedLlmVision.current) {
      console.log("LLM Vision 選項已在載入中或已初始化，跳過重複載入");
      return;
    }
    hasInitializedLlmVision.current = true;
    setIsLoadingLlmVisionOptions(true);
    try {
      console.log("開始載入 LLM Vision 模型選項...");
      const options = await aimService.getLLMVisionModelOptions();
      console.log("載入的 LLM Vision 模型選項:", options);
      if (options && options.length > 0) {
        setLlmVisionOptions(options);
      } else {
        console.warn("未獲取到 LLM Vision 模型選項或選項列表為空，設置空陣列");
        setLlmVisionOptions([]);
      }
    } catch (error) {
      console.error("載入 LLM Vision 模型選項失敗:", error);
      setLlmVisionOptions([]);
      hasInitializedLlmVision.current = false;
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "載入 LLM Vision 模型選項失敗",
          type: "error",
          duration: 3e3
        });
      }
    } finally {
      setIsLoadingLlmVisionOptions(false);
    }
  }, []);
  const loadModelFieldsInfo = useCallback$a(async (targetTrainingId) => {
    if (!targetTrainingId || targetTrainingId === 0) {
      console.log("training_id 無效，清空欄位資訊");
      setModelFieldsInfo("");
      updateParentState("model_fields_info", { data: "" });
      return;
    }
    setIsLoadingFieldInfo(true);
    try {
      console.log(`開始載入模型欄位資訊 (training_id: ${targetTrainingId})...`);
      const fieldInfo = await aimService.getAIMFieldInfo(targetTrainingId);
      console.log("載入的模型欄位資訊:", fieldInfo);
      setModelFieldsInfo(fieldInfo);
      updateParentState("model_fields_info", { data: fieldInfo });
    } catch (error) {
      console.error("載入模型欄位資訊失敗:", error);
      setModelFieldsInfo("");
      updateParentState("model_fields_info", { data: "" });
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "載入模型欄位資訊失敗",
          type: "error",
          duration: 3e3
        });
      }
    } finally {
      setIsLoadingFieldInfo(false);
    }
  }, []);
  useEffect$a(() => {
    loadAimOptions();
    loadLlmVisionOptions();
  }, [loadAimOptions, loadLlmVisionOptions]);
  const outputHandles = enableExplain ? ["text", "images"] : ["text"];
  const updateParentState = useCallback$a(
    (key, value) => {
      console.log(`updateParentState 被調用: ${key}`, value);
      if (data && typeof data.updateNodeData === "function") {
        const propertyMap = {
          aim_ml_id: "selectedAim",
          training_id: "trainingId",
          simulator_id: "simulatorId",
          enable_explain: "enableExplain",
          llm_id: "llmId",
          prompt: "promptText",
          model_fields_info: "modelFieldsInfo"
          // 新增欄位資訊映射
        };
        const propertyName = propertyMap[key] || key;
        const propertyValue = value.data !== void 0 ? value.data : value;
        data.updateNodeData(propertyName, propertyValue);
        console.log(`更新屬性 ${propertyName}:`, propertyValue);
      } else {
        console.error("data.updateNodeData 不存在或不是函數", data);
      }
    },
    [data]
  );
  useEffect$a(() => {
    if (isUpdating.current) {
      console.log("正在更新中，跳過同步");
      return;
    }
    let hasChanges = false;
    if (data?.selectedAim !== void 0 && data.selectedAim !== selectedAim) {
      console.log("同步 selectedAim:", data.selectedAim, "當前:", selectedAim);
      setSelectedAim(data.selectedAim);
      hasChanges = true;
    }
    if (data?.trainingId !== void 0 && data.trainingId !== trainingId) {
      console.log("同步 trainingId:", data.trainingId, "當前:", trainingId);
      setTrainingId(data.trainingId);
      hasChanges = true;
    }
    if (data?.simulatorId !== void 0 && data.simulatorId !== simulatorId) {
      console.log("同步 simulatorId:", data.simulatorId, "當前:", simulatorId);
      setSimulatorId(data.simulatorId);
      hasChanges = true;
    }
    if (data?.enableExplain !== void 0 && data.enableExplain !== enableExplain) {
      console.log(
        "同步 enableExplain:",
        data.enableExplain,
        "當前:",
        enableExplain
      );
      setEnableExplain(data.enableExplain);
      hasChanges = true;
    }
    if (data?.promptText !== void 0 && data.promptText !== lastExternalValueRef.current && !isComposingRef.current && !isUserInputRef.current) {
      console.log("同步 promptText:", data.promptText, "當前:", promptText);
      setPromptText(data.promptText);
      lastExternalValueRef.current = data.promptText;
      hasChanges = true;
    }
    if (data?.llmId !== void 0 && data.llmId !== llmId) {
      console.log("同步 llmId:", data.llmId, "當前:", llmId);
      setLlmId(data.llmId);
      hasChanges = true;
    }
    if (data?.modelFieldsInfo !== void 0 && data.modelFieldsInfo !== modelFieldsInfo) {
      console.log(
        "同步 modelFieldsInfo:",
        data.modelFieldsInfo,
        "當前:",
        modelFieldsInfo
      );
      setModelFieldsInfo(data.modelFieldsInfo);
      hasChanges = true;
    }
    if (hasChanges) {
      console.log("檢測到數據變化，已同步");
    }
  }, [
    data?.selectedAim,
    data?.trainingId,
    data?.simulatorId,
    data?.enableExplain,
    data?.promptText,
    data?.llmId,
    data?.modelFieldsInfo,
    // 新增依賴
    selectedAim,
    trainingId,
    simulatorId,
    enableExplain,
    promptText,
    llmId,
    modelFieldsInfo
  ]);
  useEffect$a(() => {
    console.log("🔍 QOCA AIM 節點狀態監控:", {
      selectedAim,
      llmId,
      enableExplain,
      modelFieldsInfo,
      "data.llm_id": data?.llm_id,
      "data.llmId": data?.llmId,
      "data.modelFieldsInfo": data?.modelFieldsInfo
    });
  }, [
    selectedAim,
    llmId,
    enableExplain,
    modelFieldsInfo,
    data?.llm_id,
    data?.llmId,
    data?.modelFieldsInfo
  ]);
  const handleAimChange = useCallback$a(
    async (aimValue) => {
      console.log("handleAimChange:", selectedAim, "->", aimValue);
      isUpdating.current = true;
      try {
        setSelectedAim(aimValue);
        const selectedModel = aimOptions.find(
          (option) => option.value === aimValue
        );
        console.log("選中的模型:", selectedModel);
        if (selectedModel) {
          updateParentState("aim_ml_id", { data: aimValue });
          updateParentState("training_id", {
            data: selectedModel.training_id || 0
          });
          updateParentState("simulator_id", {
            data: selectedModel.simulator_id || ""
          });
          setTrainingId(selectedModel.training_id || 0);
          setSimulatorId(selectedModel.simulator_id || "");
          if (selectedModel.training_id && selectedModel.training_id !== 0) {
            console.log(
              `載入模型欄位資訊 (training_id: ${selectedModel.training_id})`
            );
            await loadModelFieldsInfo(selectedModel.training_id);
          } else {
            console.log("training_id 無效，清空欄位資訊");
            setModelFieldsInfo("");
            updateParentState("model_fields_info", { data: "" });
          }
          console.log("AIM 模型批量更新完成");
        }
      } finally {
        setTimeout(() => {
          isUpdating.current = false;
          console.log("AIM 模型更新完成");
        }, 300);
      }
    },
    [selectedAim, aimOptions, updateParentState, loadModelFieldsInfo]
  );
  const handleEnableExplainToggle = useCallback$a(() => {
    const newValue = !enableExplain;
    console.log("handleEnableExplainToggle:", enableExplain, "->", newValue);
    isUpdating.current = true;
    try {
      setEnableExplain(newValue);
      updateParentState("enable_explain", { data: newValue });
    } finally {
      setTimeout(() => {
        isUpdating.current = false;
        console.log("enableExplain 更新完成");
      }, 300);
    }
  }, [enableExplain, updateParentState]);
  const handleLlmChange = useCallback$a(
    (llmValue) => {
      console.log("handleLlmChange:", llmId, "->", llmValue);
      const numericValue = parseInt(llmValue);
      isUpdating.current = true;
      try {
        setLlmId(numericValue);
        updateParentState("llm_id", { data: numericValue });
      } finally {
        setTimeout(() => {
          isUpdating.current = false;
          console.log("LLM 模型更新完成");
        }, 300);
      }
    },
    [llmId, updateParentState]
  );
  const handlePromptChange = useCallback$a(
    (e) => {
      const value = e.target.value;
      isUserInputRef.current = true;
      setPromptText(value);
      lastExternalValueRef.current = value;
      if (updateTimeoutRef.current) {
        clearTimeout(updateTimeoutRef.current);
      }
      if (!isComposingRef.current) {
        updateTimeoutRef.current = setTimeout(() => {
          updateParentState("prompt", {
            type: "string",
            data: value,
            node_id: data?.id || ""
          });
          setTimeout(() => {
            isUserInputRef.current = false;
          }, 100);
        }, 150);
      }
    },
    [updateParentState, data?.id]
  );
  const handleCompositionStart = useCallback$a(() => {
    isComposingRef.current = true;
    isUserInputRef.current = true;
    if (updateTimeoutRef.current) {
      clearTimeout(updateTimeoutRef.current);
      updateTimeoutRef.current = null;
    }
  }, []);
  const handleCompositionEnd = useCallback$a(
    (e) => {
      isComposingRef.current = false;
      const finalText = e.target.value;
      setPromptText(finalText);
      lastExternalValueRef.current = finalText;
      updateParentState("prompt", {
        type: "string",
        data: finalText,
        node_id: data?.id || ""
      });
      setTimeout(() => {
        isUserInputRef.current = false;
      }, 200);
    },
    [updateParentState, data?.id]
  );
  const handleKeyDown = useCallback$a((e) => {
    if (e.key === "Backspace" || e.key === "Delete") {
      isUserInputRef.current = true;
      setTimeout(() => {
        isUserInputRef.current = false;
      }, 300);
    }
  }, []);
  const handleRefinePromptClick = useCallback$a(() => {
    const validation = PromptGeneratorService.validateParameters(
      llmId,
      promptText
    );
    if (!validation.isValid) {
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: validation.errors[0],
          type: "error",
          duration: 3e3
        });
      }
      return;
    }
    setShowRefinePrompt(true);
  }, [llmId, promptText]);
  const handleOptimizedPromptApply = useCallback$a(
    (optimizedPrompt) => {
      setPromptText(optimizedPrompt);
      lastExternalValueRef.current = optimizedPrompt;
      updateParentState("prompt", {
        type: "string",
        data: optimizedPrompt,
        node_id: data?.id || ""
      });
      console.log("優化後的 Prompt 已應用:", optimizedPrompt);
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "優化 Prompt 已應用",
          type: "success",
          duration: 2e3
        });
      }
    },
    [updateParentState, data?.id]
  );
  const handleOptimizedPromptCopy = useCallback$a(() => {
    console.log("優化後的 Prompt 已複製到剪貼板");
  }, []);
  const closeRefinePrompt = useCallback$a(() => {
    setShowRefinePrompt(false);
  }, []);
  useEffect$a(() => {
    return () => {
      if (updateTimeoutRef.current) {
        clearTimeout(updateTimeoutRef.current);
      }
    };
  }, []);
  const calculateLabelWidth = (text) => {
    const baseWidth = 24;
    const charWidth = 8;
    return baseWidth + text.length * charWidth;
  };
  const getHandleColor = (handleType) => {
    const colors = {
      line: "#D3D3D3",
      node: "#00ced1"
    };
    return colors[handleType] || "#00ced1";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "input",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          left: "-6px",
          top: "50%",
          transform: "translateY(-50%)"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-80", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-gray-100 rounded-t-lg p-4 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconBase,
          {
            type: "aim",
            className: "text-teal-600"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "QOCA aim" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4 space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-medium", children: "aim 模型" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                className: `w-full border border-gray-300 rounded p-2 text-sm appearance-none bg-white pr-8
                  ${showRefinePrompt ? "opacity-50 cursor-not-allowed" : ""}`,
                value: selectedAim,
                onChange: (e) => handleAimChange(e.target.value),
                disabled: isLoadingAimOptions || showRefinePrompt,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: isLoadingAimOptions ? "載入中..." : "選擇 AIM 模型" }),
                  aimOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: option.value,
                      children: option.label
                    },
                    option.value
                  ))
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
              }
            ) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm text-gray-700 font-medium", children: "結果解釋" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: `relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${enableExplain ? "bg-cyan-500" : "bg-gray-200"} ${showRefinePrompt ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}`,
              onClick: showRefinePrompt ? void 0 : handleEnableExplainToggle,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "span",
                {
                  className: `inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${enableExplain ? "translate-x-6" : "translate-x-1"}`
                }
              )
            }
          )
        ] }),
        enableExplain && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "LLM Vision 模型" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  className: `w-full border border-gray-300 rounded p-2 text-sm appearance-none bg-white pr-8
                      ${showRefinePrompt ? "opacity-50 cursor-not-allowed" : ""}`,
                  value: llmId,
                  onChange: (e) => handleLlmChange(e.target.value),
                  disabled: isLoadingLlmVisionOptions || showRefinePrompt,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: isLoadingLlmVisionOptions ? "載入中..." : "選擇 LLM Vision 模型" }),
                    llmVisionOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "option",
                      {
                        value: option.value,
                        title: option.description ? `${option.description} (${option.provider})` : option.provider,
                        children: option.label
                      },
                      option.value
                    ))
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "16",
                  height: "16",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  stroke: "currentColor",
                  strokeWidth: "2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
                }
              ) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-1", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 font-bold", children: "Prompt" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: handleRefinePromptClick,
                  disabled: !promptText || promptText.trim().length === 0 || !llmId,
                  className: "group w-6 h-6 disabled:cursor-not-allowed rounded flex items-center justify-center transition-colors",
                  title: "Refine prompt",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: promptIcon,
                        width: 18,
                        height: 18,
                        style: {
                          maxWidth: "100%",
                          maxHeight: "100%",
                          objectFit: "contain"
                        },
                        className: "max-w-full max-h-full object-contain group-disabled:hidden"
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "img",
                      {
                        src: promptDisabledIcon,
                        width: 18,
                        height: 18,
                        style: {
                          maxWidth: "100%",
                          maxHeight: "100%",
                          objectFit: "contain"
                        },
                        className: "max-w-full max-h-full object-contain hidden group-disabled:block"
                      }
                    )
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              AutoResizeTextarea,
              {
                value: promptText,
                onChange: handlePromptChange,
                onCompositionStart: handleCompositionStart,
                onCompositionEnd: handleCompositionEnd,
                onKeyDown: handleKeyDown,
                placeholder: "Type your prompt here.",
                className: "w-full border border-gray-300 rounded p-2 text-sm min-h-[80px] pr-10",
                disabled: showRefinePrompt
              }
            ) })
          ] })
        ] })
      ] })
    ] }),
    enableExplain && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-0 top-1/2 transform translate-x-full -translate-y-1/2 ml-2 space-y-2 pointer-events-none", children: outputHandles.map((handleType) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex items-center mb-4",
        style: { pointerEvents: "none" },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "w-3 h-3 rounded-full",
              style: {
                background: "#e5e7eb",
                border: "1px solid #d1d5db",
                transform: "translateX(-6px)"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "w-4 h-0.5",
              style: {
                backgroundColor: getHandleColor("line"),
                transform: "translateX(-6px)"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: "inline-flex items-center px-3 py-1 rounded text-xs font-bold text-white whitespace-nowrap select-none",
              style: {
                backgroundColor: getHandleColor("node"),
                transform: "translateX(-6px)"
              },
              children: handleType
            }
          )
        ]
      },
      handleType
    )) }),
    outputHandles.map((handleType, index) => {
      const labelWidth = calculateLabelWidth(handleType);
      const totalWidth = labelWidth + 8;
      const style = enableExplain ? {
        background: "transparent",
        border: "none",
        width: `${totalWidth}px`,
        height: "32px",
        right: `-${totalWidth + 6}px`,
        top: `calc(50% + ${(index - (outputHandles.length - 1) / 2) * 40}px)`,
        transform: "translateY(-50%)",
        cursor: "crosshair",
        zIndex: 10
      } : {
        background: "#e5e7eb",
        border: "1px solid #D3D3D3",
        width: "12px",
        height: "12px",
        right: "-6px"
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Handle$1,
        {
          type: "source",
          position: Position.Right,
          id: handleType,
          style,
          isConnectable
        },
        handleType
      );
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RefinePromptOverlay,
      {
        isOpen: showRefinePrompt,
        onClose: closeRefinePrompt,
        originalPrompt: promptText,
        llmId,
        onOptimizedPromptApply: handleOptimizedPromptApply,
        onOptimizedPromptCopy: handleOptimizedPromptCopy,
        nodePosition: { x: data?.position?.x || 0, y: data?.position?.y || 0 },
        offsetX: 330,
        offsetY: -150
      }
    )
  ] });
};
const QOCAAimNode$1 = memo$5(QOCAAimNode);

const React$c = await importShared('react');
const {useCallback: useCallback$9,useState: useState$d,useEffect: useEffect$9} = React$c;
const SelectableTextWrapper = ({ children, className = "", ...rest }) => {
  const reactFlowInstance = useReactFlow();
  const [isSelecting, setIsSelecting] = useState$d(false);
  const [startPos, setStartPos] = useState$d({ x: 0, y: 0 });
  const setNodesDraggableState = useCallback$9(
    (draggable) => {
      try {
        if (reactFlowInstance && typeof reactFlowInstance.setNodesDraggable === "function") {
          reactFlowInstance.setNodesDraggable(draggable);
        } else if (reactFlowInstance && typeof reactFlowInstance.getNodes === "function") {
          const nodes = reactFlowInstance.getNodes();
          const updatedNodes = nodes.map((node) => ({
            ...node,
            draggable
          }));
          if (typeof reactFlowInstance.setNodes === "function") {
            reactFlowInstance.setNodes(updatedNodes);
          }
        }
      } catch (error) {
        console.warn("無法設置節點拖拽狀態:", error);
      }
    },
    [reactFlowInstance]
  );
  const handleMouseDown = useCallback$9((e) => {
    if (e.button !== 0) return;
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable || e.target.tagName === "BUTTON" || e.target.tagName === "SELECT") {
      return;
    }
    setStartPos({ x: e.clientX, y: e.clientY });
    e.stopPropagation();
  }, []);
  const handleMouseMove = useCallback$9(
    (e) => {
      if (e.buttons !== 1) return;
      const dx = Math.abs(e.clientX - startPos.x);
      const dy = Math.abs(e.clientY - startPos.y);
      if (dx > 3 || dy > 3) {
        if (!isSelecting) {
          setIsSelecting(true);
          setNodesDraggableState(false);
          e.stopPropagation();
        }
      }
    },
    [isSelecting, startPos, setNodesDraggableState]
  );
  const handleMouseUp = useCallback$9(
    (e) => {
      if (isSelecting) {
        e.stopPropagation();
        setTimeout(() => {
          setIsSelecting(false);
          setNodesDraggableState(true);
        }, 0);
      }
    },
    [isSelecting, setNodesDraggableState]
  );
  const handleDoubleClick = useCallback$9((e) => {
    if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.isContentEditable) {
      e.stopPropagation();
      return;
    }
    e.stopPropagation();
  }, []);
  useEffect$9(() => {
    return () => {
      if (isSelecting) {
        setNodesDraggableState(true);
      }
    };
  }, [isSelecting, setNodesDraggableState]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `selectable-text-wrapper ${className} ${isSelecting ? "selecting" : ""}`,
      onMouseDown: handleMouseDown,
      onMouseMove: handleMouseMove,
      onMouseUp: handleMouseUp,
      onDoubleClick: handleDoubleClick,
      style: {
        userSelect: "text",
        // 確保文字可以被選擇
        cursor: isSelecting ? "text" : "default"
      },
      ...rest,
      children
    }
  );
};

const React$b = await importShared('react');
const {useState: useState$c,useRef: useRef$7,useEffect: useEffect$8,useCallback: useCallback$8} = React$b;

const DateTimeSelector = ({
  value,
  onChange,
  placeholder = "選擇日期時間",
  disabled = false,
  className = "",
  position = "center",
  offsetX = 0,
  offsetY = 0
}) => {
  const [isOpen, setIsOpen] = useState$c(false);
  const [selectedDate, setSelectedDate] = useState$c(/* @__PURE__ */ new Date());
  const [currentMonth, setCurrentMonth] = useState$c(/* @__PURE__ */ new Date());
  const [selectedTime, setSelectedTime] = useState$c({
    hour: 1,
    minute: 0,
    period: "AM"
  });
  const [displayValue, setDisplayValue] = useState$c("");
  const [showYearMonthPicker, setShowYearMonthPicker] = useState$c(false);
  const [tempYear, setTempYear] = useState$c((/* @__PURE__ */ new Date()).getFullYear());
  const [tempMonth, setTempMonth] = useState$c((/* @__PURE__ */ new Date()).getMonth());
  const textFieldRef = useRef$7(null);
  const overlayRef = useRef$7(null);
  const getDialogPosition = useCallback$8(() => {
    if (!textFieldRef.current || position === "center") {
      return {
        position: "fixed",
        top: "50%",
        left: "50%",
        transform: "translate(-50%, -50%)",
        zIndex: 9999
      };
    }
    const rect = textFieldRef.current.getBoundingClientRect();
    const dialogWidth = 320;
    const dialogHeight = 400;
    let style = {
      position: "fixed",
      zIndex: 9999
    };
    switch (position) {
      case "top-left":
        style.bottom = `${window.innerHeight - rect.top + 10}px`;
        style.right = `${window.innerWidth - rect.left}px`;
        style.transform = "translate(0, 0)";
        break;
      case "top-center":
        style.bottom = `${window.innerHeight - rect.top + 10}px`;
        style.left = `${rect.left + rect.width / 2}px`;
        style.transform = "translateX(-50%)";
        break;
      case "top-right":
        style.bottom = `${window.innerHeight - rect.top + 10}px`;
        style.left = `${rect.right}px`;
        style.transform = "translate(0, 0)";
        break;
      case "left":
        style.top = `${rect.top}px`;
        style.right = `${window.innerWidth - rect.left + 10}px`;
        style.transform = "translate(0, 0)";
        break;
      case "right":
        style.top = `${rect.top}px`;
        style.left = `${rect.right + 10}px`;
        style.transform = "translate(0, 0)";
        break;
      case "bottom-left":
        style.top = `${rect.bottom + 10}px`;
        style.right = `${window.innerWidth - rect.left}px`;
        style.transform = "translate(0, 0)";
        break;
      case "bottom-center":
        style.top = `${rect.bottom + 10}px`;
        style.left = `${rect.left + rect.width / 2}px`;
        style.transform = "translateX(-50%)";
        break;
      case "bottom-right":
      default:
        style.top = `150px`;
        style.left = `150px`;
        style.transform = "translate(0, 0)";
        break;
    }
    if (offsetX !== 0) {
      if (style.left) {
        style.left = `${parseInt(style.left) + offsetX}px`;
      } else if (style.right) {
        style.right = `${parseInt(style.right) - offsetX}px`;
      }
    }
    if (offsetY !== 0) {
      if (style.top) {
        style.top = `${parseInt(style.top) + offsetY}px`;
      } else if (style.bottom) {
        style.bottom = `${parseInt(style.bottom) - offsetY}px`;
      }
    }
    const maxLeft = window.innerWidth - dialogWidth - 20;
    const maxTop = window.innerHeight - dialogHeight - 20;
    if (style.left && parseInt(style.left) > maxLeft) {
      style.left = `${maxLeft}px`;
    }
    if (style.left && parseInt(style.left) < 20) {
      style.left = "20px";
    }
    if (style.top && parseInt(style.top) > maxTop) {
      style.top = `${maxTop}px`;
    }
    if (style.top && parseInt(style.top) < 20) {
      style.top = "20px";
    }
    return style;
  }, [position, offsetX, offsetY]);
  const formatDisplayValue = useCallback$8((date, time) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    const hour = String(time.hour).padStart(2, "0");
    const minute = String(time.minute).padStart(2, "0");
    return `${year}-${month}-${day} ${hour}:${minute} ${time.period}`;
  }, []);
  const convertToTimestamp = useCallback$8((date, time) => {
    const newDate = new Date(date);
    let hour24 = time.hour;
    if (time.period === "PM" && time.hour !== 12) {
      hour24 += 12;
    } else if (time.period === "AM" && time.hour === 12) {
      hour24 = 0;
    }
    newDate.setHours(hour24, time.minute, 0, 0);
    return newDate.getTime();
  }, []);
  useEffect$8(() => {
    if (value) {
      const date = new Date(value);
      setSelectedDate(date);
      setCurrentMonth(date);
      setTempYear(date.getFullYear());
      setTempMonth(date.getMonth());
      let hour = date.getHours();
      const period = hour >= 12 ? "PM" : "AM";
      if (hour === 0) hour = 12;
      else if (hour > 12) hour -= 12;
      setSelectedTime({
        hour,
        minute: date.getMinutes(),
        period
      });
      setDisplayValue(
        formatDisplayValue(date, {
          hour,
          minute: date.getMinutes(),
          period
        })
      );
    } else {
      const now = /* @__PURE__ */ new Date();
      setSelectedDate(now);
      setCurrentMonth(now);
      setTempYear(now.getFullYear());
      setTempMonth(now.getMonth());
      let hour = now.getHours();
      const period = hour >= 12 ? "PM" : "AM";
      if (hour === 0) hour = 12;
      else if (hour > 12) hour -= 12;
      setSelectedTime({
        hour,
        minute: now.getMinutes(),
        period
      });
    }
  }, [value, formatDisplayValue]);
  useEffect$8(() => {
    const handleClickOutside = (event) => {
      if (overlayRef.current && !overlayRef.current.contains(event.target) && textFieldRef.current && !textFieldRef.current.contains(event.target)) {
        setIsOpen(false);
        setShowYearMonthPicker(false);
      }
    };
    const handleEscapeKey = (event) => {
      if (event.key === "Escape") {
        setIsOpen(false);
        setShowYearMonthPicker(false);
      }
    };
    if (isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
      document.addEventListener("keydown", handleEscapeKey);
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
      document.removeEventListener("keydown", handleEscapeKey);
    };
  }, [isOpen]);
  const getMonthInfo = (date) => {
    const year = date.getFullYear();
    const month = date.getMonth();
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const startDayOfWeek = firstDay.getDay();
    return { year, month, daysInMonth, startDayOfWeek };
  };
  const handleDateClick = (year, month, day) => {
    const newDate = new Date(year, month, day);
    setSelectedDate(newDate);
    if (month !== currentMonth.getMonth() || year !== currentMonth.getFullYear()) {
      setCurrentMonth(new Date(year, month, 1));
    }
  };
  const renderCalendar = () => {
    const { year, month, daysInMonth, startDayOfWeek } = getMonthInfo(currentMonth);
    const today = /* @__PURE__ */ new Date();
    const isCurrentMonth = today.getFullYear() === year && today.getMonth() === month;
    const todayDate = today.getDate();
    const days = [];
    const weekDays = ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"];
    weekDays.forEach((day) => {
      days.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "text-center text-xs text-gray-500 py-2 font-medium",
            children: day
          },
          day
        )
      );
    });
    const prevMonth = new Date(year, month - 1, 1);
    const prevMonthYear = prevMonth.getFullYear();
    const prevMonthIndex = prevMonth.getMonth();
    const prevMonthLastDay = new Date(
      prevMonthYear,
      prevMonthIndex + 1,
      0
    ).getDate();
    for (let i = startDayOfWeek - 1; i >= 0; i--) {
      const day = prevMonthLastDay - i;
      days.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "text-center py-2 text-gray-300 text-sm cursor-pointer hover:bg-gray-50 transition-colors",
            onClick: () => handleDateClick(prevMonthYear, prevMonthIndex, day),
            children: day
          },
          `prev-${day}`
        )
      );
    }
    for (let day = 1; day <= daysInMonth; day++) {
      const isSelected = selectedDate.getFullYear() === year && selectedDate.getMonth() === month && selectedDate.getDate() === day;
      const isToday = isCurrentMonth && day === todayDate;
      days.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              borderRadius: "50%"
            },
            className: `text-center py-2 text-sm cursor-pointer transition-colors
            ${isSelected ? "bg-cyan-500 text-white font-medium " : isToday ? "bg-cyan-100 text-cyan-600 font-medium" : "text-gray-700 hover:bg-gray-100"}`,
            onClick: () => handleDateClick(year, month, day),
            children: day
          },
          day
        )
      );
    }
    const nextMonth = new Date(year, month + 1, 1);
    const nextMonthYear = nextMonth.getFullYear();
    const nextMonthIndex = nextMonth.getMonth();
    const remainingCells = 42 - days.length + 7;
    for (let day = 1; day <= remainingCells; day++) {
      days.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "text-center py-2 text-gray-300 text-sm cursor-pointer hover:bg-gray-50 transition-colors",
            onClick: () => handleDateClick(nextMonthYear, nextMonthIndex, day),
            children: day
          },
          `next-${day}`
        )
      );
    }
    return days;
  };
  const changeMonth = (direction) => {
    setCurrentMonth((prev) => {
      const newMonth = new Date(prev);
      newMonth.setMonth(prev.getMonth() + direction);
      return newMonth;
    });
  };
  const openYearMonthPicker = () => {
    setTempYear(currentMonth.getFullYear());
    setTempMonth(currentMonth.getMonth());
    setShowYearMonthPicker(true);
  };
  const confirmYearMonth = () => {
    const newDate = new Date(tempYear, tempMonth, 1);
    setCurrentMonth(newDate);
    setShowYearMonthPicker(false);
  };
  const cancelYearMonth = () => {
    setShowYearMonthPicker(false);
  };
  const generateYears = () => {
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    const years = [];
    for (let i = currentYear - 10; i <= currentYear + 10; i++) {
      years.push(i);
    }
    return years;
  };
  const monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  const handleTimeChange = (type, value2) => {
    if (type === "hour") {
      setSelectedTime((prev) => ({ ...prev, hour: parseInt(value2) }));
    } else if (type === "minute") {
      setSelectedTime((prev) => ({ ...prev, minute: parseInt(value2) }));
    } else if (type === "period") {
      setSelectedTime((prev) => ({ ...prev, period: value2 }));
    }
  };
  const generateTimeOptions = () => {
    const hours2 = Array.from({ length: 12 }, (_, i) => i + 1);
    const minutes2 = Array.from({ length: 60 }, (_, i) => i);
    const periods2 = ["AM", "PM"];
    return { hours: hours2, minutes: minutes2, periods: periods2 };
  };
  const { hours, minutes, periods } = generateTimeOptions();
  const handleOpenDatePicker = () => {
    if (disabled) return;
    if (displayValue) {
      const dateTimeMatch = displayValue.match(
        /(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}) (AM|PM)/
      );
      if (dateTimeMatch) {
        const [, year, month, day, hour, minute, period] = dateTimeMatch;
        const date = new Date(
          parseInt(year),
          parseInt(month) - 1,
          parseInt(day)
        );
        setSelectedDate(date);
        setCurrentMonth(date);
        setTempYear(date.getFullYear());
        setTempMonth(date.getMonth());
        setSelectedTime({
          hour: parseInt(hour),
          minute: parseInt(minute),
          period
        });
      }
    } else {
      const now = /* @__PURE__ */ new Date();
      setSelectedDate(now);
      setCurrentMonth(now);
      setTempYear(now.getFullYear());
      setTempMonth(now.getMonth());
      let hour = now.getHours();
      const period = hour >= 12 ? "PM" : "AM";
      if (hour === 0) hour = 12;
      else if (hour > 12) hour -= 12;
      setSelectedTime({
        hour,
        minute: now.getMinutes(),
        period
      });
    }
    setIsOpen(!isOpen);
  };
  const handleConfirm = () => {
    const formattedValue = formatDisplayValue(selectedDate, selectedTime);
    const timestamp = convertToTimestamp(selectedDate, selectedTime);
    setDisplayValue(formattedValue);
    setIsOpen(false);
    setShowYearMonthPicker(false);
    if (onChange) {
      onChange({
        displayValue: formattedValue,
        timestamp,
        date: selectedDate,
        time: selectedTime
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `relative ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          ref: textFieldRef,
          type: "text",
          value: displayValue,
          placeholder,
          readOnly: true,
          disabled,
          className: `w-full border border-gray-300 rounded p-2 text-sm pr-10 cursor-pointer
            ${disabled ? "bg-gray-100 cursor-not-allowed" : "bg-white hover:border-gray-400"}
            focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-transparent`,
          onClick: handleOpenDatePicker
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-3 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "svg",
        {
          width: "16",
          height: "16",
          viewBox: "0 0 24 24",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: "2",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          className: "text-gray-400",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "rect",
              {
                x: "3",
                y: "4",
                width: "18",
                height: "18",
                rx: "2",
                ry: "2"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "line",
              {
                x1: "16",
                y1: "2",
                x2: "16",
                y2: "6"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "line",
              {
                x1: "8",
                y1: "2",
                x2: "8",
                y2: "6"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "line",
              {
                x1: "3",
                y1: "10",
                x2: "21",
                y2: "10"
              }
            )
          ]
        }
      ) })
    ] }),
    isOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      position === "center" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "fixed inset-0 bg-black bg-opacity-30 z-[9998]",
          onClick: () => {
            setIsOpen(false);
            setShowYearMonthPicker(false);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          ref: overlayRef,
          className: "bg-white rounded-lg shadow-lg border border-gray-200 p-4 pointer-events-auto",
          style: {
            ...getDialogPosition(),
            minWidth: "320px",
            width: "320px"
          },
          onClick: (e) => e.stopPropagation(),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm font-medium text-gray-700 mb-4", children: [
              "指定時間",
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => {
                    setIsOpen(false);
                    setShowYearMonthPicker(false);
                  },
                  className: "absolute right-3 hover:bg-gray-100 rounded",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "svg",
                    {
                      width: "20",
                      height: "20",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      stroke: "currentColor",
                      strokeWidth: "2",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "line",
                          {
                            x1: "18",
                            y1: "6",
                            x2: "6",
                            y2: "18"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "line",
                          {
                            x1: "6",
                            y1: "6",
                            x2: "18",
                            y2: "18"
                          }
                        )
                      ]
                    }
                  )
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => changeMonth(-1),
                  className: "p-1 hover:bg-gray-100 rounded",
                  disabled: showYearMonthPicker,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      width: "16",
                      height: "16",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      stroke: "currentColor",
                      strokeWidth: "2",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "15,18 9,12 15,6" })
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: openYearMonthPicker,
                  className: "font-medium text-gray-700 hover:text-cyan-600 hover:bg-gray-50 px-3 py-1 rounded transition-colors",
                  disabled: showYearMonthPicker,
                  children: currentMonth.toLocaleDateString("en-US", {
                    year: "numeric",
                    month: "long"
                  })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: () => changeMonth(1),
                  className: "p-1 hover:bg-gray-100 rounded",
                  disabled: showYearMonthPicker,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      width: "16",
                      height: "16",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      stroke: "currentColor",
                      strokeWidth: "2",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "9,18 15,12 9,6" })
                    }
                  )
                }
              )
            ] }),
            showYearMonthPicker && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute h-[450px] inset-0 bg-white rounded-lg z-10 p-4 border border-gray-200 shadow-lg", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm font-medium text-gray-700 mb-4", children: "選擇年月" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4 bg-white", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-600 mb-2", children: "年份" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "select",
                  {
                    value: tempYear,
                    onChange: (e) => setTempYear(parseInt(e.target.value)),
                    className: "w-full border border-gray-300 rounded p-2 text-sm bg-white",
                    children: generateYears().map((year) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "option",
                      {
                        value: year,
                        children: year
                      },
                      year
                    ))
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6 mt-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-600 mb-2", children: "月份" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-3 rounded border border-gray-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-3 gap-2", children: monthNames.map((month, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => setTempMonth(index),
                      className: `p-2 text-sm rounded transition-colors
                            ${tempMonth === index ? "bg-cyan-500 text-white" : "bg-gray-50 hover:bg-gray-100 text-gray-700 border border-gray-200"}`,
                      children: month.slice(0, 3)
                    },
                    month
                  )) }) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2 bg-white pt-2", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: cancelYearMonth,
                      className: "flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded transition-colors border border-gray-300",
                      children: "取消"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: confirmYearMonth,
                      className: "flex-1 bg-cyan-500 hover:bg-cyan-600 text-white font-medium py-2 px-4 rounded transition-colors",
                      children: "確定"
                    }
                  )
                ] })
              ] })
            ] }),
            !showYearMonthPicker && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-7 gap-1 mb-4", children: renderCalendar() }),
            !showYearMonthPicker && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 mb-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "select",
                {
                  value: selectedTime.hour,
                  onChange: (e) => handleTimeChange("hour", e.target.value),
                  className: "w-full border border-gray-300 rounded p-2 text-sm appearance-none bg-white",
                  children: hours.map((hour) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: hour,
                      children: String(hour).padStart(2, "0")
                    },
                    hour
                  ))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray-500", children: ":" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "select",
                {
                  value: selectedTime.minute,
                  onChange: (e) => handleTimeChange("minute", e.target.value),
                  className: "w-full border border-gray-300 rounded p-2 text-sm appearance-none bg-white",
                  children: minutes.map((minute) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: minute,
                      children: String(minute).padStart(2, "0")
                    },
                    minute
                  ))
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "select",
                {
                  value: selectedTime.period,
                  onChange: (e) => handleTimeChange("period", e.target.value),
                  className: "w-full border border-gray-300 rounded p-2 text-sm appearance-none bg-white",
                  children: periods.map((period) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: period,
                      children: period
                    },
                    period
                  ))
                }
              ) })
            ] }),
            !showYearMonthPicker && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleConfirm,
                className: "w-full bg-cyan-500 hover:bg-cyan-600 text-white font-medium py-2 px-4 rounded transition-colors",
                children: "設定"
              }
            )
          ]
        }
      )
    ] })
  ] });
};

const magicIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20width='20'%20height='20'%20rx='4'%20fill='%23F5F5F5'/%3e%3cpath%20d='m11.19%205.596-.002.041a.4.4%200%200%201-.796%200l-.002-.04V4.4a.4.4%200%200%201%20.8%200v1.196zM8.166%206.334a.393.393%200%200%201%200%20.561.407.407%200%200%201-.57%200l-.863-.85a.393.393%200%200%201%200-.561.407.407%200%200%201%20.57%200l.863.85zM6.344%208.846a.4.4%200%201%201%200%20.8H5.117a.4.4%200%201%201%200-.8h1.227zM15.6%208.846a.4.4%200%200%201%200%20.8h-1.227a.4.4%200%200%201%200-.8H15.6zM13.476%205.484a.407.407%200%200%201%20.57%200%20.393.393%200%200%201%200%20.561l-.863.85a.407.407%200%200%201-.57%200%20.393.393%200%200%201%200-.56l.863-.851zM14.619%2012.687a.393.393%200%200%201%200%20.561.407.407%200%200%201-.57%200l-.863-.85a.393.393%200%200%201%200-.562.407.407%200%200%201%20.57%200l.863.85zM11.19%2014.834l-.002.04a.4.4%200%200%201-.796%200l-.002-.04v-1.197a.4.4%200%200%201%20.8%200v1.197z'%20fill='%237C3AED'%20stroke='%237C3AED'%20stroke-width='.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M10.354%207.09c.062-.12.23-.12.292%200l.746%201.448c.016.031.04.056.071.072l1.447.741c.12.062.12.236%200%20.298l-1.447.741a.166.166%200%200%200-.071.072l-.746%201.449a.163.163%200%200%201-.292%200l-.746-1.45a.165.165%200%200%200-.071-.07L8.09%209.648a.168.168%200%200%201%200-.298l1.447-.741a.165.165%200%200%200%20.071-.072l.746-1.449zM8.925%2012.022a.306.306%200%200%200%200-.436l-.444-.438a.316.316%200%200%200-.443%200l-3.946%203.888a.306.306%200%200%200%200%20.436l.444.438a.316.316%200%200%200%20.443%200l3.946-3.888z'%20fill='%237C3AED'/%3e%3c/svg%3e";

const React$a = await importShared('react');
const {memo: memo$4,useState: useState$b,useEffect: useEffect$7,useCallback: useCallback$7,useRef: useRef$6} = React$a;
const ScheduleTriggerNode = ({ data, isConnectable }) => {
  const [scheduleType, setScheduleType] = useState$b(
    data?.schedule_type || "cron"
  );
  const [cronExpression, setCronExpression] = useState$b(
    data?.cron_expression || ""
  );
  const [executeAt, setExecuteAt] = useState$b(data?.execute_at || null);
  const [timezone, setTimezone] = useState$b(data?.timezone || "Asia/Taipei");
  const [enabled, setEnabled] = useState$b(data?.enabled ?? true);
  const [description, setDescription] = useState$b(data?.description || "");
  const [showSmartDialog, setShowSmartDialog] = useState$b(false);
  const [defaultDescriptions, setDefaultDescriptions] = useState$b([]);
  const [userInput, setUserInput] = useState$b("");
  const [selectedLlm, setSelectedLlm] = useState$b("3");
  const [isGenerating, setIsGenerating] = useState$b(false);
  const [llmOptions, setLlmOptions] = useState$b([]);
  const [isLoadingModels, setIsLoadingModels] = useState$b(false);
  const [modelLoadError, setModelLoadError] = useState$b(null);
  const [timezoneOptions, setTimezoneOptions] = useState$b([]);
  const [frequencyMode, setFrequencyMode] = useState$b("preset");
  const [isLoadingTimezones, setIsLoadingTimezones] = useState$b(false);
  const [isLoadingDescriptions, setIsLoadingDescriptions] = useState$b(false);
  const [selectedPresetValue, setSelectedPresetValue] = useState$b("");
  const [presetScheduleConfigs, setPresetScheduleConfigs] = useState$b([]);
  const [isLoadingScheduleConfigs, setIsLoadingScheduleConfigs] = useState$b(false);
  const isInitialized = useRef$6(false);
  const lastSyncedData = useRef$6({});
  const updateParentState = useCallback$7(
    (key, value) => {
      console.log(`Schedule節點更新: ${key}=${value}`);
      if (data && typeof data.updateNodeData === "function") {
        data.updateNodeData(key, value);
        lastSyncedData.current[key] = value;
        return true;
      }
      console.warn(`無法更新父組件的 ${key}`);
      return false;
    },
    [data]
  );
  const loadLlmOptions = useCallback$7(async () => {
    try {
      const options = await llmService.getModelOptions();
      setLlmOptions(options);
      if (options.length > 0 && !selectedLlm) {
        setSelectedLlm(options[0].value);
      }
    } catch (error) {
      console.error("載入 LLM 選項失敗:", error);
    }
  }, [selectedLlm]);
  const loadTimezoneOptions = useCallback$7(async () => {
    if (isLoadingTimezones) return;
    setIsLoadingTimezones(true);
    try {
      const options = await scheduleTriggerService.getTimezoneOptions({
        region: "Asia",
        format: "detailed"
      });
      setTimezoneOptions(options);
    } catch (error) {
      console.error("載入時區選項失敗:", error);
      window.notify?.({
        message: "載入時區選項失敗",
        type: "error",
        duration: 3e3
      });
    } finally {
      setIsLoadingTimezones(false);
    }
  }, [isLoadingTimezones]);
  const loadDefaultDescriptions = useCallback$7(async () => {
    if (isLoadingDescriptions) return;
    setIsLoadingDescriptions(true);
    try {
      const options = await scheduleTriggerService.getDefaultDescriptionOptions();
      setDefaultDescriptions(options);
    } catch (error) {
      console.error("載入預設描述失敗:", error);
      window.notify?.({
        message: "載入預設描述失敗",
        type: "error",
        duration: 3e3
      });
    } finally {
      setIsLoadingDescriptions(false);
    }
  }, [isLoadingDescriptions]);
  const loadDefaultScheduleConfigs = useCallback$7(async () => {
    if (isLoadingScheduleConfigs) return;
    setIsLoadingScheduleConfigs(true);
    try {
      const options = await scheduleTriggerService.getDefaultScheduleConfigOptions();
      setPresetScheduleConfigs(options);
      console.log("載入的預設調度設定選項:", options);
    } catch (error) {
      console.error("載入預設調度設定選項失敗:", error);
      window.notify?.({
        message: "載入預設調度設定選項失敗",
        type: "error",
        duration: 3e3
      });
    } finally {
      setIsLoadingScheduleConfigs(false);
    }
  }, [isLoadingScheduleConfigs]);
  useEffect$7(() => {
    if (!isInitialized.current) {
      loadLlmOptions();
      loadTimezoneOptions();
      loadDefaultScheduleConfigs();
      isInitialized.current = true;
    }
  }, [loadLlmOptions, loadTimezoneOptions, loadDefaultScheduleConfigs]);
  useEffect$7(() => {
    let hasChanges = false;
    const fieldsToSync = [
      "schedule_type",
      "cron_expression",
      "execute_at",
      "timezone",
      "enabled",
      "description"
    ];
    fieldsToSync.forEach((field) => {
      if (data?.[field] !== void 0 && data[field] !== lastSyncedData.current[field]) {
        switch (field) {
          case "schedule_type":
            setScheduleType(data[field]);
            break;
          case "cron_expression":
            setCronExpression(data[field]);
            break;
          case "execute_at":
            setExecuteAt(data[field]);
            break;
          case "timezone":
            setTimezone(data[field]);
            break;
          case "enabled":
            setEnabled(data[field]);
            break;
          case "description":
            setDescription(data[field]);
            break;
        }
        lastSyncedData.current[field] = data[field];
        hasChanges = true;
      }
    });
    if (hasChanges) {
      console.log("Schedule節點數據同步完成");
    }
  }, [data]);
  useEffect$7(() => {
    if (cronExpression && presetScheduleConfigs.length > 0) {
      const matchedConfig = presetScheduleConfigs.find(
        (config) => config.cronExpression === cronExpression && config.value !== "custom" && config.cronExpression !== ""
      );
      if (matchedConfig) {
        setFrequencyMode("preset");
        setSelectedPresetValue(matchedConfig.cronExpression);
      } else {
        setFrequencyMode("custom");
        setSelectedPresetValue("");
      }
    } else if (presetScheduleConfigs.length > 0 && !cronExpression) {
      const firstNonCustomOption = presetScheduleConfigs.find(
        (config) => config.value !== "custom" && config.cronExpression !== ""
      );
      if (firstNonCustomOption) {
        setFrequencyMode("preset");
        setSelectedPresetValue(firstNonCustomOption.cronExpression);
      }
    }
  }, [cronExpression, presetScheduleConfigs]);
  const handleEnabledToggle = useCallback$7(() => {
    const newEnabled = !enabled;
    setEnabled(newEnabled);
    updateParentState("enabled", newEnabled);
  }, [enabled, updateParentState]);
  const handleTypeChange = useCallback$7(
    (newType) => {
      setScheduleType(newType);
      updateParentState("schedule_type", newType);
    },
    [updateParentState]
  );
  const handleCronExpressionChange = useCallback$7(
    (newExpression) => {
      setCronExpression(newExpression);
      updateParentState("cron_expression", newExpression);
    },
    [updateParentState]
  );
  const handleExecuteAtChange = useCallback$7(
    (dateTimeData) => {
      const isoString = new Date(dateTimeData.timestamp).toISOString();
      setExecuteAt(isoString);
      updateParentState("execute_at", isoString);
    },
    [updateParentState]
  );
  const handleTimezoneChange = useCallback$7(
    (newTimezone) => {
      setTimezone(newTimezone);
      updateParentState("timezone", newTimezone);
    },
    [updateParentState]
  );
  const handleDescriptionChange = useCallback$7(
    (newDescription) => {
      setDescription(newDescription);
      updateParentState("description", newDescription);
    },
    [updateParentState]
  );
  const getDropdownValue = useCallback$7(() => {
    if (frequencyMode === "custom") {
      const customOption = presetScheduleConfigs.find(
        (config) => config.value === "custom" || config.cronExpression === ""
      );
      return customOption ? customOption.cronExpression : "";
    } else {
      if (selectedPresetValue) {
        return selectedPresetValue;
      } else {
        const firstNonCustomOption = presetScheduleConfigs.find(
          (config) => config.value !== "custom" && config.cronExpression !== ""
        );
        return firstNonCustomOption ? firstNonCustomOption.cronExpression : "";
      }
    }
  }, [frequencyMode, selectedPresetValue, presetScheduleConfigs]);
  const handleFrequencySelectChange = useCallback$7(
    (e) => {
      const selectedValue = e.target.value;
      const selectedConfig = presetScheduleConfigs.find(
        (config) => config.cronExpression === selectedValue
      );
      const isCustomOption = selectedConfig && (selectedConfig.value === "custom" || selectedConfig.cronExpression === "");
      if (isCustomOption) {
        setFrequencyMode("custom");
        setSelectedPresetValue("");
        handleCronExpressionChange("");
      } else {
        setFrequencyMode("preset");
        setSelectedPresetValue(selectedValue);
        if (selectedConfig) {
          handleCronExpressionChange(selectedConfig.cronExpression);
        } else {
          handleCronExpressionChange(selectedValue);
        }
      }
    },
    [presetScheduleConfigs, handleCronExpressionChange]
  );
  const openSmartDialog = useCallback$7(async () => {
    setShowSmartDialog(true);
    if (defaultDescriptions.length === 0) {
      await loadDefaultDescriptions();
    }
  }, [defaultDescriptions.length, loadDefaultDescriptions]);
  const closeSmartDialog = useCallback$7(() => {
    setShowSmartDialog(false);
    setUserInput("");
  }, []);
  const selectDefaultDescription = useCallback$7((description2) => {
    setUserInput(description2);
  }, []);
  const generateScheduleSettings = useCallback$7(async () => {
    if (!userInput.trim()) {
      window.notify?.({
        message: "請輸入任務描述",
        type: "warning",
        duration: 2e3
      });
      return;
    }
    setIsGenerating(true);
    try {
      const requestData = {
        current_date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        // YYYY-MM-DD
        llm_id: parseInt(selectedLlm),
        task_description: userInput,
        timezone,
        user_input: userInput
      };
      const response = await scheduleTriggerService.generateScheduleTime(
        requestData
      );
      if (response.success && response.result) {
        const result = response.result;
        setScheduleType(result.schedule_type);
        updateParentState("schedule_type", result.schedule_type);
        if (result.schedule_type === "cron") {
          setCronExpression(result.schedule_config.cron_expression);
          updateParentState(
            "cron_expression",
            result.schedule_config.cron_expression
          );
          const matchedConfig = presetScheduleConfigs.find(
            (config) => config.cronExpression === result.schedule_config.cron_expression
          );
          if (matchedConfig) {
            setFrequencyMode("preset");
            setSelectedPresetValue(matchedConfig.cronExpression);
          } else {
            setFrequencyMode("custom");
            setSelectedPresetValue("");
          }
        } else if (result.schedule_type === "once") {
          setExecuteAt(result.schedule_config.execute_at);
          updateParentState("execute_at", result.schedule_config.execute_at);
        }
        if (result.schedule_config.timezone) {
          setTimezone(result.schedule_config.timezone);
          updateParentState("timezone", result.schedule_config.timezone);
        }
        if (result.description) {
          setDescription(result.schedule_config.description);
          updateParentState("description", result.schedule_config.description);
        }
        window.notify?.({
          message: "排程設定生成成功",
          type: "success",
          duration: 2e3
        });
        closeSmartDialog();
      } else {
        throw new Error(response.error || "生成設定失敗");
      }
    } catch (error) {
      console.error("生成排程設定失敗:", error);
      window.notify?.({
        message: "生成排程設定失敗",
        type: "error",
        duration: 3e3
      });
    } finally {
      setIsGenerating(false);
    }
  }, [
    userInput,
    selectedLlm,
    timezone,
    updateParentState,
    closeSmartDialog,
    presetScheduleConfigs
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-80", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "p-4",
          style: { backgroundColor: "#dccafa" },
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 rounded-full flex items-center justify-center mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "schedule" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-bold text-gray-800", children: "Schedule" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: handleEnabledToggle,
                  className: `relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-600 focus:ring-offset-2 ${enabled ? "bg-indigo-600" : "bg-gray-200"}`,
                  role: "switch",
                  "aria-checked": enabled,
                  title: enabled ? "停用排程" : "啟用排程",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      "aria-hidden": "true",
                      className: `pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out ${enabled ? "translate-x-5" : "translate-x-0"}`
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: openSmartDialog,
                  title: "智慧設定助手",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "img",
                    {
                      src: magicIcon,
                      alt: "Magic Icon"
                    }
                  )
                }
              )
            ] })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "類型" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: scheduleType,
                onChange: (e) => handleTypeChange(e.target.value),
                className: "w-full border border-gray-300 rounded p-2 text-sm bg-white appearance-none pr-8",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "cron", children: "週期性" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "once", children: "一次性" })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
              }
            ) })
          ] })
        ] }),
        scheduleType === "cron" && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "頻率" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                value: getDropdownValue(),
                onChange: handleFrequencySelectChange,
                disabled: isLoadingScheduleConfigs,
                className: "w-full border border-gray-300 rounded p-2 text-sm bg-white",
                children: [
                  isLoadingScheduleConfigs && /* @__PURE__ */ jsxRuntimeExports.jsx("option", { children: "載入頻率選項中..." }),
                  !isLoadingScheduleConfigs && presetScheduleConfigs.map((config) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: config.cronExpression,
                      title: config.description,
                      children: config.label
                    },
                    config.value
                  ))
                ]
              }
            ),
            frequencyMode === "custom" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-3", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "進階表達式" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: cronExpression,
                  onChange: (e) => handleCronExpressionChange(e.target.value),
                  placeholder: "* * * * *",
                  className: "w-full border border-gray-300 rounded p-2 text-sm"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-500", children: "格式：分 時 日 月 週" }) })
            ] })
          ] })
        ] }) }),
        scheduleType === "once" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-medium", children: "指定時間" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DateTimeSelector,
            {
              value: executeAt ? new Date(executeAt).getTime() : null,
              onChange: handleExecuteAtChange,
              placeholder: "選擇執行時間",
              className: "w-full",
              position: "bottom-right",
              offsetX: -10,
              offsetY: 5
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "時區" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "select",
            {
              value: timezone,
              onChange: (e) => handleTimezoneChange(e.target.value),
              disabled: isLoadingTimezones,
              className: "w-full border border-gray-300 rounded p-2 text-sm bg-white",
              children: isLoadingTimezones ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { children: "載入中..." }) : timezoneOptions.map((tz) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "option",
                {
                  value: tz.value,
                  children: tz.label
                },
                tz.value
              ))
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "任務描述" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectableTextWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "textarea",
            {
              value: description,
              onChange: (e) => handleDescriptionChange(e.target.value),
              placeholder: "輸入任務描述...",
              className: "w-full border border-gray-300 rounded p-2 text-sm h-20 resize-none"
            }
          ) })
        ] })
      ] })
    ] }),
    showSmartDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed inset-0 z-[9999]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "absolute inset-0 bg-black bg-opacity-50 pointer-events-auto rounded-lg overflow-hidden",
          onClick: closeSmartDialog
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "absolute -left-[250px] top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white rounded-lg shadow-xl max-w-md w-full mx-4 max-h-[90vh] overflow-hidden flex flex-col pointer-events-auto border border-gray-200 z-10 w-[450px]",
          onClick: (e) => {
            e.stopPropagation();
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between p-4 border-b border-gray-200", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "svg",
                  {
                    width: "20",
                    height: "20",
                    viewBox: "0 0 24 24",
                    fill: "none",
                    stroke: "currentColor",
                    strokeWidth: "2",
                    strokeLinecap: "round",
                    strokeLinejoin: "round",
                    className: "mr-2 text-purple-600",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2L15.09 8.26L22 9L17 14L18.18 21L12 17.77L5.82 21L7 14L2 9L8.91 8.26L12 2Z" })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium text-gray-900", children: "智慧設定助手" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: closeSmartDialog,
                  className: "p-1 hover:bg-gray-100 rounded",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "svg",
                    {
                      width: "20",
                      height: "20",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      stroke: "currentColor",
                      strokeWidth: "2",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "line",
                          {
                            x1: "18",
                            y1: "6",
                            x2: "6",
                            y2: "18"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "line",
                          {
                            x1: "6",
                            y1: "6",
                            x2: "18",
                            y2: "18"
                          }
                        )
                      ]
                    }
                  )
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 flex-1 overflow-y-auto", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 mb-4", children: "用自然語言描述您的需求，例如：" }),
              isLoadingDescriptions ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 text-sm text-gray-500", children: "載入預設選項中..." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-4 space-y-2", children: defaultDescriptions.map((desc, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  type: "button",
                  disabled: isGenerating,
                  onClick: () => selectDefaultDescription(desc.value),
                  className: "block w-full text-left p-2 text-sm bg-gray-50 hover:bg-gray-100 rounded border border-gray-200 transition-colors",
                  children: [
                    '"',
                    desc.value,
                    '"'
                  ]
                },
                index
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  value: userInput,
                  onChange: (e) => setUserInput(e.target.value),
                  placeholder: "請輸入您的需求...",
                  disabled: isGenerating,
                  className: "w-full border border-gray-300 rounded p-3 text-sm h-24 resize-none focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 border-t border-gray-200 bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "select",
                    {
                      value: selectedLlm,
                      onChange: (e) => setSelectedLlm(e.target.value),
                      className: `border border-gray-300 rounded p-1 text-sm bg-white appearance-none pr-8
                        ${isLoadingModels ? "opacity-70 cursor-wait" : ""} 
                        ${modelLoadError ? "border-red-300" : ""}`,
                      disabled: isLoadingModels || isGenerating,
                      children: llmOptions.map((llm) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "option",
                        {
                          value: llm.value,
                          children: llm.label
                        },
                        llm.value
                      ))
                    }
                  ),
                  isLoadingModels ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-1 top-1/2 transform -translate-y-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-3 w-3 border-b-2 border-gray-500" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-1 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      xmlns: "http://www.w3.org/2000/svg",
                      width: "12",
                      height: "12",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      stroke: "currentColor",
                      strokeWidth: "2",
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
                    }
                  ) })
                ] }),
                modelLoadError && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs text-red-500", children: "載入失敗" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: loadLlmOptions,
                      className: "text-xs text-blue-500 hover:text-blue-700",
                      title: "重新載入",
                      children: "↻"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  onClick: generateScheduleSettings,
                  disabled: isGenerating || !userInput.trim(),
                  className: "bg-cyan-500 hover:bg-cyan-600 text-white px-4 py-2 rounded text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center justify-center space-x-2 min-w-[120px] whitespace-nowrap",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: isGenerating ? "生成中..." : "生成設定" }),
                    isGenerating && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "animate-spin rounded-full h-4 w-4 border-b-2 border-white" })
                  ]
                }
              )
            ] }) })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "trigger",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          right: "-6px",
          zIndex: 5
        },
        isConnectable
      }
    )
  ] });
};
const ScheduleNode = memo$4(ScheduleTriggerNode);

const copyIcon = "data:image/svg+xml,%3csvg%20width='18'%20height='18'%20viewBox='0%200%2018%2018'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.344%2016.875H6.469a2.531%202.531%200%200%201-2.532-2.531V6.469A2.531%202.531%200%200%201%206.47%203.937h7.875a2.531%202.531%200%200%201%202.531%202.532v7.875a2.531%202.531%200%200%201-2.531%202.531z'%20fill='%23FC6165'/%3e%3cpath%20d='M5.625%202.813h8.293a2.536%202.536%200%200%200-2.387-1.688H3.656a2.531%202.531%200%200%200-2.531%202.531v7.875a2.536%202.536%200%200%200%201.688%202.387V5.625a2.813%202.813%200%200%201%202.812-2.813z'%20fill='%23FC6165'/%3e%3c/svg%3e";

const React$9 = await importShared('react');
const {memo: memo$3,useState: useState$a,useCallback: useCallback$6} = React$9;
const WebhookInputNode = ({ data, isConnectable, id }) => {
  const {
    curl_example,
    webhook_url,
    "X-QOCA-Agent-Api-Key": apiKey,
    isCreatingWebhook
  } = data;
  const [isCreating, setIsCreating] = useState$a(false);
  const [isExampleExpanded, setIsExampleExpanded] = useState$a(false);
  const handleCreateWebhook = useCallback$6(async () => {
    console.log("handleCreateWebhook 被調用");
    setIsCreating(true);
    try {
      const flowId = data?.flowId || window.currentFlowId || data?.flow_id || localStorage.getItem("current_flow_id");
      console.log("檢查到的 flowId:", flowId);
      if (!flowId) {
        console.log("沒有 flow_id，需要先保存流程");
        const event = new CustomEvent("requestSaveFlow", {
          detail: {
            nodeId: id,
            callback: async (savedFlowId) => {
              if (savedFlowId) {
                await createWebhook(savedFlowId);
              }
            }
          }
        });
        window.dispatchEvent(event);
        return;
      }
      console.log("已有 flow_id，直接創建 webhook");
      await createWebhook(flowId);
    } finally {
      setIsCreating(false);
    }
  }, [data, id]);
  const createWebhook = async (flowId) => {
    try {
      console.log("創建 webhook 返回的數據:", { flowId, nodeId: id });
      const response = await WebhookService.createWebhookUrl(flowId, id);
      console.log("Webhook 創建成功:", response);
      if (response.success && response.curl_example) {
        if (data?.updateNodeData && typeof data.updateNodeData === "function") {
          data.updateNodeData("curl_example", response.curl_example);
          data.updateNodeData("webhook_url", response.webhook_url);
          data.updateNodeData(
            "X-QOCA-Agent-Api-Key",
            response["X-QOCA-Agent-Api-Key"]
          );
          console.log("已將 webhook 數據更新到節點:", response);
        } else {
          console.warn("updateNodeData 不可用，無法保存 webhook 數據");
        }
        if (typeof window !== "undefined" && window.notify) {
          window.notify({
            message: "Webhook 創建成功",
            type: "success",
            duration: 3e3
          });
        }
      } else {
        throw new Error("後端未返回有效的 webhook 數據");
      }
    } catch (error) {
      console.error("創建 webhook 失敗:", error);
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "創建 webhook 失敗",
          type: "error",
          duration: 3e3
        });
      }
    }
  };
  const copyToClipboard = useCallback$6(async (text, label) => {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(text);
          window.notify?.({
            message: `${label} 已複製到剪貼板`,
            type: "success",
            duration: 2e3
          });
          return;
        } catch (clipboardError) {
          console.warn("Clipboard API 失敗，嘗試 fallback:", clipboardError);
        }
      }
      const textArea = document.createElement("textarea");
      textArea.value = text;
      textArea.style.cssText = "position:fixed;top:0;left:0;opacity:0;pointer-events:none;";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      const successful = document.execCommand("copy");
      document.body.removeChild(textArea);
      if (successful) {
        window.notify?.({
          message: `${label} 已複製到剪貼板`,
          type: "success",
          duration: 2e3
        });
      } else {
        throw new Error("所有複製方法都失敗");
      }
    } catch (error) {
      console.error("複製失敗:", error);
      window.notify?.({
        message: "複製失敗，請手動複製內容",
        type: "error",
        duration: 3e3
      });
    }
  }, []);
  const CopyButton = ({ onClick, title }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      onClick,
      title,
      className: "flex-shrink-0 p-1 hover:bg-gray-200 rounded transition-colors",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: copyIcon,
          width: 16,
          height: 16,
          className: "max-w-full max-h-full object-contain",
          style: {
            maxWidth: "100%",
            maxHeight: "100%",
            objectFit: "contain"
          }
        }
      )
    }
  );
  const hasWebhookData = webhook_url || curl_example || apiKey;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-96", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[#fff8f8] p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 flex items-center justify-center mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "webhook_input" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Webhook" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-4 space-y-4", children: !hasWebhookData ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "w-full bg-[#fc6165] hover:bg-[#dc6160] text-white rounded-md p-3 font-medium disabled:opacity-50 disabled:cursor-not-allowed transition-colors",
          onClick: handleCreateWebhook,
          disabled: isCreating || isCreatingWebhook,
          children: isCreating || isCreatingWebhook ? "創建中..." : "Create a webhook"
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        webhook_url && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-medium", children: "URL:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center bg-gray-50 border rounded p-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 text-xs font-mono text-gray-800 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "truncate pr-2", children: webhook_url }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CopyButton,
              {
                onClick: () => copyToClipboard(webhook_url, "URL"),
                title: "複製 URL"
              }
            )
          ] })
        ] }),
        apiKey && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-1 font-medium", children: "X-QOCA-Agent-Api-Key:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center bg-gray-50 border rounded p-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 text-xs font-mono text-gray-800 overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "truncate pr-2", children: apiKey }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CopyButton,
              {
                onClick: () => copyToClipboard(apiKey, "API Key"),
                title: "複製 API Key"
              }
            )
          ] })
        ] }),
        curl_example && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => setIsExampleExpanded(!isExampleExpanded),
              className: "w-full flex items-center justify-between text-sm text-gray-700 font-medium p-2 bg-gray-50 rounded-md hover:bg-gray-100 transition-colors",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "inline-flex w-full justify-between items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "inline-flex items-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "svg",
                    {
                      className: `w-4 h-4 transition-transform duration-200 ${isExampleExpanded ? "rotate-0" : "-rotate-90"}`,
                      fill: "none",
                      stroke: "currentColor",
                      viewBox: "0 0 24 24",
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          strokeLinecap: "round",
                          strokeLinejoin: "round",
                          strokeWidth: 2,
                          d: "M19 9l-7 7-7-7"
                        }
                      )
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-1", children: "範例程式" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  CopyButton,
                  {
                    onClick: (e) => {
                      e.stopPropagation();
                      copyToClipboard(curl_example, "Curl 命令");
                    },
                    title: "複製 Curl 命令"
                  }
                )
              ] })
            }
          ),
          isExampleExpanded && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-start bg-gray-900 text-white rounded p-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 text-xs font-mono overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "whitespace-pre-wrap break-all pr-2", children: curl_example }) }) }) })
        ] })
      ] }) })
    ] }),
    hasWebhookData && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "output",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          right: "-6px",
          zIndex: 5
        },
        isConnectable
      }
    )
  ] });
};
const WebhookInputNode$1 = memo$3(WebhookInputNode);

const React$8 = await importShared('react');
const {memo: memo$2,useEffect: useEffect$6,useState: useState$9,useRef: useRef$5,useCallback: useCallback$5} = React$8;
const WebhookOutputNode = ({ id, data, isConnectable }) => {
  const [inputs, setInputs] = useState$9([]);
  const [handleLabels, setHandleLabels] = useState$9({});
  const updateNodeInternals = useUpdateNodeInternals();
  const initAttempts = useRef$5(0);
  const nodeId = id || "unknown";
  const isUpdating = useRef$5(false);
  const isInitialized = useRef$5(false);
  const handleHeight = 40;
  const getNodeHeight = useCallback$5(() => {
    const headerHeight = 50;
    const buttonAreaHeight = 48;
    const textAreaHeight = 40;
    const bottomPadding = 30;
    return headerHeight + inputs.length * handleHeight + buttonAreaHeight + textAreaHeight + bottomPadding;
  }, [inputs.length]);
  useEdges();
  const processHandleId = (handleId) => {
    console.log(handleId);
    if (!handleId) return "";
    if (typeof handleId !== "string") {
      console.warn(`processHandleId: handleId 不是字符串: ${handleId}`);
      return "";
    }
    const match = handleId && handleId.match(/^(text\d+)(?:_\d+)?$/);
    if (match && match[1]) {
      return match[1];
    }
    if (handleId === "input") {
      return "text0";
    }
    return handleId;
  };
  const loadLabelsFromNodeInput = useCallback$5(() => {
    if (!data.node_input) return {};
    const labels = {};
    Object.entries(data.node_input).forEach(([key, value]) => {
      console.log("loadLabelsFromNodeInput:", key, value);
      if (value && value.return_name) {
        const baseHandleId = processHandleId(key);
        console.log(`讀取 ${key} 的 return_name:`, value.return_name);
        labels[baseHandleId] = value.return_name;
      }
    });
    return labels;
  }, [data.node_input]);
  useEffect$6(() => {
    if (isUpdating.current || isInitialized.current) return;
    isUpdating.current = true;
    initAttempts.current += 1;
    console.log(
      `初始化 WebhookOutputNode ${nodeId}，嘗試 #${initAttempts.current}`
    );
    const handleSet = /* @__PURE__ */ new Set();
    if (data.node_input && typeof data.node_input === "object") {
      const inputKeys = Object.keys(data.node_input);
      console.log(`從 node_input 載入 handle (${nodeId}):`, inputKeys);
      inputKeys.forEach((key) => {
        const baseHandleId = processHandleId(key);
        if (baseHandleId) {
          handleSet.add(baseHandleId);
        }
      });
    }
    if (data.inputHandles && Array.isArray(data.inputHandles)) {
      console.log(
        `從 inputHandles 屬性載入 ${data.inputHandles.length} 個 handle`
      );
      data.inputHandles.forEach((handle) => {
        if (handle && handle.id) {
          const baseHandleId = processHandleId(handle.id);
          if (baseHandleId) {
            handleSet.add(baseHandleId);
          }
        }
      });
    }
    if (data.parameters && data.parameters.inputHandles && data.parameters.inputHandles.data) {
      console.log(`從參數中載入 handle`);
      const paramHandles = data.parameters.inputHandles.data;
      if (Array.isArray(paramHandles)) {
        paramHandles.forEach((handleId) => {
          const baseHandleId = processHandleId(handleId);
          if (baseHandleId) {
            handleSet.add(baseHandleId);
          }
        });
      }
    }
    if (handleSet.size === 0) {
      handleSet.add("text0");
      console.log(`添加默認 handle: text0`);
    }
    const handles = Array.from(handleSet).map((id2) => ({ id: String(id2) }));
    console.log(`最終設置節點 ${nodeId} 的 inputs:`, handles);
    setInputs(handles);
    if (data.node_input) {
      const nodeInput = { ...data.node_input };
      const handleMapping = {};
      Object.keys(nodeInput).forEach((key) => {
        const baseHandleId = processHandleId(key);
        if (!handleMapping[baseHandleId]) {
          handleMapping[baseHandleId] = [];
        }
        handleMapping[baseHandleId].push(key);
      });
      handles.forEach((handle) => {
        const baseHandleId = handle.id;
        if (!handleMapping[baseHandleId] || handleMapping[baseHandleId].length === 0) {
          nodeInput[baseHandleId] = {
            node_id: "",
            output_name: "",
            type: "string",
            data: "",
            is_empty: true,
            return_name: ""
            // 確保有 return_name 屬性
          };
          console.log(`為 handle ${baseHandleId} 創建 node_input 項`);
        } else if (handleMapping[baseHandleId]) {
          handleMapping[baseHandleId].forEach((key) => {
            if (!Object.prototype.hasOwnProperty.call(
              nodeInput[key],
              "return_name"
            )) {
              nodeInput[key].return_name = "";
              console.log(`為 handle ${key} 添加 return_name 屬性`);
            }
          });
        }
      });
      data.node_input = nodeInput;
    }
    if (data.inputHandles) {
      data.inputHandles = handles;
    }
    const initialLabels = loadLabelsFromNodeInput();
    if (Object.keys(initialLabels).length > 0) {
      setHandleLabels(initialLabels);
      console.log("設置初始標籤:", initialLabels);
    }
    console.log(`節點 ${nodeId} 完整資料:`, {
      handles,
      node_input: data.node_input || {},
      inputHandles: data.inputHandles || [],
      labels: initialLabels
    });
    isInitialized.current = true;
    const updateTimes = [0, 50, 150, 300, 600, 1e3, 1500];
    updateTimes.forEach((delay) => {
      setTimeout(() => {
        try {
          updateNodeInternals(nodeId);
        } catch (error) {
          console.error(`更新節點內部結構時出錯:`, error);
        }
      }, delay);
    });
    setTimeout(() => {
      isUpdating.current = false;
    }, 200);
  }, [nodeId, data, updateNodeInternals, loadLabelsFromNodeInput]);
  useEffect$6(() => {
    if (inputs.length > 0) {
      console.log(`inputs 更新為 ${inputs.length} 個 handle，更新內部結構`);
      setTimeout(() => {
        try {
          updateNodeInternals(nodeId);
        } catch (error) {
          console.error(`更新節點內部結構時出錯:`, error);
        }
      }, 50);
    }
  }, [inputs, nodeId, updateNodeInternals]);
  const handleAddOutput = useCallback$5(() => {
    let maxIndex = -1;
    inputs.forEach((input) => {
      console.log(input);
      if (input.id && input.id.startsWith("text")) {
        const indexStr = input.id.substring(4);
        const index = parseInt(indexStr, 10);
        if (!isNaN(index) && index > maxIndex) {
          maxIndex = index;
        }
      }
    });
    const newIndex = maxIndex + 1;
    const newInputId = `text${newIndex}`;
    const newInputs = [...inputs, { id: newInputId }];
    console.log(`新增 handle (${nodeId}):`, newInputId);
    const currentLabels = { ...handleLabels };
    setInputs(newInputs);
    if (data.node_input) {
      data.node_input[newInputId] = {
        node_id: "",
        output_name: "",
        type: "string",
        data: "",
        is_empty: true,
        return_name: ""
        // 確保有 return_name 屬性
      };
      console.log(`已在 node_input 中添加 ${newInputId}`);
    }
    if (data.inputHandles) {
      data.inputHandles = newInputs;
    } else {
      data.inputHandles = newInputs;
    }
    if (data.parameters && data.parameters.inputHandles) {
      data.parameters.inputHandles.data = newInputs.map((h) => h.id);
    }
    if (data.updateNodeData) {
      try {
        data.updateNodeData("inputHandles", newInputs);
        data.updateNodeData("node_input", data.node_input);
        console.log(`已同步更新節點數據: inputHandles 和 node_input`);
      } catch (err) {
        console.warn("同步更新節點數據時出錯:", err);
      }
    }
    setTimeout(() => {
      setHandleLabels((prevLabels) => {
        const mergedLabels = { ...currentLabels, ...prevLabels };
        console.log("合併後的標籤:", mergedLabels);
        return mergedLabels;
      });
    }, 0);
    if (data.onAddOutput) {
      try {
        data.onAddOutput(newInputs);
      } catch (err) {
        console.warn(`調用 onAddOutput 時出錯:`, err);
      }
    } else {
      console.warn(`節點 ${nodeId} 沒有 onAddOutput 回調函數`);
    }
  }, [inputs, data, nodeId, handleLabels]);
  const handleDeleteInput = useCallback$5(
    (handleId) => {
      const newInputs = inputs.filter((input) => input.id !== handleId);
      console.log(`刪除 handle (${nodeId}):`, handleId);
      const currentLabels = { ...handleLabels };
      delete currentLabels[handleId];
      setInputs(newInputs);
      if (data.node_input) {
        const updatedNodeInput = { ...data.node_input };
        Object.keys(updatedNodeInput).forEach((key) => {
          const baseHandleId = processHandleId(key);
          if (baseHandleId === handleId) {
            delete updatedNodeInput[key];
            console.log(`從 node_input 中刪除 ${key}`);
          }
        });
        data.node_input = updatedNodeInput;
      }
      data.inputHandles = newInputs;
      if (data.parameters && data.parameters.inputHandles) {
        data.parameters.inputHandles.data = newInputs.map((h) => h.id);
      }
      setHandleLabels(currentLabels);
      if (data.updateNodeData) {
        try {
          data.updateNodeData("inputHandles", newInputs);
          data.updateNodeData("node_input", data.node_input);
          console.log(
            `已同步更新節點數據: 刪除 ${handleId} 後的 inputHandles 和 node_input`
          );
        } catch (err) {
          console.warn("同步更新節點數據時出錯:", err);
        }
      }
      if (typeof window !== "undefined" && window.deleteEdgesByHandle) {
        window.deleteEdgesByHandle(nodeId, handleId);
      }
      if (data.onRemoveHandle) {
        try {
          data.onRemoveHandle(handleId);
        } catch (err) {
          console.warn(`調用 onRemoveHandle 時出錯:`, err);
        }
      }
    },
    [inputs, data, nodeId, handleLabels]
  );
  const handleLabelChange = useCallback$5(
    (handleId, newLabel) => {
      console.log(`標籤變更: ${handleId} -> ${newLabel}`);
      setHandleLabels((prev) => {
        if (prev[handleId] === newLabel) return prev;
        const updatedLabels = { ...prev, [handleId]: newLabel };
        console.log("更新標籤狀態:", updatedLabels);
        return updatedLabels;
      });
      if (data.node_input) {
        Object.keys(data.node_input).forEach((key) => {
          const baseKey = processHandleId(key);
          if (baseKey === handleId) {
            data.node_input[key].return_name = newLabel;
            data.node_input[key].has_return_name = true;
          }
        });
        const baseHandleExists = Object.keys(data.node_input).some(
          (key) => processHandleId(key) === handleId
        );
        if (!baseHandleExists) {
          data.node_input[handleId] = {
            node_id: "",
            output_name: "",
            type: "string",
            data: "",
            is_empty: true,
            return_name: newLabel,
            has_return_name: true
            // 標記為有 return_name
          };
        }
      }
      console.log(`已更新 ${handleId} 的標籤為: ${newLabel}`);
      if (data.updateNodeData && data.node_input) {
        try {
          const updatedNodeInput = JSON.parse(JSON.stringify(data.node_input));
          Object.keys(updatedNodeInput).forEach((key) => {
            const baseKey = processHandleId(key);
            if (baseKey === handleId) {
              updatedNodeInput[key].return_name = newLabel;
              updatedNodeInput[key].has_return_name = true;
            }
          });
          if (!Object.keys(updatedNodeInput).some(
            (key) => processHandleId(key) === handleId
          )) {
            updatedNodeInput[handleId] = {
              node_id: "",
              output_name: "",
              type: "string",
              data: "",
              is_empty: true,
              return_name: newLabel,
              has_return_name: true
            };
          }
          data.updateNodeData("node_input", updatedNodeInput);
          console.log(`已將 ${handleId} 的標籤變更同步到後端`);
        } catch (err) {
          console.warn("更新節點數據時出錯:", err);
        }
      }
    },
    [data]
  );
  const nodeStyle = {
    height: `${getNodeHeight()}px`,
    transition: "height 0.3s ease"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "rounded-lg shadow-md overflow-visible w-64 bg-white",
      style: nodeStyle,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 rounded-t-lg bg-[#fff8f8]", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-8 h-8 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "webhook_output" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-base", children: "Webhook Response" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pl-2 pt-2", children: "Response" }),
        inputs.map((input, index) => {
          const startY = 95;
          const topPosition = startY + index * handleHeight;
          const handleStyle = {
            background: "#e5e7eb",
            borderColor: "#D3D3D3",
            width: "12px",
            height: "12px",
            left: "-6px",
            top: `${topPosition + 14}px`,
            border: "1px solid #D3D3D3"
          };
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(React$8.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Handle$1,
              {
                type: "target",
                position: Position.Left,
                id: String(input.id),
                style: handleStyle,
                isConnectable
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "absolute flex items-center",
                style: { left: "10px", top: `${topPosition}px` },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "input",
                    {
                      type: "text",
                      className: "text-sm border border-gray-300 rounded px-2 py-1 focus:ring-1 focus:ring-teal-500 focus:border-teal-500 focus:outline-none",
                      placeholder: "請輸入",
                      value: handleLabels[input.id] || "",
                      onChange: (e) => handleLabelChange(input.id, e.target.value),
                      title: `輸入 ${input.id} 的標籤（將儲存為 return_name）`,
                      style: {
                        height: "30px",
                        lineHeight: "28px",
                        fontSize: "14px",
                        width: "210px"
                        // 調整寬度為刪除按鈕留空間
                      }
                    }
                  ),
                  inputs.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      onClick: () => handleDeleteInput(input.id),
                      className: "ml-2 text-gray-500 hover:text-teal-600 text-sm p-1 w-6 h-6 flex items-center justify-center",
                      title: "刪除此輸入",
                      children: "✕"
                    }
                  )
                ]
              }
            )
          ] }, `handle-${input.id}`);
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "p-4 absolute bottom-1 left-1 right-1 rounded-b-lg",
            style: {
              backgroundColor: "white",
              borderTop: "1px solid #f0f0f0"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "w-full bg-teal-500 hover:bg-teal-600 text-white rounded-md p-2 flex justify-center items-center",
                onClick: handleAddOutput,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Add, {})
              }
            )
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Handle$1,
          {
            type: "source",
            position: Position.Right,
            id: "output",
            style: {
              background: "#e5e7eb",
              border: "1px solid #D3D3D3",
              width: "12px",
              height: "12px",
              right: "-6px"
            },
            isConnectable
          }
        )
      ]
    }
  );
};
const WebhookOutputNode$1 = memo$2(WebhookOutputNode);

const React$7 = await importShared('react');
const {useRef: useRef$4,useEffect: useEffect$5,useState: useState$8,useCallback: useCallback$4,forwardRef: forwardRef$1,useImperativeHandle: useImperativeHandle$1} = React$7;

const CombineTextEditor = forwardRef$1(
  ({
    value,
    onChange,
    onCompositionStart,
    onCompositionEnd,
    onKeyDown,
    placeholder,
    className,
    flowId,
    onTagInsert,
    initialHtmlContent,
    shouldShowPanel,
    showInputPanel,
    onShowPanel,
    ...props
  }, ref) => {
    const editorRef = useRef$4(null);
    const [isFocused, setIsFocused] = useState$8(false);
    const [tags, setTags] = useState$8([]);
    const [selectedTag, setSelectedTag] = useState$8(null);
    const [isComposing, setIsComposing] = useState$8(false);
    const [isInitialized, setIsInitialized] = useState$8(false);
    const [isRestoring, setIsRestoring] = useState$8(false);
    const isUpdatingFromExternal = useRef$4(false);
    const lastReportedValue = useRef$4("");
    const generateDefaultContent = useCallback$4(() => {
      return JSON.stringify(
        {
          flow_id: flowId || "default-flow-id",
          func_id: "",
          data: ""
        },
        null,
        2
      );
    }, [flowId]);
    const getEditorTextContent = useCallback$4(() => {
      if (!editorRef.current) return "";
      let content = "";
      const walker = document.createTreeWalker(
        editorRef.current,
        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
        null,
        false
      );
      let node;
      while (node = walker.nextNode()) {
        if (node.nodeType === Node.TEXT_NODE) {
          if (node.parentElement?.classList?.contains("delete-btn") || node.parentElement?.classList?.contains("tag-display-name")) {
            continue;
          }
          content += node.textContent;
        } else if (node.classList && node.classList.contains("inline-tag")) {
          const tagData = node.getAttribute("data-tag-data");
          if (tagData) {
            content += tagData;
          }
        }
      }
      return content;
    }, []);
    const handleContentChange = useCallback$4(() => {
      if (isComposing || isRestoring || isUpdatingFromExternal.current) return;
      const textContent = getEditorTextContent();
      if (textContent !== lastReportedValue.current) {
        lastReportedValue.current = textContent;
        if (onChange) {
          onChange({
            target: {
              value: textContent
            }
          });
        }
      }
    }, [onChange, getEditorTextContent, isComposing, isRestoring]);
    const setCursorPosition = useCallback$4((x, y) => {
      if (!editorRef.current) return;
      let range;
      if (document.caretRangeFromPoint) {
        range = document.caretRangeFromPoint(x, y);
      } else if (document.caretPositionFromPoint) {
        const caretPos = document.caretPositionFromPoint(x, y);
        if (caretPos) {
          range = document.createRange();
          range.setStart(caretPos.offsetNode, caretPos.offset);
          range.collapse(true);
        }
      }
      if (range && editorRef.current.contains(range.startContainer)) {
        const selection2 = window.getSelection();
        selection2.removeAllRanges();
        selection2.addRange(range);
        return true;
      }
      range = document.createRange();
      range.selectNodeContents(editorRef.current);
      range.collapse(false);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
      return false;
    }, []);
    const insertTagAtCursor = useCallback$4(
      (tagInfo) => {
        if (!editorRef.current) return;
        const selection = window.getSelection();
        let range;
        if (!editorRef.current.contains(document.activeElement)) {
          editorRef.current.focus();
        }
        if (selection.rangeCount === 0) {
          range = document.createRange();
          range.selectNodeContents(editorRef.current);
          range.collapse(false);
        } else {
          range = selection.getRangeAt(0);
          if (!editorRef.current.contains(range.startContainer)) {
            range = document.createRange();
            range.selectNodeContents(editorRef.current);
            range.collapse(false);
          }
        }
        const newTag = {
          id: Date.now(),
          name: tagInfo.name,
          data: tagInfo.data || tagInfo.code,
          color: tagInfo.color
        };
        setTags((prev) => [...prev, newTag]);
        const tagElement = document.createElement("span");
        tagElement.className = "inline-tag";
        tagElement.setAttribute("data-tag-id", newTag.id);
        tagElement.setAttribute("data-tag-data", newTag.data);
        tagElement.style.cssText = `
          display: inline-block;
          background-color: ${newTag.color};
          color: white;
          padding: 4px 8px;
          margin: 2px;
          border-radius: 6px;
          font-size: 12px;
          font-weight: 500;
          cursor: pointer;
          white-space: nowrap;
          user-select: none;
          box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        `;
        tagElement.contentEditable = false;
        const tagContent = document.createElement("span");
        tagContent.className = "tag-display-name";
        tagContent.textContent = newTag.name;
        tagElement.appendChild(tagContent);
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-btn";
        deleteBtn.textContent = "×";
        deleteBtn.style.cssText = "margin-left: 6px; cursor: pointer; font-weight: bold;";
        tagElement.appendChild(deleteBtn);
        range.deleteContents();
        range.insertNode(tagElement);
        const spaceNode = document.createTextNode(" ");
        tagElement.after(spaceNode);
        range.setStartAfter(spaceNode);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
        handleContentChange();
        if (onTagInsert) {
          onTagInsert(newTag);
        }
        editorRef.current.focus();
      },
      [onTagInsert, handleContentChange]
    );
    const removeTag = useCallback$4(
      (tagId) => {
        const numericTagId = typeof tagId === "string" ? parseInt(tagId) : tagId;
        setTags((prev) => prev.filter((tag) => tag.id !== numericTagId));
        setSelectedTag((prev) => prev?.id === numericTagId ? null : prev);
        const tagElement = document.querySelector(
          `[data-tag-id="${numericTagId}"]`
        );
        if (tagElement) {
          const selection = window.getSelection();
          const range = document.createRange();
          range.setStartBefore(tagElement);
          range.collapse(true);
          const nextNode = tagElement.nextSibling;
          tagElement.remove();
          if (nextNode && nextNode.nodeType === Node.TEXT_NODE && /^[\u00A0\s]*$/.test(nextNode.nodeValue)) {
            nextNode.remove();
          }
          selection.removeAllRanges();
          selection.addRange(range);
          handleContentChange();
        }
      },
      [handleContentChange]
    );
    useImperativeHandle$1(ref, () => ({
      insertTagAtCursor: (tagData) => {
        insertTagAtCursor(tagData);
      },
      focus: () => {
        if (editorRef.current) {
          editorRef.current.focus();
        }
      },
      getValue: () => {
        return getEditorTextContent();
      },
      get innerHTML() {
        return editorRef.current ? editorRef.current.innerHTML : "";
      },
      set innerHTML(content) {
        if (editorRef.current) {
          isUpdatingFromExternal.current = true;
          editorRef.current.innerHTML = content;
          setTimeout(() => {
            isUpdatingFromExternal.current = false;
          }, 500);
        }
      }
    }));
    const handleEditorClick = useCallback$4(
      (e) => {
        const tagElement = e.target.closest(".inline-tag");
        if (tagElement) {
          const tagId = parseInt(tagElement.getAttribute("data-tag-id"));
          const tagData = tagElement.getAttribute("data-tag-data");
          if (e.target.classList.contains("delete-btn")) {
            e.preventDefault();
            e.stopPropagation();
            removeTag(tagId);
            return;
          } else {
            e.preventDefault();
            e.stopPropagation();
            if (tagData) {
              navigator.clipboard.writeText(tagData).then(() => {
                const originalBg = tagElement.style.backgroundColor;
                setTimeout(() => {
                  tagElement.style.backgroundColor = originalBg;
                }, 200);
              }).catch(() => {
                const textArea = document.createElement("textarea");
                textArea.value = tagData;
                textArea.style.position = "fixed";
                textArea.style.left = "-999999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                  document.execCommand("copy");
                } catch (err) {
                  console.error("複製失敗:", err);
                }
                document.body.removeChild(textArea);
                editorRef.current?.focus();
              });
            }
            const currentTag = tags.find((tag) => tag.id === tagId);
            const isCurrentlySelected = selectedTag?.id === tagId;
            document.querySelectorAll(".inline-tag").forEach((tag) => {
              tag.style.boxShadow = "";
            });
            if (isCurrentlySelected) {
              setSelectedTag(null);
            } else if (currentTag) {
              setSelectedTag(currentTag);
              tagElement.style.boxShadow = "0 0 0 2px #FFFFFF";
            }
            return;
          }
        }
        setSelectedTag(null);
        document.querySelectorAll(".inline-tag").forEach((tag) => {
          tag.style.boxShadow = "";
        });
        const x = e.clientX;
        const y = e.clientY;
        editorRef.current.focus();
        setCursorPosition(x, y);
        if (shouldShowPanel && onShowPanel) {
          if (showInputPanel) {
            onShowPanel(false);
          } else {
            setTimeout(() => {
              onShowPanel(true);
            }, 500);
          }
        }
      },
      [
        tags,
        selectedTag,
        removeTag,
        shouldShowPanel,
        showInputPanel,
        onShowPanel,
        setCursorPosition
      ]
    );
    const handleKeyDown = useCallback$4(
      (e) => {
        if (onKeyDown) {
          onKeyDown(e);
          if (e.defaultPrevented) {
            return;
          }
        }
        if ((e.metaKey || e.ctrlKey) && e.key === "c" && selectedTag) {
          e.preventDefault();
          navigator.clipboard.writeText(selectedTag.data);
          return;
        }
        if (e.key === "Backspace" || e.key === "Delete") {
          if (selectedTag) {
            e.preventDefault();
            removeTag(selectedTag.id);
            return;
          }
          const selection = window.getSelection();
          if (!selection.rangeCount) return;
          const range = selection.getRangeAt(0);
          if (!range.collapsed) return;
          let tagToDelete = null;
          if (e.key === "Backspace") {
            const container = range.startContainer;
            const offset = range.startOffset;
            if (container.nodeType === Node.TEXT_NODE) {
              if (offset === 0 && container.previousSibling?.classList?.contains("inline-tag")) {
                tagToDelete = container.previousSibling;
              }
            } else {
              if (offset > 0) {
                const prevNode = container.childNodes[offset - 1];
                if (prevNode?.classList?.contains("inline-tag")) {
                  tagToDelete = prevNode;
                }
              }
            }
          } else if (e.key === "Delete") {
            const container = range.endContainer;
            const offset = range.endOffset;
            if (container.nodeType === Node.TEXT_NODE) {
              if (offset === container.textContent.length && container.nextSibling?.classList?.contains("inline-tag")) {
                tagToDelete = container.nextSibling;
              }
            } else {
              if (offset < container.childNodes.length) {
                const nextNode = container.childNodes[offset];
                if (nextNode?.classList?.contains("inline-tag")) {
                  tagToDelete = nextNode;
                }
              }
            }
          }
          if (tagToDelete) {
            e.preventDefault();
            const tagId = parseInt(tagToDelete.getAttribute("data-tag-id"));
            removeTag(tagId);
          }
        }
      },
      [selectedTag, removeTag, onKeyDown]
    );
    const handleCompositionStart = useCallback$4(
      (e) => {
        setIsComposing(true);
        if (onCompositionStart) {
          onCompositionStart(e);
        }
      },
      [onCompositionStart]
    );
    const handleCompositionEnd = useCallback$4(
      (e) => {
        setIsComposing(false);
        setTimeout(() => {
          handleContentChange();
        }, 0);
        if (onCompositionEnd) {
          onCompositionEnd(e);
        }
      },
      [onCompositionEnd, handleContentChange]
    );
    const handleInput = useCallback$4(() => {
      if (!isComposing && !isRestoring && !isUpdatingFromExternal.current) {
        setTimeout(() => {
          handleContentChange();
        }, 0);
      }
    }, [isComposing, isRestoring, handleContentChange]);
    useEffect$5(() => {
      const editor = editorRef.current;
      if (!editor) return;
      const resizeObserver = new ResizeObserver(() => {
        editor.style.height = "auto";
        const scrollHeight = Math.max(editor.scrollHeight, 60);
        editor.style.height = `${Math.min(scrollHeight, 400)}px`;
      });
      resizeObserver.observe(editor);
      return () => {
        resizeObserver.disconnect();
      };
    }, []);
    useEffect$5(() => {
      if (initialHtmlContent && editorRef.current && !isInitialized) {
        setIsRestoring(true);
        isUpdatingFromExternal.current = true;
        editorRef.current.innerHTML = initialHtmlContent;
        lastReportedValue.current = getEditorTextContent();
        const tagElements = editorRef.current.querySelectorAll(".inline-tag");
        const restoredTags = [];
        tagElements.forEach((element) => {
          const tagId = parseInt(element.getAttribute("data-tag-id"));
          const tagData = element.getAttribute("data-tag-data");
          if (!isNaN(tagId) && tagData) {
            const tagNameElement = element.querySelector(
              "span:not(.delete-btn)"
            );
            const tagName = tagNameElement ? tagNameElement.textContent.trim() : "Tag";
            restoredTags.push({
              id: tagId,
              data: tagData,
              name: tagName
            });
          }
        });
        setTags(restoredTags);
        setIsInitialized(true);
        setTimeout(() => {
          setIsRestoring(false);
          isUpdatingFromExternal.current = false;
        }, 500);
      }
    }, [initialHtmlContent, isInitialized, getEditorTextContent]);
    useEffect$5(() => {
      if (!initialHtmlContent && editorRef.current && (!value || value === "") && editorRef.current.textContent === "" && !isInitialized) {
        const defaultContent = generateDefaultContent();
        isUpdatingFromExternal.current = true;
        editorRef.current.textContent = defaultContent;
        lastReportedValue.current = defaultContent;
        setIsInitialized(true);
        setTimeout(() => {
          isUpdatingFromExternal.current = false;
          handleContentChange();
        }, 500);
      }
    }, [
      value,
      generateDefaultContent,
      handleContentChange,
      initialHtmlContent,
      isInitialized
    ]);
    useEffect$5(() => {
      if (isInitialized && value !== void 0 && value !== lastReportedValue.current && !isUpdatingFromExternal.current && !isFocused) {
        isUpdatingFromExternal.current = true;
        editorRef.current.textContent = value;
        lastReportedValue.current = value;
        setTimeout(() => {
          isUpdatingFromExternal.current = false;
        }, 500);
      }
    }, [value, isInitialized, isFocused]);
    useEffect$5(() => {
      const editor = editorRef.current;
      if (!editor) return;
      const handleFocus = () => setIsFocused(true);
      const handleBlur = () => {
        setIsFocused(false);
        setTimeout(() => {
          if (!isUpdatingFromExternal.current) {
            handleContentChange();
          }
        }, 0);
      };
      editor.addEventListener("focus", handleFocus);
      editor.addEventListener("blur", handleBlur);
      return () => {
        editor.removeEventListener("focus", handleFocus);
        editor.removeEventListener("blur", handleBlur);
      };
    }, [handleContentChange]);
    useEffect$5(() => {
      if (isFocused) {
        const findReactFlowNode = (element) => {
          let current = element;
          while (current && !current.classList?.contains("react-flow__node")) {
            current = current.parentElement;
          }
          return current;
        };
        const reactFlowNode = findReactFlowNode(editorRef.current);
        if (reactFlowNode) {
          reactFlowNode._originalClassName = reactFlowNode.className;
          reactFlowNode.classList.add("nodrag");
        }
        return () => {
          if (reactFlowNode && reactFlowNode._originalClassName) {
            reactFlowNode.className = reactFlowNode._originalClassName;
            delete reactFlowNode._originalClassName;
          }
        };
      }
    }, [isFocused]);
    useEffect$5(() => {
      const editor = editorRef.current;
      if (!editor) return;
      const handleWheelCapture = (e) => {
        if (isFocused && (e.target === editor || editor.contains(e.target))) {
          e.stopPropagation();
          const isAtTop = editor.scrollTop <= 0;
          const isAtBottom = Math.abs(
            editor.scrollTop + editor.clientHeight - editor.scrollHeight
          ) <= 1;
          if (isAtTop && e.deltaY < 0 || isAtBottom && e.deltaY > 0) {
            e.preventDefault();
          }
        }
      };
      const preventZoom = (e) => {
        if (isFocused && (e.ctrlKey || e.metaKey) && (e.target === editor || editor.contains(e.target))) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      document.addEventListener("wheel", handleWheelCapture, {
        passive: false,
        capture: true
      });
      document.addEventListener("wheel", preventZoom, {
        passive: false,
        capture: true
      });
      return () => {
        document.removeEventListener("wheel", handleWheelCapture, {
          passive: false,
          capture: true
        });
        document.removeEventListener("wheel", preventZoom, {
          passive: false,
          capture: true
        });
      };
    }, [isFocused]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: editorRef,
        contentEditable: true,
        suppressContentEditableWarning: true,
        onInput: handleInput,
        onClick: handleEditorClick,
        onKeyDown: handleKeyDown,
        onCompositionStart: handleCompositionStart,
        onCompositionEnd: handleCompositionEnd,
        className: `
          w-full 
          border 
          border-gray-300 
          rounded 
          p-3 
          text-sm 
          resize-none 
          overflow-auto 
          min-h-[60px] 
          max-h-[400px]
          font-mono
          ${isFocused ? "z-50 shadow-md border-blue-400" : ""} 
          ${className}
        `,
        style: {
          fontFamily: 'Monaco, Menlo, Consolas, "Courier New", monospace',
          lineHeight: "1.5",
          whiteSpace: "pre-wrap",
          wordBreak: "break-word",
          ...props.style
        },
        "data-placeholder": placeholder,
        ...props
      }
    );
  }
);
CombineTextEditor.displayName = "CombineTextEditor";

const React$6 = await importShared('react');
const {memo: memo$1,useState: useState$7,useEffect: useEffect$4,useCallback: useCallback$3,useRef: useRef$3,useMemo: useMemo$1} = React$6;
const {flushSync} = await importShared('react-dom');

const CombineTextNode = ({ data, isConnectable, id }) => {
  const edges = useEdges();
  const nodes = useNodes();
  const [content, setContent] = useState$7(data?.textToCombine || "");
  const [showInputPanel, setShowInputPanel] = useState$7(false);
  const [filterText, setFilterText] = useState$7("");
  const [inputHandles, setInputHandles] = useState$7(
    data?.inputHandles || [{ id: "text0" }]
  );
  const [activeTab, setActiveTab] = useState$7(data?.activeTab || "editor");
  const [editorHtmlContent, setEditorHtmlContent] = useState$7(
    data?.editorHtmlContent || ""
  );
  const [isInitialized, setIsInitialized] = useState$7(false);
  const textareaRef = useRef$3(null);
  const previewRef = useRef$3(null);
  const inputPanelRef = useRef$3(null);
  const stableContentRef = useRef$3(data?.textToCombine || "");
  const updateTimeoutRef = useRef$3(null);
  const isUpdatingRef = useRef$3(false);
  const lastRenderContentRef = useRef$3("");
  const connectionCount = useMemo$1(
    () => edges.filter((edge) => edge.target === id).length,
    [edges, id]
  );
  const getEditorContent = useCallback$3(() => {
    if (!textareaRef.current) return null;
    try {
      if (typeof textareaRef.current.getValue === "function") {
        return textareaRef.current.getValue();
      }
    } catch (error) {
      console.warn("獲取編輯器內容失敗:", error);
    }
    return null;
  }, []);
  const updateContent = useCallback$3(
    (newContent) => {
      if (isUpdatingRef.current) return;
      if (!newContent && stableContentRef.current) {
        console.warn("拒絕空內容更新，保持現有內容");
        return;
      }
      if (newContent === stableContentRef.current) {
        return;
      }
      isUpdatingRef.current = true;
      try {
        stableContentRef.current = newContent;
        setContent(newContent);
        if (data && typeof data.updateNodeData === "function") {
          data.updateNodeData("textToCombine", newContent);
        }
      } finally {
        setTimeout(() => {
          isUpdatingRef.current = false;
        }, 100);
      }
    },
    [data]
  );
  const getCurrentContent = useCallback$3(() => {
    if (activeTab === "editor") {
      const editorContent = getEditorContent();
      if (editorContent !== null) {
        return editorContent;
      }
    }
    return content || stableContentRef.current || "";
  }, [activeTab, content, getEditorContent]);
  const handleTextChange = useCallback$3(
    (e) => {
      const newContent = e.target.value;
      if (updateTimeoutRef.current) {
        clearTimeout(updateTimeoutRef.current);
      }
      updateTimeoutRef.current = setTimeout(() => {
        updateContent(newContent, "handleTextChange");
        if (textareaRef.current) {
          try {
            const htmlContent = textareaRef.current.innerHTML || "";
            if (htmlContent !== editorHtmlContent) {
              setEditorHtmlContent(htmlContent);
              if (data && typeof data.updateNodeData === "function") {
                data.updateNodeData("editorHtmlContent", htmlContent);
              }
            }
          } catch (error) {
            console.warn("更新 HTML 內容失敗:", error);
          }
        }
      }, 300);
    },
    [updateContent, editorHtmlContent, data]
  );
  const handleTagInsert = useCallback$3(() => {
    setTimeout(() => {
      const editorContent = getEditorContent();
      if (editorContent) {
        updateContent(editorContent, "handleTagInsert");
        if (textareaRef.current) {
          try {
            const htmlContent = textareaRef.current.innerHTML || "";
            setEditorHtmlContent(htmlContent);
            if (data && typeof data.updateNodeData === "function") {
              data.updateNodeData("editorHtmlContent", htmlContent);
            }
          } catch (error) {
            console.warn("更新 HTML 內容失敗:", error);
          }
        }
      }
    }, 200);
  }, [getEditorContent, updateContent, data]);
  const handleTabChange = useCallback$3(
    (newTab) => {
      if (activeTab === "editor" && newTab === "preview") {
        const currentContent = getEditorContent();
        if (currentContent && currentContent !== stableContentRef.current) {
          try {
            flushSync(() => {
              updateContent(currentContent, "handleTabChange");
              setActiveTab(newTab);
            });
          } catch (error) {
            console.error("flushSync 失敗:", error);
            updateContent(currentContent, "handleTabChange");
            setActiveTab(newTab);
          }
          if (data && typeof data.updateNodeData === "function") {
            data.updateNodeData("activeTab", newTab);
          }
          return;
        }
      }
      setActiveTab(newTab);
      if (data && typeof data.updateNodeData === "function") {
        data.updateNodeData("activeTab", newTab);
      }
    },
    [activeTab, getEditorContent, updateContent, data]
  );
  const copyToClipboard = useCallback$3(async () => {
    try {
      const selection = window.getSelection();
      let textToCopy = "";
      let copyType = "";
      if (selection && selection.toString().trim()) {
        textToCopy = selection.toString();
        copyType = "選取內容";
      } else {
        textToCopy = getCurrentContent();
        copyType = "Preview內容";
      }
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(textToCopy);
          if (typeof window !== "undefined" && window.notify) {
            window.notify({
              message: `已複製${copyType}到剪貼板`,
              type: "success",
              duration: 2e3
            });
          }
          return;
        } catch (clipboardError) {
          console.warn("Clipboard API 失敗，嘗試 fallback:", clipboardError);
        }
      }
      const textArea = document.createElement("textarea");
      textArea.value = textToCopy;
      textArea.style.cssText = "position:fixed;top:0;left:0;opacity:0;pointer-events:none;";
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      const successful = document.execCommand("copy");
      document.body.removeChild(textArea);
      if (successful) {
        if (typeof window !== "undefined" && window.notify) {
          window.notify({
            message: `已複製${copyType}到剪貼板`,
            type: "success",
            duration: 2e3
          });
        }
      } else {
        throw new Error("所有複製方法都失敗");
      }
    } catch (error) {
      console.error("複製失敗:", error);
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "複製失敗，請手動複製 Prompt",
          type: "error",
          duration: 3e3
        });
      }
    }
  }, [getCurrentContent]);
  const closeInputPanel = useCallback$3(() => {
    setShowInputPanel(false);
    setFilterText("");
  }, []);
  const handleShowPanel = useCallback$3(
    (show) => {
      if (activeTab === "editor") {
        setShowInputPanel(show);
        if (!show) {
          setFilterText("");
        }
      }
    },
    [activeTab]
  );
  const handleTagClick = useCallback$3(
    (nodeInfo) => {
      if (textareaRef.current && textareaRef.current.insertTagAtCursor) {
        textareaRef.current.insertTagAtCursor(nodeInfo);
        setTimeout(() => {
          const newContent = getEditorContent();
          if (newContent) {
            updateContent(newContent, "handleTagClick");
          }
        }, 100);
      }
      closeInputPanel();
    },
    [getEditorContent, updateContent, closeInputPanel]
  );
  const handleTagDragStart = useCallback$3((e, nodeInfo) => {
    e.dataTransfer.setData("text/plain", JSON.stringify(nodeInfo));
    e.dataTransfer.effectAllowed = "copy";
  }, []);
  const handleWheel = useCallback$3((e) => {
    const target = e.currentTarget;
    const isScrollable = target.scrollHeight > target.clientHeight;
    if (isScrollable) {
      e.stopPropagation();
      const deltaY = e.deltaY;
      const currentScrollTop = target.scrollTop;
      const maxScrollTop = target.scrollHeight - target.clientHeight;
      const newScrollTop = Math.max(
        0,
        Math.min(maxScrollTop, currentScrollTop + deltaY)
      );
      target.scrollTop = newScrollTop;
      e.preventDefault();
    } else {
      e.stopPropagation();
      e.preventDefault();
    }
  }, []);
  const handleMouseDown = useCallback$3((e) => e.stopPropagation(), []);
  const handleMouseMove = useCallback$3((e) => e.stopPropagation(), []);
  const handleMouseUp = useCallback$3((e) => e.stopPropagation(), []);
  const getFlowId = useCallback$3(() => {
    if (data?.flowId) return data.flowId;
    const urlParams = new URLSearchParams(window.location.search);
    const urlFlowId = urlParams.get("flowId") || urlParams.get("flow_id");
    if (urlFlowId) return urlFlowId;
    const pathMatch = window.location.pathname.match(/\/flow\/([^\/]+)/);
    if (pathMatch) return pathMatch[1];
    if (typeof window !== "undefined" && window.currentFlowId) {
      return window.currentFlowId;
    }
    return "";
  }, [data?.flowId]);
  const connectedNodesInfo = useMemo$1(() => {
    const connectedEdges = edges.filter((edge) => edge.target === id);
    return connectedEdges.map((edge) => {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      const getNodeDisplayName = (sourceNode2) => {
        if (!sourceNode2) return "Unknown";
        switch (sourceNode2.type) {
          case "customInput":
          case "input":
            return "Input";
          case "aiCustomInput":
          case "ai":
            return "AI";
          case "aim_ml":
            return "ML Node";
          case "browserExtensionInput":
            return "Browser Extension Input";
          case "webhook_input":
            return "Webhook Input Node";
          case "knowledgeRetrieval":
            return "Knowledge Retrieval";
          case "extract_data":
            return "Extract Data Node";
          case "line_webhook_input":
            return "Line Webhook Input";
          case "httpRequest":
            return "HTTP Request Node";
          case "schedule_trigger":
            return "Schedule node";
          case "combine_text":
            return "Combine Text Node";
          case "webhook_output":
            return "Webhook Output Node";
          case "browserExtensionOutput":
            return "Browser Extension Output";
          case "router_switch":
            return "Router Switch Node";
          default:
            return `${sourceNode2.type.charAt(0).toUpperCase() + sourceNode2.type.slice(1)}`;
        }
      };
      const getNodeTagColor = (nodeName2) => {
        const colorMap = {
          Input: "#0075FF",
          AI: "#FFAA1E",
          "Knowledge Retrieval": "#87CEEB",
          "Browser Extension Input": "#1FCD28",
          "Line Webhook Input": "#06C755",
          "Extract Data Node": "#D97706",
          "ML Node": "#098D7F",
          "HTTP Request Node": "#F8D7DA",
          "Schedule node": "#DCCAFA",
          "Webhook Input Node": "#FC6165",
          "Combine Text Node": "#4E7ECF",
          "Router Switch Node": "#00ced1"
        };
        return colorMap[nodeName2] || "#6b7280";
      };
      const nodeName = getNodeDisplayName(sourceNode);
      return {
        id: edge.source,
        name: nodeName,
        outputName: edge.sourceHandle || "output",
        handleId: edge.targetHandle,
        nodeType: sourceNode?.type || "unknown",
        data: `QOCA__NODE_ID__${edge.source}__NODE_OUTPUT_NAME__${edge.sourceHandle || "output"}`,
        code: `QOCA__NODE_ID__${edge.source}__NODE_OUTPUT_NAME__${edge.sourceHandle || "output"}`,
        color: getNodeTagColor(nodeName)
      };
    });
  }, [edges, nodes, id]);
  const filteredNodes = useMemo$1(
    () => connectedNodesInfo.filter(
      (node) => node.name.toLowerCase().includes(filterText.toLowerCase())
    ),
    [connectedNodesInfo, filterText]
  );
  const previewContent = useMemo$1(() => {
    const displayContent = getCurrentContent();
    if (displayContent !== lastRenderContentRef.current) {
      console.log("Preview 內容更新:", displayContent?.substring(0, 100));
      lastRenderContentRef.current = displayContent;
    }
    return displayContent || "點擊此處編輯內容...";
  }, [getCurrentContent]);
  useEffect$4(() => {
    if (!isInitialized && data) {
      console.log("執行一次性初始化同步");
      const initialContent = data.textToCombine || "";
      stableContentRef.current = initialContent;
      lastRenderContentRef.current = initialContent;
      if (data.activeTab && data.activeTab !== activeTab) {
        setActiveTab(data.activeTab);
      }
      if (data.editorHtmlContent && data.editorHtmlContent !== editorHtmlContent) {
        setEditorHtmlContent(data.editorHtmlContent);
      }
      if (initialContent !== content) {
        setContent(initialContent);
      }
      setIsInitialized(true);
    }
  }, [data, isInitialized, activeTab, editorHtmlContent, content]);
  useEffect$4(() => {
    const singleHandle = [{ id: "text" }];
    if (JSON.stringify(singleHandle) !== JSON.stringify(inputHandles)) {
      setInputHandles(singleHandle);
      if (data && typeof data.updateNodeData === "function") {
        data.updateNodeData("inputHandles", singleHandle);
      }
    }
  }, [inputHandles, data]);
  useEffect$4(() => {
    const connectedEdges = edges.filter((edge) => edge.target === id);
    if (connectedEdges.length > 0 && data && typeof data.updateNodeData === "function") {
      const currentNodeInput = data.node_input || {};
      const newNodeInput = {};
      const existingConnections = /* @__PURE__ */ new Map();
      Object.entries(currentNodeInput).forEach(([key, value]) => {
        if (key.startsWith("text") && value.node_id) {
          const connectionKey = `${value.node_id}:${value.output_name || "output"}`;
          existingConnections.set(connectionKey, {
            key,
            value,
            index: parseInt(key.replace("text", "")) || 0
          });
        }
      });
      const sortedEdges = connectedEdges.sort((a, b) => {
        const aConnectionKey = `${a.source}:${a.sourceHandle || "output"}`;
        const bConnectionKey = `${b.source}:${b.sourceHandle || "output"}`;
        const aExisting = existingConnections.get(aConnectionKey);
        const bExisting = existingConnections.get(bConnectionKey);
        if (aExisting && bExisting) {
          return aExisting.index - bExisting.index;
        } else if (aExisting) {
          return -1;
        } else if (bExisting) {
          return 1;
        } else {
          return a.source.localeCompare(b.source);
        }
      });
      const usedIndices = /* @__PURE__ */ new Set();
      sortedEdges.forEach((edge) => {
        const connectionKey = `${edge.source}:${edge.sourceHandle || "output"}`;
        const existingConnection = existingConnections.get(connectionKey);
        let inputKey;
        if (existingConnection) {
          inputKey = existingConnection.key;
          usedIndices.add(existingConnection.index);
        } else {
          let newIndex = 0;
          while (usedIndices.has(newIndex)) {
            newIndex++;
          }
          inputKey = `text${newIndex}`;
          usedIndices.add(newIndex);
        }
        const sourceNode = nodes.find((n) => n.id === edge.source);
        let returnName = edge.label || "output";
        if (sourceNode) {
          if (sourceNode.type === "customInput" || sourceNode.type === "input") {
            if (sourceNode.data?.fields?.[0]?.inputName) {
              returnName = sourceNode.data.fields[0].inputName;
            }
          } else if (sourceNode.type === "browserExtensionInput") {
            const targetItem = sourceNode.data?.items?.find(
              (item) => item.id === edge.sourceHandle
            );
            if (targetItem?.name) {
              returnName = targetItem.name;
            }
          } else if (sourceNode.type === "aiCustomInput" || sourceNode.type === "ai") {
            returnName = "output";
          } else if (sourceNode.type === "knowledgeRetrieval") {
            returnName = "output";
          } else if (sourceNode.type === "schedule_trigger") {
            returnName = "trigger";
          } else if (sourceNode.type === "router_switch") {
            returnName = edge.sourceHandle || "output";
          }
        }
        newNodeInput[inputKey] = {
          node_id: edge.source,
          output_name: edge.sourceHandle || "output",
          type: "string",
          return_name: returnName
        };
      });
      if (JSON.stringify(currentNodeInput) !== JSON.stringify(newNodeInput)) {
        data.updateNodeData("node_input", newNodeInput);
      }
    }
  }, [edges, id, data, nodes]);
  useEffect$4(() => {
    return () => {
      if (updateTimeoutRef.current) {
        clearTimeout(updateTimeoutRef.current);
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-96", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[#dbeafe] p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 flex items-center justify-center text-white mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "combine_text" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Combine Text" })
        ] }),
        connectionCount > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs bg-blue-200 text-blue-800 px-2 py-1 rounded-full", children: "已連線" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 font-bold", children: "Compose" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "group relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: copyToClipboard,
                className: "px-3 py-1 text-white rounded-md transition-colors text-sm flex items-center space-x-1",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: CopytIncon,
                    alt: "Copy Icon",
                    className: "text-white",
                    width: 16,
                    height: 16
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs text-white bg-gray-800 rounded shadow-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap z-[10000]", children: [
              "複製",
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 w-0 h-0 border-l-4 border-r-4 border-t-4 border-transparent border-t-gray-800" })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex mb-4 bg-gray-100 rounded-lg p-1 mt-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => handleTabChange("editor"),
              className: `flex-1 py-2 px-4 rounded-md text-sm font-medium transition-all duration-200 ${activeTab === "editor" ? "bg-white text-gray-900 shadow-sm" : "text-gray-600 hover:text-gray-900"}`,
              children: "Editor"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: () => handleTabChange("preview"),
              className: `flex-1 py-2 px-4 rounded-md text-sm font-medium transition-all duration-200 ${activeTab === "preview" ? "bg-white text-gray-900 shadow-sm" : "text-gray-600 hover:text-gray-900"}`,
              children: "Preview"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative", children: activeTab === "editor" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          CombineTextEditor,
          {
            ref: textareaRef,
            value: isInitialized ? void 0 : content,
            onChange: handleTextChange,
            onTagInsert: handleTagInsert,
            placeholder: "點擊此處編輯內容...",
            className: "bg-gray-900 text-white border-gray-300",
            flowId: getFlowId(),
            initialHtmlContent: editorHtmlContent,
            shouldShowPanel: connectionCount > 0,
            showInputPanel,
            onShowPanel: handleShowPanel,
            style: {
              minHeight: "220px",
              maxHeight: "400px",
              color: "rgba(255, 255, 255, 0.9)"
            },
            onWheel: handleWheel,
            onMouseDown: handleMouseDown,
            onMouseMove: handleMouseMove,
            onMouseUp: handleMouseUp
          },
          `editor-${isInitialized}`
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            ref: previewRef,
            className: "font-mono text-sm bg-gray-100 text-gray-800 p-3 rounded border",
            style: {
              fontFamily: 'Monaco, Menlo, Consolas, "Courier New", monospace',
              minHeight: "220px",
              maxHeight: "400px",
              overflow: "auto",
              wordBreak: "break-all",
              overflowWrap: "anywhere"
            },
            onWheel: handleWheel,
            onMouseDown: handleMouseDown,
            onMouseMove: handleMouseMove,
            onMouseUp: handleMouseUp,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "pre",
              {
                className: "whitespace-pre-wrap",
                style: {
                  wordBreak: "break-all",
                  whiteSpace: "pre-wrap",
                  margin: 0
                },
                children: previewContent
              }
            )
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "text",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          left: "-6px",
          top: "50%",
          transform: "translateY(-50%)"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "source",
        position: Position.Right,
        id: "output",
        style: {
          background: "#e5e7eb",
          border: "1px solid #D3D3D3",
          width: "12px",
          height: "12px",
          right: "-6px",
          top: "50%",
          transform: "translateY(-50%)"
        },
        isConnectable
      }
    ),
    showInputPanel && connectionCount > 0 && activeTab === "editor" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "fixed inset-0 z-[9999]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "absolute inset-0 bg-transparent pointer-events-auto",
          onClick: closeInputPanel
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          ref: inputPanelRef,
          className: "absolute bg-white rounded-lg shadow-xl w-80 flex flex-col pointer-events-auto border border-gray-200 z-10",
          style: {
            left: `${(data?.position?.x || 0) - 320}px`,
            top: `${data?.position?.y || 0}px`,
            maxHeight: "400px"
          },
          onClick: (e) => e.stopPropagation(),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between border-b p-2 flex-shrink-0", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex-1 mr-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "svg",
                  {
                    xmlns: "http://www.w3.org/2000/svg",
                    width: "16",
                    height: "16",
                    viewBox: "0 0 24 24",
                    fill: "none",
                    stroke: "currentColor",
                    strokeWidth: "2",
                    strokeLinecap: "round",
                    strokeLinejoin: "round",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "circle",
                        {
                          cx: "11",
                          cy: "11",
                          r: "8"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "line",
                        {
                          x1: "21",
                          y1: "21",
                          x2: "16.65",
                          y2: "16.65"
                        }
                      )
                    ]
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "text",
                    value: filterText,
                    onChange: (e) => setFilterText(e.target.value),
                    placeholder: "Search...",
                    className: "w-full pl-10 p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: closeInputPanel,
                  className: "text-gray-400 hover:text-gray-600 transition-colors flex-shrink-0",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "svg",
                    {
                      xmlns: "http://www.w3.org/2000/svg",
                      width: "20",
                      height: "20",
                      viewBox: "0 0 24 24",
                      fill: "none",
                      stroke: "currentColor",
                      strokeWidth: "2",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "line",
                          {
                            x1: "18",
                            y1: "6",
                            x2: "6",
                            y2: "18"
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "line",
                          {
                            x1: "6",
                            y1: "6",
                            x2: "18",
                            y2: "18"
                          }
                        )
                      ]
                    }
                  )
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "flex-1 overflow-y-auto p-4 min-h-0",
                style: { maxHeight: "calc(400px - 60px)" },
                onWheelCapture: (e) => e.stopPropagation(),
                onMouseDownCapture: (e) => e.stopPropagation(),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "mb-3 block text-sm font-medium text-gray-700", children: "Input" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col items-start", children: [
                    filteredNodes.map((nodeInfo, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "flex items-center px-3 py-2 rounded cursor-pointer text-white text-sm font-medium hover:opacity-80 transition-opacity mr-2 mb-2 w-full",
                        style: { backgroundColor: nodeInfo.color },
                        onClick: () => handleTagClick(nodeInfo),
                        onDragStart: (e) => handleTagDragStart(e, nodeInfo),
                        draggable: true,
                        title: "點擊插入或拖拽到文字區域",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "truncate", children: nodeInfo.name })
                      },
                      `${nodeInfo.id}-${index}`
                    )),
                    filteredNodes.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-gray-500 text-sm text-center py-8 w-full", children: filterText ? "沒有找到符合的節點" : "沒有連線的節點" })
                  ] })
                ]
              }
            )
          ]
        }
      )
    ] })
  ] });
};
const CombineTextNode$1 = memo$1(CombineTextNode);

const deleteIcon = "data:image/svg+xml,%3csvg%20width='16'%20height='17'%20viewBox='0%200%2016%2017'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill='%23fff'%20fill-opacity='.01'%20d='M0%20.5h16v16H0z'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M13.71%203.544a.533.533%200%200%200-.754-.754L8%207.746%203.044%202.79a.533.533%200%201%200-.754.754L7.246%208.5%202.29%2013.456a.533.533%200%200%200%20.754.755L8%209.253l4.956%204.957a.534.534%200%200%200%20.755-.755L8.753%208.5l4.957-4.956z'%20fill='%231C2024'/%3e%3c/svg%3e";

await importShared('react');
const DeleteIcon = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `flex items-center justify-center`,
      style: {
        width: "14px",
        height: "14px",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "img",
        {
          src: deleteIcon,
          width: 32,
          height: 32,
          className: "max-w-full max-h-full object-contain",
          style: {
            maxWidth: "100%",
            maxHeight: "100%",
            objectFit: "contain"
          }
        }
      )
    }
  );
};

const React$5 = await importShared('react');
const {memo,useState: useState$6,useEffect: useEffect$3,useCallback: useCallback$2,useRef: useRef$2} = React$5;
const RouterSwitchNode = ({ data, isConnectable, id }) => {
  const [selectedModelId, setSelectedModelId] = useState$6(data?.llm_id || "1");
  const [routers, setRouters] = useState$6(
    data?.routers || [
      {
        router_id: "router0",
        router_name: "Router",
        ai_condition: "",
        connection_id: `router_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
      }
    ]
  );
  const [modelOptions, setModelOptions] = useState$6([]);
  const [isLoadingModels, setIsLoadingModels] = useState$6(false);
  const [draggedIndex, setDraggedIndex] = useState$6(null);
  const [dragOverIndex, setDragOverIndex] = useState$6(null);
  const [isScrollContainerHovered, setIsScrollContainerHovered] = useState$6(false);
  const isInitialized = useRef$2(false);
  const isUpdating = useRef$2(false);
  const lastModelOptionsRef = useRef$2([]);
  const scrollContainerRef = useRef$2(null);
  const updateParentState = useCallback$2(
    (key, value) => {
      console.log("嘗試更新父組件狀態:", key, value);
      if (isUpdating.current) {
        console.log("更新被阻擋：正在更新中");
        return false;
      }
      if (data && typeof data.updateNodeData === "function") {
        isUpdating.current = true;
        try {
          console.log("執行父組件更新:", key);
          data.updateNodeData(key, value);
          console.log("父組件更新成功");
          return true;
        } catch (error) {
          console.error("父組件更新失敗:", error);
          return false;
        } finally {
          setTimeout(() => {
            isUpdating.current = false;
            console.log("更新狀態重置");
          }, 50);
        }
      } else {
        console.warn("無法更新父組件：data 或 updateNodeData 不存在");
      }
      return false;
    },
    [data]
  );
  const loadModelOptions = useCallback$2(async () => {
    if (isLoadingModels) return;
    setIsLoadingModels(true);
    try {
      console.log("開始載入模型選項...");
      const options = await llmService.getModelOptions();
      const optionsString = JSON.stringify(options);
      const lastOptionsString = JSON.stringify(lastModelOptionsRef.current);
      if (optionsString === lastOptionsString) {
        console.log("模型選項未變化，跳過更新");
        return;
      }
      console.log("API 返回的模型選項:", options);
      if (options && options.length > 0) {
        setModelOptions(options);
        lastModelOptionsRef.current = options;
        const isCurrentModelValid = options.some(
          (opt) => opt.value === selectedModelId
        );
        if (!isCurrentModelValid) {
          let defaultModel = options[0].value;
          const defaultOption = options.find((opt) => opt.isDefault);
          if (defaultOption) {
            defaultModel = defaultOption.value;
          }
          setSelectedModelId(defaultModel);
          updateParentState("llm_id", defaultModel);
        }
      } else {
        const fallbackOptions = [
          { value: "1", label: "O3-mini (預設)" },
          { value: "2", label: "GPT-4 (預設)" }
        ];
        setModelOptions(fallbackOptions);
        lastModelOptionsRef.current = fallbackOptions;
      }
    } catch (error) {
      console.error("載入模型選項失敗:", error);
      if (error.message && (error.message.includes("已有進行中的LLM模型請求") || error.message.includes("進行中的請求") || error.message.includes("使用相同請求"))) {
        console.log("檢測到進行中的模型請求，跳過錯誤通知");
        return;
      }
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "載入模型選項失敗",
          type: "error",
          duration: 3e3
        });
      }
      const fallbackOptions = [
        { value: "1", label: "O3-mini (預設)" },
        { value: "2", label: "GPT-4 (預設)" }
      ];
      setModelOptions(fallbackOptions);
      lastModelOptionsRef.current = fallbackOptions;
    } finally {
      setIsLoadingModels(false);
    }
  }, [selectedModelId, updateParentState]);
  useEffect$3(() => {
    if (!isInitialized.current) {
      loadModelOptions();
      isInitialized.current = true;
    }
  }, [loadModelOptions]);
  useEffect$3(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) return;
    const handleWheelCapture = (e) => {
      if (isScrollContainerHovered && (e.target === scrollContainer || scrollContainer.contains(e.target))) {
        e.stopPropagation();
        const isAtTop = scrollContainer.scrollTop <= 0;
        const isAtBottom = Math.abs(
          scrollContainer.scrollTop + scrollContainer.clientHeight - scrollContainer.scrollHeight
        ) <= 1;
        if (isAtTop && e.deltaY < 0 || isAtBottom && e.deltaY > 0) {
          e.preventDefault();
        }
      }
    };
    document.addEventListener("wheel", handleWheelCapture, {
      passive: false,
      capture: true
    });
    return () => {
      document.removeEventListener("wheel", handleWheelCapture, {
        passive: false,
        capture: true
      });
    };
  }, [isScrollContainerHovered]);
  useEffect$3(() => {
    if (isUpdating.current) return;
    let hasChanges = false;
    if (data?.llm_id !== void 0 && data.llm_id !== selectedModelId) {
      setSelectedModelId(data.llm_id);
      hasChanges = true;
    }
    if (data?.routers !== void 0) {
      const dataRoutersString = JSON.stringify(data.routers);
      const currentRoutersString = JSON.stringify(routers);
      if (dataRoutersString !== currentRoutersString) {
        setRouters(data.routers);
        hasChanges = true;
      }
    }
    if (hasChanges) {
      console.log("RouterSwitchNode 數據同步完成");
    }
  }, [data?.llm_id, data?.routers]);
  const handleModelChange = useCallback$2(
    (modelId) => {
      setSelectedModelId(modelId);
      updateParentState("llm_id", modelId);
    },
    [updateParentState]
  );
  const updateRoutersToParent = useCallback$2(
    (newRouters) => {
      const routersWithOther = [...newRouters];
      const hasOtherRouter = routersWithOther.some(
        (router) => router.router_id === "default_router"
      );
      if (!hasOtherRouter) {
        routersWithOther.push({
          router_id: "default_router",
          router_name: "Other",
          ai_condition: ""
        });
      }
      console.log("更新 routers 到父組件:", routersWithOther);
      setRouters(routersWithOther);
      updateParentState("routers", routersWithOther);
    },
    [updateParentState]
  );
  const otherRouters = routers.filter((r) => r.router_id !== "default_router");
  const addRouter = useCallback$2(() => {
    if (otherRouters.length >= 8) {
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "最多只能添加 8 個 Router",
          type: "warning",
          duration: 3e3
        });
      }
      return;
    }
    let maxRouterId = -1;
    otherRouters.forEach((router) => {
      const match = router.router_id.match(/^router(\d+)$/);
      if (match) {
        const routerNum = parseInt(match[1], 10);
        if (routerNum > maxRouterId) {
          maxRouterId = routerNum;
        }
      }
    });
    const newRouterId = maxRouterId + 1;
    const existingNames = otherRouters.map((router) => router.router_name);
    let nextNumber = 1;
    while (existingNames.includes(`Router ${nextNumber}`)) {
      nextNumber++;
    }
    const connectionId = `router_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const newRouter = {
      router_id: `router${newRouterId}`,
      router_name: `Router ${nextNumber}`,
      ai_condition: "",
      connection_id: connectionId
      // 新增獨立的連線識別 ID
    };
    const newRouters = [...otherRouters, newRouter];
    updateRoutersToParent(newRouters);
  }, [otherRouters, updateRoutersToParent]);
  const deleteRouter = useCallback$2(
    (routerIndex) => {
      if (otherRouters.length <= 1) {
        if (typeof window !== "undefined" && window.notify) {
          window.notify({
            message: "至少需要保留一個 Router",
            type: "warning",
            duration: 3e3
          });
        }
        return;
      }
      const routerToDelete = otherRouters[routerIndex];
      const connectionIdToDelete = routerToDelete.connection_id || routerToDelete.router_id;
      console.log(
        `準備刪除 router ${routerToDelete.router_id}，connection_id: ${connectionIdToDelete}`
      );
      if (typeof window !== "undefined" && window.deleteEdgesBySourceHandle) {
        const currentNodeId = id;
        window.deleteEdgesBySourceHandle(currentNodeId, connectionIdToDelete);
        console.log(`已斷開與 ${connectionIdToDelete} 相關的所有連線`);
      }
      const newRouters = otherRouters.filter(
        (_, index) => index !== routerIndex
      );
      const renumberedRouters = newRouters.map((router, index) => ({
        ...router,
        router_id: `router${index}`,
        // 保留原有的 connection_id，如果沒有則生成新的
        connection_id: router.connection_id || `router_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
      }));
      updateRoutersToParent(renumberedRouters);
      if (typeof window !== "undefined") {
        const event = new CustomEvent("routerDeleted", {
          detail: {
            nodeId: id,
            deletedRouter: routerToDelete,
            remainingRouters: renumberedRouters
          }
        });
        window.dispatchEvent(event);
      }
    },
    [otherRouters, updateRoutersToParent, id]
  );
  const updateRouterName = useCallback$2(
    (index, newName) => {
      const updatedRouters = otherRouters.map(
        (router, i) => i === index ? {
          ...router,
          router_name: newName,
          // 確保 connection_id 存在
          connection_id: router.connection_id || `router_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        } : router
      );
      updateRoutersToParent(updatedRouters);
    },
    [otherRouters, updateRoutersToParent]
  );
  const updateAiCondition = useCallback$2(
    (index, newCondition) => {
      const updatedRouters = otherRouters.map(
        (router, i) => i === index ? {
          ...router,
          ai_condition: newCondition,
          // 確保 connection_id 存在
          connection_id: router.connection_id || `router_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
        } : router
      );
      updateRoutersToParent(updatedRouters);
    },
    [otherRouters, updateRoutersToParent]
  );
  const ensureConnectionIds = useCallback$2((routers2) => {
    return routers2.map((router) => ({
      ...router,
      connection_id: router.connection_id || `router_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    }));
  }, []);
  useEffect$3(() => {
    if (data?.routers !== void 0) {
      const dataRoutersString = JSON.stringify(data.routers);
      const currentRoutersString = JSON.stringify(routers);
      if (dataRoutersString !== currentRoutersString) {
        const routersWithConnectionIds = ensureConnectionIds(data.routers);
        setRouters(routersWithConnectionIds);
      }
    }
  }, [data?.routers, ensureConnectionIds]);
  const handleDragStart = useCallback$2((e, index) => {
    setDraggedIndex(index);
    setDragOverIndex(null);
    e.dataTransfer.setData("text/plain", index.toString());
    e.dataTransfer.effectAllowed = "move";
    e.stopPropagation();
  }, []);
  const handleDragOver = useCallback$2((e) => {
    e.preventDefault();
    e.stopPropagation();
    e.dataTransfer.dropEffect = "move";
  }, []);
  const handleDragEnter = useCallback$2(
    (e, index) => {
      e.preventDefault();
      e.stopPropagation();
      if (draggedIndex !== null && draggedIndex !== index) {
        setDragOverIndex(index);
      }
    },
    [draggedIndex]
  );
  const handleDragEnd = useCallback$2((e) => {
    e.preventDefault();
    e.stopPropagation();
    setDraggedIndex(null);
    setDragOverIndex(null);
  }, []);
  const handleDrop = useCallback$2(
    (e, dropIndex) => {
      e.preventDefault();
      e.stopPropagation();
      const dragIndex = draggedIndex !== null ? draggedIndex : parseInt(e.dataTransfer.getData("text/plain"));
      if (dragIndex === null || isNaN(dragIndex) || dragIndex === dropIndex) {
        setDraggedIndex(null);
        setDragOverIndex(null);
        return;
      }
      if (dragIndex < 0 || dragIndex >= otherRouters.length) {
        setDraggedIndex(null);
        setDragOverIndex(null);
        return;
      }
      const newRouters = [...otherRouters];
      const [draggedItem] = newRouters.splice(dragIndex, 1);
      let insertIndex;
      if (dropIndex >= otherRouters.length) {
        insertIndex = newRouters.length;
        console.log("拖拽到列表最後，插入位置:", insertIndex);
      } else {
        insertIndex = dropIndex;
        console.log("插入到位置:", insertIndex, "(原目標索引:", dropIndex, ")");
      }
      insertIndex = Math.max(0, Math.min(insertIndex, newRouters.length));
      newRouters.splice(insertIndex, 0, draggedItem);
      const renumberedRouters = newRouters.map((router, index) => ({
        ...router,
        router_id: `router${index}`
      }));
      updateRoutersToParent(renumberedRouters);
      setDraggedIndex(null);
      setDragOverIndex(null);
    },
    [draggedIndex, otherRouters, updateRoutersToParent]
  );
  const calculateLabelWidth = (text) => {
    const baseWidth = 24;
    const charWidth = 8;
    return baseWidth + text.length * charWidth;
  };
  const getAllOutputHandles = useCallback$2(() => {
    const handles = otherRouters.map((router) => ({
      id: router.router_id,
      name: router.router_name,
      router_id: router.router_id
      // 保留 router_id 作為參考
    }));
    handles.push({
      id: "default_router",
      name: "Other",
      router_id: "default_router"
    });
    return handles;
  }, [otherRouters]);
  const outputHandles = getAllOutputHandles();
  const HANDLE_SPACING = 40;
  const LABEL_HEIGHT = 32;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rounded-lg shadow-md overflow-hidden w-[400px]", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-[#ecfdf5] p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-6 h-6 flex items-center justify-center mr-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconBase, { type: "router_switch" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Router" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 mb-2 font-bold", children: "Model" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                className: "w-full border border-gray-300 rounded p-2 text-sm appearance-none bg-white pr-8 nodrag",
                value: selectedModelId,
                onChange: (e) => handleModelChange(e.target.value),
                disabled: isLoadingModels,
                onMouseDown: (e) => e.stopPropagation(),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: isLoadingModels ? "載入中..." : "選擇模型" }),
                  modelOptions.map((model) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "option",
                    {
                      value: model.value,
                      children: model.label
                    },
                    model.value
                  ))
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "16",
                height: "16",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
              }
            ) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 font-bold", children: "Context" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm text-gray-700 font-bold", children: "Router" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            ref: scrollContainerRef,
            className: "mb-4 space-y-2 overflow-y-auto nodrag",
            style: {
              maxHeight: "360px",
              // 大約可容納3個router section的高度
              scrollbarWidth: "thin",
              scrollbarColor: "#cbd5e0 #f7fafc"
            },
            onMouseEnter: () => setIsScrollContainerHovered(true),
            onMouseLeave: () => setIsScrollContainerHovered(false),
            onTouchStart: (e) => {
              e.stopPropagation();
              setIsScrollContainerHovered(true);
            },
            onTouchEnd: () => setIsScrollContainerHovered(false),
            children: [
              otherRouters.map((router, index) => {
                const isDraggedItem = draggedIndex === index;
                const isDropTarget = dragOverIndex === index && draggedIndex !== null && draggedIndex !== index;
                return /* @__PURE__ */ jsxRuntimeExports.jsx(React$5.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: `border rounded-lg pt-3 pb-3 pl-1 pr-1 transition-all duration-150 ${isDraggedItem ? "opacity-30 border-gray-300 bg-gray-100" : isDropTarget ? "border-cyan-400 bg-cyan-50" : "border-gray-200 bg-[#fafafa] hover:bg-gray-50"}`,
                    draggable: true,
                    onDragStart: (e) => handleDragStart(e, index),
                    onDragOver: handleDragOver,
                    onDragEnter: (e) => handleDragEnter(e, index),
                    onDragEnd: handleDragEnd,
                    onDrop: (e) => handleDrop(e, index),
                    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          className: `flex items-center justify-center w-6 h-6 text-gray-400 hover:text-gray-600 cursor-grab active:cursor-grabbing nodrag transition-colors duration-200 ${isDraggedItem ? "text-cyan-500" : ""}`,
                          style: {
                            alignSelf: "center",
                            marginTop: "32px"
                          },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "img",
                            {
                              src: dragIcon,
                              width: 12,
                              height: 12,
                              className: "max-w-full max-h-full object-contain pointer-events-none",
                              alt: "drag handle",
                              draggable: false
                            }
                          )
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1 space-y-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-600 mb-1 font-bold", children: "Router Name" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "input",
                            {
                              type: "text",
                              className: "w-full border border-gray-300 rounded px-2 py-1 text-sm nodrag",
                              value: router.router_name,
                              onChange: (e) => updateRouterName(index, e.target.value),
                              placeholder: "Router",
                              onDragStart: (e) => e.preventDefault()
                            }
                          )
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-xs text-gray-600 mb-1 font-bold", children: "AI Condition" }),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            AutoResizeTextarea,
                            {
                              value: router.ai_condition,
                              onChange: (e) => updateAiCondition(index, e.target.value),
                              placeholder: "輸入 AI 條件...",
                              className: "w-full border border-gray-300 rounded px-2 py-1 text-sm nodrag",
                              onDragStart: (e) => e.preventDefault()
                            }
                          )
                        ] })
                      ] }),
                      otherRouters.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          className: "flex items-center justify-center w-6 h-6 text-gray-400 hover:text-red-600 transition-colors duration-200 nodrag",
                          style: {
                            alignSelf: "center",
                            marginTop: "32px"
                          },
                          onClick: () => deleteRouter(index),
                          disabled: otherRouters.length <= 1,
                          onMouseDown: (e) => e.stopPropagation(),
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, {})
                        }
                      )
                    ] })
                  }
                ) }, router.router_id);
              }),
              draggedIndex !== null && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  className: "h-8 w-full border-2 border-dashed border-transparent hover:border-cyan-300 transition-colors nodrag",
                  onDragOver: handleDragOver,
                  onDragEnter: (e) => handleDragEnter(e, otherRouters.length),
                  onDrop: (e) => handleDrop(e, otherRouters.length)
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            className: "w-full bg-cyan-500 hover:bg-cyan-600 text-white rounded-md p-2 font-medium flex items-center justify-center gap-2 nodrag",
            onClick: addRouter,
            onMouseDown: (e) => e.stopPropagation(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Add, {}),
              "Router"
            ]
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Handle$1,
      {
        type: "target",
        position: Position.Left,
        id: "context",
        style: {
          background: "#e5e7eb",
          borderColor: "#D3D3D3",
          width: "12px",
          height: "12px",
          left: "-6px",
          top: "165px",
          border: "1px solid #D3D3D3"
        },
        isConnectable
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute right-0 top-1/2 transform translate-x-full -translate-y-1/2 ml-2 pointer-events-none", children: outputHandles.map((handle, index) => {
      const verticalOffset = (index - (outputHandles.length - 1) / 2) * HANDLE_SPACING;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "flex items-center absolute",
          style: {
            pointerEvents: "none",
            top: `${verticalOffset}px`,
            transform: "translateY(-50%)",
            // 確保標籤垂直置中
            left: 0
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "w-3 h-3 rounded-full",
                style: {
                  background: "#e5e7eb",
                  border: "1px solid #D3D3D3",
                  transform: "translateX(-6px)"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "w-4 h-0.5",
                style: {
                  backgroundColor: "#00ced1",
                  transform: "translateX(-6px)"
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: `inline-flex items-center px-3 py-1 rounded text-xs font-medium text-white whitespace-nowrap select-none ${handle.id === "default_router" ? "bg-gray-500" : "bg-cyan-500"}`,
                style: {
                  transform: "translateX(-6px)",
                  backgroundColor: "#00ced1"
                },
                children: handle.name
              }
            )
          ]
        },
        handle.id
      );
    }) }),
    outputHandles.map((handle, index) => {
      const labelWidth = calculateLabelWidth(handle.name);
      const totalWidth = labelWidth + 8;
      const verticalOffset = (index - (outputHandles.length - 1) / 2) * HANDLE_SPACING;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Handle$1,
        {
          type: "source",
          position: Position.Right,
          id: handle.id,
          style: {
            background: "transparent",
            border: "none",
            width: `${totalWidth}px`,
            height: `${LABEL_HEIGHT}px`,
            // 使用統一的高度
            right: `-${totalWidth + 6}px`,
            top: `calc(50% + ${verticalOffset}px)`,
            // 使用相同的計算邏輯
            transform: "translateY(-50%)",
            cursor: "crosshair",
            zIndex: 10
          },
          isConnectable
        },
        handle.id
      );
    })
  ] });
};
const RouterSwitchNode$1 = memo(RouterSwitchNode);

const enhancedNodeTypes = {
  customInput: withNodeSelection(CustomInputNode$1),
  aiCustomInput: withNodeSelection(AICustomInputNode$1),
  browserExtensionOutput: withNodeSelection(BrowserExtensionOutputNode$1),
  browserExtensionInput: withNodeSelection(BrowserExtensionInputNode$1),
  ifElse: withNodeSelection(IfElseNode$1),
  knowledgeRetrieval: withNodeSelection(KnowledgeRetrievalNode$1),
  end: withNodeSelection(EndNode$1),
  webhook: withNodeSelection(WebhookNode$1),
  httpRequest: withNodeSelection(HTTPRequestNode),
  line_webhook_input: withNodeSelection(LineNode$1),
  timer: withNodeSelection(TimerNode$1),
  line_send_message: withNodeSelection(LineMessageNode$1),
  extract_data: withNodeSelection(ExtractDataNode$1),
  aim_ml: withNodeSelection(QOCAAimNode$1),
  schedule_trigger: withNodeSelection(ScheduleNode),
  webhook_input: withNodeSelection(WebhookInputNode$1),
  webhook_output: withNodeSelection(WebhookOutputNode$1),
  combine_text: withNodeSelection(CombineTextNode$1),
  router_switch: withNodeSelection(RouterSwitchNode$1)
};

await importShared('react');

const BaseButton = ({
  children,
  onClick,
  disabled = false,
  title = "",
  className = "",
  width = "85px",
  buttonStyle = "primary",
  loading = false
}) => {
  const getButtonStyles = () => {
    if (disabled) {
      return "bg-gray-400 text-white cursor-not-allowed";
    }
    switch (buttonStyle) {
      case "loading":
        return "bg-[#00ced1] opacity-70 text-white";
      case "success":
        return "bg-[#00ced1] text-white";
      case "error":
        return "bg-red-500 text-white";
      default:
        return "bg-[#00ced1] text-white hover:bg-[#00b8bb] transition-colors";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative inline-block", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "inline-block bg-white rounded-full shadow-md",
      style: {
        padding: "10px 13px",
        boxShadow: "0px 2px 4px rgba(0, 0, 0, 0.1)"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: `rounded-full text-sm font-medium ${getButtonStyles()} ${className}`,
          onClick,
          disabled: disabled || loading,
          title,
          style: {
            width,
            height: "40px",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          },
          children
        }
      )
    }
  ) });
};

await importShared('react');

const LoadingSpinner = ({ size = 16 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    className: "animate-spin",
    xmlns: "http://www.w3.org/2000/svg",
    width: size,
    height: size,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 12a9 9 0 1 1-6.219-8.56" })
  }
);
const CheckIcon = ({ size = 16 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: size,
    height: size,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M20 6L9 17l-5-5" })
  }
);
const ErrorIcon = ({ size = 16 }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: size,
    height: size,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "circle",
        {
          cx: "12",
          cy: "12",
          r: "10"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: "12",
          y1: "8",
          x2: "12",
          y2: "12"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "line",
        {
          x1: "12",
          y1: "16",
          x2: "12.01",
          y2: "16"
        }
      )
    ]
  }
);

const {useState: useState$5} = await importShared('react');


/**
 * 按鈕狀態管理 Hook
 */
const useButtonState = (resetDelay = 2000) => {
  const [state, setState] = useState$5('');
  const [errorMessage, setErrorMessage] = useState$5('');

  const setLoading = () => {
    setState('loading');
    setErrorMessage('');
  };

  const setSuccess = () => {
    setState('success');
    setTimeout(() => setState(''), resetDelay);
  };

  const setError = (message = '') => {
    setState('error');
    setErrorMessage(message);
    setTimeout(() => {
      setState('');
      setErrorMessage('');
    }, resetDelay);
  };

  const reset = () => {
    setState('');
    setErrorMessage('');
  };

  return {
    state,
    errorMessage,
    setLoading,
    setSuccess,
    setError,
    reset,
    isLoading: state === 'loading',
    isSuccess: state === 'success',
    isError: state === 'error'
  };
};

await importShared('react');
const SaveButton = ({
  onSave,
  className = "",
  title = "",
  flowId = "",
  disabled = false,
  isLocked = false
  // 新增 isLocked 參數
}) => {
  const { state, errorMessage, setLoading, setSuccess, setError } = useButtonState();
  const isTitleValid = title && title.trim().length > 0;
  const isCreateMode = !flowId || flowId === "new";
  const triggerSave = async () => {
    if (isLocked) {
      setError("工作流已鎖定，無法保存");
      return;
    }
    if (!isTitleValid) {
      setError("請先輸入標題");
      return;
    }
    if (state === "loading") return;
    setLoading();
    try {
      await onSave();
      setSuccess();
    } catch (error) {
      console.error("儲存按鈕：儲存作業期間發生錯誤：", error);
      setError("儲存失敗");
    }
  };
  const getButtonStyle = () => {
    if (disabled || isLocked || !isTitleValid && !state) return "disabled";
    if (state === "loading") return "loading";
    if (state === "success") return "success";
    if (state === "error") return "error";
    return "primary";
  };
  const getButtonTitle = () => {
    if (isLocked) return "工作流已鎖定，無法保存";
    if (!isTitleValid && !state) return "請先輸入標題";
    if (disabled) return "目前無法儲存";
    return isCreateMode ? "建立新流程" : "儲存現有流程";
  };
  const getButtonContent = () => {
    if (state === "loading") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: isCreateMode ? "建立中..." : "儲存中..." })
      ] });
    }
    if (state === "success") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: isCreateMode ? "已建立" : "已儲存" })
      ] });
    }
    if (state === "error") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "錯誤" })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: isCreateMode ? "Create" : "Save" });
  };
  const buttonWidth = isCreateMode ? "92px" : "85px";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BaseButton,
      {
        onClick: triggerSave,
        disabled: disabled || isLocked || !isTitleValid && !state,
        title: getButtonTitle(),
        className,
        width: buttonWidth,
        buttonStyle: getButtonStyle(),
        children: getButtonContent()
      }
    ),
    errorMessage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-1/2 transform -translate-x-1/2 mt-2 bg-red-100 text-red-700 px-2 py-1 rounded text-xs whitespace-nowrap", children: errorMessage })
  ] });
};

// src/services/FileIOService.js

/**
 * 用於處理本地檔案作業（儲存和載入）的服務
 */
class FileIOService {
  /**
   * 通過建立下載來將資料儲存到本地檔案
   *
   * @param {Object} data - 要儲存的資料
   * @param {string} filename - 建議的檔案名稱（預設：flow.json）
   * @returns {Promise} - 當檔案準備下載時解析
   */
  static saveToFile(data, filename = 'flow.json') {
    return new Promise((resolve, reject) => {
      try {
        // 將資料轉換為 JSON 字串
        const jsonString = JSON.stringify(data, null, 2);

        // 建立含有資料的 Blob
        const blob = new Blob([jsonString], { type: 'application/json' });

        // 為 Blob 建立 URL
        const url = URL.createObjectURL(blob);

        // 建立臨時錨點元素
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;

        // 附加到文件，點擊開始下載，然後移除
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // 清理 URL 物件
        setTimeout(() => {
          URL.revokeObjectURL(url);
        }, 100);

        resolve({ success: true, filename });
      } catch (error) {
        console.error('儲存檔案時發生錯誤：', error);
        reject({
          success: false,
          message: '無法儲存檔案',
          error
        });
      }
    });
  }

  /**
   * 開啟檔案對話框並讀取本地檔案
   *
   * @param {Object} options - 檔案讀取選項
   * @param {string} options.accept - 要接受的 MIME 類型（預設：application/json）
   * @returns {Promise} - 解析檔案內容
   */
  static readFromFile(options = {}) {
    return new Promise((resolve, reject) => {
      try {
        // 建立檔案輸入元素
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = options.accept || 'application/json';
        fileInput.style.display = 'none';

        // 將輸入元素加入文件
        document.body.appendChild(fileInput);

        // 當選取檔案時
        fileInput.onchange = (event) => {
          const file = event.target.files[0];

          if (!file) {
            document.body.removeChild(fileInput);
            reject({ success: false, message: '未選取檔案' });
            return;
          }

          // 建立 FileReader 讀取檔案
          const reader = new FileReader();

          // 定義檔案載入時發生的事
          reader.onload = (e) => {
            try {
              // 嘗試將檔案內容解析為 JSON
              const fileContent = e.target.result;
              const parsedData = JSON.parse(fileContent);

              // 清理檔案輸入
              document.body.removeChild(fileInput);

              // 解析已解析的資料
              resolve({
                success: true,
                filename: file.name,
                data: parsedData
              });
            } catch (parseError) {
              document.body.removeChild(fileInput);
              reject({
                success: false,
                message: '無效的 JSON 檔案',
                error: parseError
              });
            }
          };

          // 定義發生錯誤時的處理
          reader.onerror = (error) => {
            document.body.removeChild(fileInput);
            reject({
              success: false,
              message: '讀取檔案時發生錯誤',
              error
            });
          };

          // 以文字方式讀取檔案
          reader.readAsText(file);
        };

        // 觸發檔案選取對話框
        fileInput.click();
      } catch (error) {
        console.error('開啟檔案對話框時發生錯誤：', error);
        reject({
          success: false,
          message: '無法開啟檔案對話框',
          error
        });
      }
    });
  }
}

/**
 * 增強版 IFrameBridgeService - 處理從母網站接收標題修改及下載JSON功能
 */
class IFrameBridgeService {
  constructor() {
    // 標記是否已初始化，防止重複初始化
    this.initialized = false;

    // 追蹤已註冊的事件處理函數
    this.eventHandlers = {
      titleChange: [],
      downloadRequest: [],
      loadWorkflow: [], // 新增載入工作流事件
      ready: [],
      tokenReceived: [],
      saveWorkflow: [],
      connectionEstablished: []
    };

    // 是否在 iframe 內部
    this.isInIframe = false;

    // 訊息處理相關
    this.messageQueue = [];
    this.isProcessingMessages = false;
    this.recentMessages = new Map();
    this.MESSAGE_CACHE_TIME = 2000; // 訊息緩存時間

    // 連接狀態
    this.connectionEstablished = false;
    this.parentOrigin = '*'; // 父頁面來源

    // 初始化
    this.init();
  }

  /**
   * 初始化通訊橋接器
   */
  init() {
    // 防止重複初始化
    if (this.initialized) return;
    this.initialized = true;

    try {
      this.isInIframe = window.self !== window.top;
    } catch {
      // 如果訪問window.top出現安全錯誤，則我們肯定在iframe中
      this.isInIframe = true;
    }

    if (this.isInIframe) {
      // 監聽來自父頁面的消息
      window.addEventListener(
        'message',
        this.handleIncomingMessage.bind(this),
        false
      );

      // 延遲發送準備好消息，確保事件監聽器已註冊
      setTimeout(() => {
        this.sendReadyMessage();
      }, 300); // 增加延遲時間
    } else {
      console.log('IFrameBridgeService 已初始化 - 在獨立模式中運行');
    }
  }

  /**
   * 發送準備好消息
   */
  sendReadyMessage() {
    this.sendToParent({
      type: 'READY',
      timestamp: new Date().toISOString(),
      capabilities: {
        messageHandling: true,
        workflowLoading: true,
        dataExport: true
      }
    });

    // 延遲觸發內部準備好事件，確保組件有時間註冊事件處理器
    setTimeout(() => {
      this.triggerEvent('ready', {
        timestamp: new Date().toISOString()
      });
    }, 100);
  }

  /**
   * 檢查訊息是否重複
   */
  isDuplicateMessage(message) {
    if (!message || !message.type) return false;

    const messageKey = `${message.type}-${message.timestamp || Date.now()}`;
    const now = Date.now();

    if (this.recentMessages.has(messageKey)) {
      const lastTime = this.recentMessages.get(messageKey);
      if (now - lastTime < this.MESSAGE_CACHE_TIME) {
        return true;
      }
    }

    this.recentMessages.set(messageKey, now);

    // 清理過期訊息
    this.cleanupRecentMessages(now);

    return false;
  }

  /**
   * 清理過期訊息記錄
   */
  cleanupRecentMessages(now) {
    this.recentMessages.forEach((timestamp, key) => {
      if (now - timestamp > this.MESSAGE_CACHE_TIME * 2) {
        this.recentMessages.delete(key);
      }
    });
  }

  /**
   * 將訊息加入處理佇列
   */
  queueMessage(message) {
    this.messageQueue.push({
      ...message,
      receivedAt: Date.now()
    });

    if (!this.isProcessingMessages) {
      this.processMessageQueue();
    }
  }

  /**
   * 處理訊息佇列
   */
  async processMessageQueue() {
    this.isProcessingMessages = true;

    while (this.messageQueue.length > 0) {
      const message = this.messageQueue.shift();

      try {
        await this.processMessage(message);

        // 短暫延遲，避免過於頻繁的處理
        await new Promise((resolve) => setTimeout(resolve, 50));
      } catch (error) {
        console.error('處理訊息時發生錯誤:', error);
      }
    }

    this.isProcessingMessages = false;
  }

  /**
   * 處理單個訊息
   */
  async processMessage(message) {
    console.log(`處理訊息: ${message.type}`, message);

    // 發送確認訊息
    this.sendAcknowledgment(message);

    // 根據訊息類型處理
    switch (message.type) {
      case 'PING':
        this.handlePingMessage(message);
        break;

      case 'SET_FLOW_ID':
        this.handleSetFlowId(message);
        break;

      case 'SET_FLOW_ID_AND_TOKEN':
        this.handleSetFlowIdAndToken(message);
        break;

      case 'SET_TITLE':
        this.handleSetTitle(message);
        break;

      case 'REQUEST_DATA_FOR_DOWNLOAD':
        this.handleDownloadRequest(message);
        break;

      case 'SAVE_WORKFLOW':
        this.handleSaveWorkflow(message);
        break;

      case 'READY_CHECK':
        this.handleReadyCheck(message);
        break;

      default:
        console.log(`收到未處理的訊息類型: ${message.type}`);
        break;
    }
  }

  /**
   * 發送確認訊息
   */
  sendAcknowledgment(originalMessage) {
    this.sendToParent({
      type: 'MESSAGE_ACKNOWLEDGED',
      originalType: originalMessage.type,
      originalTimestamp: originalMessage.timestamp,
      timestamp: new Date().toISOString()
    });
  }

  /**
   * 處理來自父頁面的消息
   */
  handleIncomingMessage(event) {
    try {
      const message = event.data;

      // 檢查消息結構
      if (!message || !message.type) {
        return;
      }

      // 記錄父頁面來源
      if (event.origin !== 'null') {
        this.parentOrigin = event.origin;
      }

      // 檢查是否是重複訊息
      if (this.isDuplicateMessage(message)) {
        console.log('偵測到重複訊息，跳過處理:', message.type);
        return;
      }

      // 將訊息加入處理佇列
      this.queueMessage(message);
    } catch (error) {
      console.error('處理來自父頁面的訊息時發生錯誤:', error);
    }
  }

  /**
   * 處理 PING 訊息
   */
  handlePingMessage(message) {
    // 立即回應PONG
    this.sendToParent({
      type: 'PONG',
      timestamp: new Date().toISOString(),
      originalPingTime: message.timestamp
    });

    // 同時重新發送READY消息以確保連接建立
    this.sendToParent({
      type: 'READY',
      timestamp: new Date().toISOString(),
      status: 'responding-to-ping'
    });

    // 標記連接已建立
    if (!this.connectionEstablished) {
      this.connectionEstablished = true;
      this.triggerEvent('connectionEstablished', {
        timestamp: new Date().toISOString()
      });
    }
  }

  /**
   * 處理就緒檢查
   */
  handleReadyCheck(message) {
    console.log('收到 READY_CHECK，發送狀態回應');

    this.sendToParent({
      type: 'READY',
      timestamp: new Date().toISOString(),
      status: 'ready-check-response',
      originalMessage: message.timestamp
    });
  }

  /**
   * 處理設置 Flow ID
   */
  handleSetFlowId(message) {
    if (message.flowId) {
      const flowId = message.flowId;

      // 延遲觸發，確保所有必要資料都已設置
      setTimeout(() => {
        this.triggerEvent('loadWorkflow', flowId);
      }, 200);
    }
  }

  /**
   * 處理設置 Flow ID 和 Token
   */
  handleSetFlowIdAndToken(message) {
    if (message.flowId && message.token && message.selectedWorkspaceId) {
      const flowId = message.flowId;
      const selectedWorkspaceId = message.selectedWorkspaceId;

      // 先觸發 token 接收事件
      this.triggerEvent('tokenReceived', {
        token: message.token,
        storage: message.storage || 'local',
        selectedWorkspaceId
      });

      // 延遲觸發 loadWorkflow，確保 token 已設置
      setTimeout(() => {
        this.triggerEvent('loadWorkflow', flowId);
      }, 500);
    } else {
      console.warn('SET_FLOW_ID_AND_TOKEN 訊息缺少必要資料:', {
        hasFlowId: !!message.flowId,
        hasToken: !!message.token,
        hasWorkspaceId: !!message.selectedWorkspaceId
      });
    }
  }

  /**
   * 處理設置標題
   */
  handleSetTitle(message) {
    if (message.title) {
      // 觸發標題變更事件
      this.triggerEvent('titleChange', message.title);
    } else {
      console.warn('收到 SET_TITLE 消息，但標題為空');
    }
  }

  /**
   * 處理下載請求
   */
  handleDownloadRequest(message) {
    // 觸發下載請求事件
    this.triggerEvent('downloadRequest', message.options || {});
  }

  /**
   * 處理保存工作流
   */
  handleSaveWorkflow() {
    this.triggerEvent('saveWorkflow');
  }

  /**
   * 向父頁面發送消息
   */
  sendToParent(message) {
    if (!this.isInIframe) {
      console.warn('無法發送消息：未在 iframe 中運行');
      return false;
    }

    try {
      // 確保消息有時間戳
      message.timestamp = message.timestamp || new Date().toISOString();
      message.source = 'iframe-app';

      // 使用記錄的父頁面來源，或通配符
      const targetOrigin = this.parentOrigin || '*';

      window.parent.postMessage(message, targetOrigin);

      return true;
    } catch (error) {
      console.error('向父頁面發送消息時出錯:', error);
      return false;
    }
  }

  /**
   * 註冊事件處理程序
   */
  on(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      console.warn(`未知的事件類型: ${eventType}`);
      return false;
    }

    // 檢查是否已註冊相同的回調函數
    const isAlreadyRegistered = this.eventHandlers[eventType].some(
      (handler) => handler === callback
    );

    if (isAlreadyRegistered) {
      return false;
    }

    this.eventHandlers[eventType].push(callback);

    return true;
  }

  /**
   * 觸發特定事件的所有處理程序
   */
  triggerEvent(eventType, data) {
    if (!this.eventHandlers[eventType]) {
      console.warn(`未知的事件類型: ${eventType}`);
      return;
    }

    const handlers = this.eventHandlers[eventType];
    if (handlers.length === 0) {
      // 對於 ready 事件，如果沒有處理器，延遲重試
      if (eventType === 'ready') {
        setTimeout(() => {
          const retryHandlers = this.eventHandlers[eventType];
          if (retryHandlers.length > 0) {
            this.triggerEventWithHandlers(eventType, data, retryHandlers);
          } else {
            console.log(`${eventType} 事件延遲重試後仍無處理程序，跳過`);
          }
        }, 500);
      } else {
        console.warn(`觸發 ${eventType} 事件，但沒有註冊的處理程序`);
      }
      return;
    }

    this.triggerEventWithHandlers(eventType, data, handlers);
  }

  /**
   * 執行事件處理器
   */
  triggerEventWithHandlers(eventType, data, handlers) {
    handlers.forEach((handler, index) => {
      try {
        handler(data);
      } catch (error) {
        console.error(
          `執行 ${eventType} 事件處理程序 #${index + 1} 時出錯:`,
          error
        );
      }
    });
  }

  /**
   * 取消註冊事件處理程序
   */
  off(eventType, callback) {
    if (!this.eventHandlers[eventType]) {
      console.warn(`未知的事件類型: ${eventType}`);
      return false;
    }

    const initialLength = this.eventHandlers[eventType].length;
    this.eventHandlers[eventType] = this.eventHandlers[eventType].filter(
      (handler) => handler !== callback
    );

    const removed = initialLength !== this.eventHandlers[eventType].length;
    if (removed) {
      console.log(
        `已移除 ${eventType} 事件處理程序，當前處理程序數量: ${this.eventHandlers[eventType].length}`
      );
    } else {
      console.warn(`嘗試移除未找到的 ${eventType} 事件處理程序`);
    }

    return removed;
  }

  /**
   * 向父頁面發送JSON數據以進行下載
   */
  requestDownload(data, filename) {
    if (!this.isInIframe) {
      console.warn('無法請求下載：未在 iframe 中運行');
      return false;
    }

    try {
      // 創建可序列化的數據副本
      const serializableData = JSON.parse(JSON.stringify(data));

      this.sendToParent({
        type: 'DOWNLOAD_JSON',
        data: serializableData,
        filename: filename,
        timestamp: new Date().toISOString()
      });

      return true;
    } catch (error) {
      console.error('發送下載請求時出錯:', error);
      return false;
    }
  }

  /**
   * 獲取連接狀態
   */
  getConnectionStatus() {
    return this.connectionEstablished;
  }

  /**
   * 清理和銷毀服務
   */
  destroy() {
    console.log('正在銷毀 IFrameBridgeService...');

    // 移除事件監聽器
    window.removeEventListener('message', this.handleIncomingMessage);

    // 清理所有事件處理程序
    Object.keys(this.eventHandlers).forEach((eventType) => {
      this.eventHandlers[eventType] = [];
    });

    // 清理訊息佇列和緩存
    this.messageQueue = [];
    this.recentMessages.clear();

    // 重置狀態
    this.initialized = false;
    this.connectionEstablished = false;
    this.isProcessingMessages = false;

    console.log('IFrameBridgeService 已成功銷毀');
  }
}

// 創建單例實例
const iframeBridge = new IFrameBridgeService();

await importShared('react');
function CustomEdge({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  style = {},
  markerEnd,
  selected,
  label
}) {
  const [edgePath] = getBezierPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition
  });
  const getEdgeStyle = () => {
    const baseStyle = {
      stroke: selected ? "#4299e1" : "#9ca3af",
      // Grey color when not selected
      strokeWidth: selected ? 3 : 2,
      strokeDasharray: "5,5",
      // Dashed line
      transition: "all 0.3s ease"
    };
    return Object.entries(style).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, baseStyle);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BaseEdge,
      {
        id,
        path: edgePath,
        style: getEdgeStyle(),
        markerEnd
      }
    ),
    label && /* @__PURE__ */ jsxRuntimeExports.jsx(EdgeLabelRenderer, {})
  ] });
}

const React$4 = await importShared('react');
const {useState: useState$4} = React$4;
const LoadWorkflowButton = ({ onLoad }) => {
  const [workflowId, setWorkflowId] = useState$4(
    "cb419ef0-ac18-4f73-9178-499b31136e48"
  );
  const [showInput, setShowInput] = useState$4(false);
  const { state, setLoading, setSuccess, setError } = useButtonState();
  const handleClick = () => {
    setShowInput(true);
  };
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!workflowId || typeof onLoad !== "function") return;
    try {
      setLoading();
      await onLoad(workflowId);
      setSuccess();
      setWorkflowId("");
      setShowInput(false);
    } catch (error) {
      console.error("載入工作流失敗:", error);
      setError();
    }
  };
  const handleCancel = () => {
    setWorkflowId("");
    setShowInput(false);
  };
  const getButtonStyle = () => {
    if (state === "loading") return "loading";
    if (state === "success") return "success";
    if (state === "error") return "error";
    return "primary";
  };
  const getButtonContent = () => {
    if (state === "loading") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "載入中..." })
      ] });
    }
    if (state === "success") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "已載入" })
      ] });
    }
    if (state === "error") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center space-x-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "錯誤" })
      ] });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "測試用" });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BaseButton,
      {
        onClick: handleClick,
        disabled: state === "loading",
        title: "載入工作流",
        buttonStyle: getButtonStyle(),
        children: getButtonContent()
      }
    ),
    showInput && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-full left-0 mt-2 p-3 bg-white rounded-md shadow-lg border border-gray-200 z-20 w-64", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "form",
      {
        onSubmit: handleSubmit,
        className: "flex flex-col",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "mb-1 text-sm text-gray-600", children: "請輸入工作流 ID:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: workflowId,
              onChange: (e) => setWorkflowId(e.target.value),
              className: "border border-gray-300 rounded-md px-3 py-2 mb-3 focus:outline-none focus:ring-2 focus:ring-[#00ced1] focus:border-transparent",
              autoFocus: true,
              placeholder: "例如: 5e9867a0-58b4-4c16-acbb-e194df6efa46"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: handleCancel,
                className: "px-3 py-1.5 text-sm text-gray-600 hover:text-gray-800 rounded-md border border-gray-300 hover:bg-gray-50",
                children: "取消"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "submit",
                className: "px-3 py-1.5 text-sm bg-[#00ced1] text-white rounded-md hover:bg-[#00b5b8]",
                children: "載入"
              }
            )
          ] })
        ]
      }
    ) })
  ] });
};

const React$3 = await importShared('react');
const {useEffect: useEffect$2,useState: useState$3} = React$3;

class NotificationService {
  static listeners = [];
  static notify(message, type = "info", duration = 3e3) {
    this.listeners.forEach((listener) => listener(message, type, duration));
  }
  static subscribe(listener) {
    this.listeners.push(listener);
    return () => {
      this.listeners = this.listeners.filter((l) => l !== listener);
    };
  }
}
if (typeof window !== "undefined") {
  window.notify = (options) => {
    if (typeof options === "string") {
      NotificationService.notify(options);
    } else {
      const { message, type, duration } = options;
      NotificationService.notify(message, type, duration);
    }
  };
}
const Notification = () => {
  const [notifications, setNotifications] = useState$3([]);
  useEffect$2(() => {
    const unsubscribe = NotificationService.subscribe(
      (message, type, duration) => {
        const id = Date.now();
        setNotifications((prev) => [...prev, { id, message, type, duration }]);
        setTimeout(() => {
          setNotifications(
            (prev) => prev.filter((notification) => notification.id !== id)
          );
        }, duration);
      }
    );
    return () => unsubscribe();
  }, []);
  if (notifications.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "", children: notifications.map((notification) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: `absolute top-16 left-1/2 rounded-lg transform -translate-x-1/2 px-4 py-2 z-20 text-sm ${notification.type === "error" ? "bg-red-100 text-red-700 border border-red-200" : notification.type === "success" ? "bg-green-100 text-green-700 border border-green-200" : "bg-blue-100 text-blue-700 border border-blue-200"}`,
      children: notification.message
    },
    notification.id
  )) });
};

const React$2 = await importShared('react');
const {useState: useState$2,useCallback: useCallback$1} = React$2;

const SaveFlowDialog = ({
  isOpen,
  onClose,
  onSave,
  title = "請先儲存您的 Flow"
}) => {
  const [flowName, setFlowName] = useState$2("");
  const [isSaving, setIsSaving] = useState$2(false);
  const handleSave = useCallback$1(async () => {
    if (!flowName.trim()) {
      if (typeof window !== "undefined" && window.notify) {
        window.notify({
          message: "請輸入流程名稱",
          type: "error",
          duration: 3e3
        });
      }
      return;
    }
    setIsSaving(true);
    try {
      await onSave(flowName);
      setFlowName("");
    } catch (error) {
      console.error("保存流程失敗:", error);
    } finally {
      setIsSaving(false);
    }
  }, [flowName, onSave]);
  const handleClose = useCallback$1(() => {
    if (!isSaving) {
      setFlowName("");
      onClose();
    }
  }, [isSaving, onClose]);
  const handleKeyPress = useCallback$1(
    (e) => {
      if (e.key === "Enter" && !isSaving) {
        handleSave();
      }
    },
    [handleSave, isSaving]
  );
  if (!isOpen) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "bg-white rounded-lg p-6 w-[500px] max-w-[90vw] shadow-xl",
      onClick: (e) => e.stopPropagation(),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium mb-4 text-gray-900", children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600 mb-4", children: "為了建立專屬 Webhook URL，請先儲存您的 Flow。" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mb-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium text-gray-700 mb-2", children: "Flow Name (流程名稱)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "text",
              value: flowName,
              onChange: (e) => setFlowName(e.target.value),
              onKeyPress: handleKeyPress,
              className: "w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:border-cyan-500 disabled:bg-gray-100 disabled:cursor-not-allowed",
              placeholder: "未命名的流程",
              disabled: isSaving,
              autoFocus: true
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleClose,
              disabled: isSaving,
              className: "px-4 py-2 text-gray-600 hover:text-gray-800 hover:bg-gray-100 border rounded-md disabled:opacity-50 disabled:cursor-not-allowed",
              children: "取消"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: handleSave,
              disabled: isSaving || !flowName.trim(),
              className: "px-4 py-2 bg-cyan-500 text-white rounded-md hover:bg-cyan-600 disabled:opacity-50 disabled:cursor-not-allowed flex items-center",
              children: [
                isSaving && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "svg",
                  {
                    className: "animate-spin -ml-1 mr-2 h-4 w-4 text-white",
                    fill: "none",
                    viewBox: "0 0 24 24",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "circle",
                        {
                          className: "opacity-25",
                          cx: "12",
                          cy: "12",
                          r: "10",
                          stroke: "currentColor",
                          strokeWidth: "4"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "path",
                        {
                          className: "opacity-75",
                          fill: "currentColor",
                          d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                        }
                      )
                    ]
                  }
                ),
                isSaving ? "保存中..." : "建立"
              ]
            }
          )
        ] })
      ]
    }
  ) });
};

/**
 * 通知系統 Hook
 */
const useNotification = () => {
  const notify = (message, type = 'info', duration = 2000) => {
    if (typeof window !== 'undefined' && window.notify) {
      window.notify({ message, type, duration });
    }
  };

  return { notify };
};

const React$1 = await importShared('react');
const {useState: useState$1,useRef: useRef$1,useEffect: useEffect$1} = React$1;
const AutoLayoutButton = ({ onLayout, disabled = false, isLocked = false }) => {
  const [layoutDirection, setLayoutDirection] = useState$1("LR");
  const [showDirectionMenu, setShowDirectionMenu] = useState$1(false);
  const { state, setLoading, setSuccess, setError } = useButtonState();
  const { notify } = useNotification();
  const dropdownRef = useRef$1(null);
  const directions = [
    {
      value: "TB",
      label: "上到下",
      icon: "↓",
      description: "從頂部向底部排列"
    },
    {
      value: "LR",
      label: "左到右",
      icon: "→",
      description: "從左側向右側排列"
    },
    {
      value: "BT",
      label: "下到上",
      icon: "↑",
      description: "從底部向頂部排列"
    },
    {
      value: "RL",
      label: "右到左",
      icon: "←",
      description: "從右側向左側排列"
    }
  ];
  useEffect$1(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setShowDirectionMenu(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  const executeLayout = async (direction) => {
    if (disabled || !onLayout || isLocked) return;
    if (isLocked) {
      notify("工作流已鎖定，無法執行自動排版", "warning", 3e3);
      return;
    }
    try {
      setLoading();
      console.log(`執行自動排版，方向: ${direction}`);
      await onLayout(direction);
      setSuccess();
      notify(
        `自動排版完成 (${directions.find((d) => d.value === direction)?.label})`,
        "success"
      );
    } catch (error) {
      console.error("自動排版失敗:", error);
      setError();
      notify("自動排版失敗，請檢查節點連接", "error", 3e3);
    }
  };
  const handleLayout = () => {
    if (isLocked) {
      notify("工作流已鎖定，無法執行自動排版", "warning", 3e3);
      return;
    }
    executeLayout(layoutDirection);
  };
  const handleDirectionChange = async (direction) => {
    if (isLocked) {
      notify("工作流已鎖定，無法執行自動排版", "warning", 3e3);
      return;
    }
    setLayoutDirection(direction);
    setShowDirectionMenu(false);
    if (onLayout && !disabled && state !== "loading") {
      await executeLayout(direction);
    }
  };
  const toggleDropdown = (e) => {
    e.stopPropagation();
    if (isLocked) {
      notify("工作流已鎖定，無法更改排版設定", "warning", 3e3);
      return;
    }
    setShowDirectionMenu(!showDirectionMenu);
  };
  const currentDirection = directions.find((d) => d.value === layoutDirection);
  const getButtonStyle = () => {
    if (disabled || state === "loading" || isLocked) return "disabled";
    return "primary";
  };
  const getButtonTitle = () => {
    if (isLocked) return "工作流已鎖定，無法執行自動排版";
    return `自動排版 (${currentDirection?.label}) - ${currentDirection?.description}`;
  };
  const getButtonContent = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center w-full", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: "16px", marginRight: "6px" }, children: currentDirection?.icon }),
        state === "loading" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSpinner, { size: 14 }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "排版中" })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "自動排版" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "flex items-center justify-center ml-2 pl-2 border-l border-white/30",
          onClick: toggleDropdown,
          style: {
            cursor: disabled || state === "loading" || isLocked ? "not-allowed" : "pointer",
            opacity: disabled || state === "loading" || isLocked ? 0.5 : 1
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "12",
              height: "12",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              style: {
                transform: showDirectionMenu ? "rotate(180deg)" : "rotate(0deg)",
                transition: "transform 0.2s ease"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "6 9 12 15 18 9" })
            }
          )
        }
      )
    ] });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: "relative",
      ref: dropdownRef,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          BaseButton,
          {
            onClick: handleLayout,
            disabled: disabled || isLocked,
            title: getButtonTitle(),
            width: "120px",
            buttonStyle: getButtonStyle(),
            children: getButtonContent()
          }
        ),
        showDirectionMenu && !disabled && state !== "loading" && !isLocked && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-full left-0 mt-2 p-2 bg-white rounded-md shadow-lg border border-gray-200 z-30 min-w-[200px]", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 mb-2 px-2 font-medium", children: "選擇排版方向並自動執行:" }),
          directions.map((direction) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => handleDirectionChange(direction.value),
              className: `w-full text-left px-3 py-2 text-sm rounded-md transition-colors flex items-center space-x-3 hover:bg-gray-50 ${layoutDirection === direction.value ? "bg-blue-100 text-blue-700 font-medium" : "text-gray-700"}`,
              title: direction.description,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-block w-6 text-center text-base", children: direction.icon }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium", children: direction.label }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: direction.description })
                ] }),
                layoutDirection === direction.value && /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { className: "ml-auto" })
              ]
            },
            direction.value
          )),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mt-2 pt-2 border-t border-gray-200", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500 px-2", children: "💡 自動排版會根據節點連接關係智能調整位置" }) })
        ] })
      ]
    }
  );
};

const React = await importShared('react');
const {useState,useEffect,useCallback,useRef,useMemo,forwardRef,useImperativeHandle} = React;
const ReactFlowWithControls = forwardRef(
  ({
    nodes,
    edges,
    onNodesChange,
    onEdgesChange,
    onConnect,
    onNodesDelete,
    nodeTypes,
    edgeTypes,
    defaultViewport,
    onSelectionChange,
    onInit,
    onDrop,
    onDragOver,
    sidebarVisible,
    isLocked = false
  }, ref) => {
    const reactFlowInstance = useReactFlow();
    const fitViewToNodes = useCallback(
      (padding = 0.1, maxZoom = 1.85, duration = 800) => {
        if (!reactFlowInstance) {
          console.warn("ReactFlow 實例尚未初始化，無法自動縮放畫布");
          return;
        }
        console.log("自動縮放畫布以顯示所有節點...");
        try {
          reactFlowInstance.fitView({
            padding,
            // 邊緣留白，值越大顯示的節點佔比越小
            maxZoom,
            // 限制最大縮放，防止縮放過大
            duration,
            // 動畫持續時間（毫秒）
            includeHiddenNodes: false
            // 不包含隱藏節點
          });
          console.log("畫布縮放完成");
        } catch (error) {
          console.error("自動縮放畫布時發生錯誤：", error);
        }
      },
      [reactFlowInstance]
    );
    useImperativeHandle(ref, () => ({
      fitViewToNodes
    }));
    const controlsStyle = useMemo(() => {
      return {
        left: sidebarVisible ? "17rem" : "10px",
        // 如果sidebar顯示，將controls向右移動
        transition: "left 0.3s ease"
        // 添加過渡效果使移動更平滑
      };
    }, [sidebarVisible]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      ReactFlow,
      {
        nodes,
        edges,
        onNodesChange: isLocked ? () => {
        } : onNodesChange,
        onEdgesChange: isLocked ? () => {
        } : onEdgesChange,
        onConnect: isLocked ? () => {
        } : onConnect,
        onNodesDelete: isLocked ? () => {
        } : onNodesDelete,
        nodeTypes,
        edgeTypes,
        defaultViewport,
        onSelectionChange,
        deleteKeyCode: isLocked ? [] : ["Backspace", "Delete"],
        onInit,
        onDrop: isLocked ? () => {
        } : onDrop,
        onDragOver: isLocked ? () => {
        } : onDragOver,
        nodesDraggable: !isLocked,
        nodesConnectable: !isLocked,
        elementsSelectable: !isLocked,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MiniMap$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Controls$1, { style: controlsStyle }),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(Background$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Panel, { position: "bottom-right", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "bg-white p-2 rounded-md shadow-md border border-gray-300 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-gray-300",
              onClick: () => fitViewToNodes(0.1),
              title: "縮放視圖以顯示所有節點",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "svg",
                {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "20",
                  height: "20",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  stroke: "currentColor",
                  strokeWidth: "2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15 3h6v6" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9 21H3v-6" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 3l-7 7" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M3 21l7-7" })
                  ]
                }
              )
            }
          ) })
        ]
      }
    ) });
  }
);
const FlowEditor = forwardRef(({ initialTitle, onTitleChange }, ref) => {
  const reactFlowWrapper = useRef(null);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  const reactFlowControlsRef = useRef(null);
  const isInitialized = useRef(false);
  const [isSaving, setIsSaving] = useState(false);
  const [sidebarVisible, setSidebarVisible] = useState(true);
  const [isLocked, setIsLocked] = useState(false);
  const nodeTypes = useMemo(() => enhancedNodeTypes, []);
  const edgeTypes = useMemo(() => ({ "custom-edge": CustomEdge }), []);
  const defaultViewport = useMemo(() => ({ x: 0, y: 0, zoom: 1.3 }), []);
  const {
    nodes,
    edges,
    onNodesChange,
    onEdgesChange,
    onConnect,
    onNodesDelete,
    handleAddNode,
    handleAddInputNode,
    handleAddAINode,
    handleAddBrowserExtensionOutput,
    handleAddBrowserExtensionInput,
    updateNodeFunctions,
    handleAddIfElseNode,
    handleAddKnowledgeRetrievalNode,
    handleAddEndNode,
    handleAddWebhookNode,
    handleAddHttpRequestNode,
    handleAddEventNode,
    handleAddTimerNode,
    handleAddLineNode,
    handleAddLineMessageNode,
    handleAddExtractDataNode,
    handleAddQOCAAimNode,
    handleAddScheduleTriggerNode,
    handleAddWebhookInputNode,
    handleAddWebhookOutputNode,
    handleAddCombineTextNode,
    handleNodeSelection,
    handleAddRouterSwitchNode,
    setNodes: setFlowNodes,
    setEdges: setFlowEdges,
    getNodeCallbacks,
    handleAutoLayout,
    startWorkflowLoading,
    finishWorkflowLoading
  } = useFlowNodes();
  const [flowMetadata, setFlowMetadata] = useState({
    id: null,
    title: initialTitle || "",
    lastSaved: null,
    version: 1
  });
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [saveDialogCallback, setSaveDialogCallback] = useState(null);
  const isInIframe = useMemo(() => {
    try {
      return window.self !== window.top;
    } catch {
      return true;
    }
  }, []);
  const toggleSidebar = useCallback(() => {
    setSidebarVisible((prev) => !prev);
  }, []);
  const handleLoadWorkflow = useCallback(async (flowId) => {
    try {
      const success = await loadWorkflowImpl(flowId);
      return success;
    } catch (error) {
      console.error("無法載入工作流:", error);
      window.notify({
        message: "載入工作流失敗",
        type: "error",
        duration: 2e3
      });
      return false;
    }
  }, []);
  const loadWorkflowImpl = async (flowId) => {
    if (flowId !== "new") {
      try {
        if (startWorkflowLoading) {
          startWorkflowLoading();
        }
        const apiData = await workflowAPIService.loadWorkflow(flowId);
        if (apiData.hasOwnProperty("is_locked")) {
          setIsLocked(apiData.is_locked);
        }
        const { nodes: transformedNodes, edges: transformedEdges } = WorkflowDataConverter.transformToReactFlowFormat(apiData);
        const nodesWithCallbacks = transformedNodes.map((node) => {
          const nodeCallbacks = getNodeCallbacks(node.id, node.type);
          if (node.type === "combine_text") {
            return {
              ...node,
              data: {
                ...node.data,
                textToCombine: node.data.textToCombine || "",
                editorHtmlContent: node.data.editorHtmlContent || "",
                activeTab: node.data.activeTab || "editor",
                inputHandles: node.data.inputHandles || [{ id: "text" }],
                ...nodeCallbacks
              }
            };
          }
          return {
            ...node,
            data: {
              ...node.data,
              ...nodeCallbacks
            }
          };
        });
        setFlowNodes(nodesWithCallbacks);
        setFlowEdges(transformedEdges);
        setTimeout(() => {
          debugBrowserExtensionOutput(transformedNodes, transformedEdges);
          setFlowMetadata((prev) => ({
            ...prev,
            id: apiData.flow_id,
            title: apiData.flow_name || prev.flow_name,
            version: apiData.version || prev.version
          }));
          if (typeof window !== "undefined") {
            window.currentFlowId = apiData.flow_id;
          }
          console.log("載入工作流後立即更新節點函數...");
          setTimeout(() => {
            console.log("載入工作流後再次確認節點函數...");
            updateNodeFunctions();
            if (reactFlowControlsRef.current && reactFlowControlsRef.current.fitViewToNodes) {
              console.log("載入工作流後，執行一次畫布縮放以顯示所有節點...");
              reactFlowControlsRef.current.fitViewToNodes(0.1, 1.85, 800);
            }
            if (finishWorkflowLoading) {
              finishWorkflowLoading();
            }
          }, 500);
        }, 100);
        window.notify({
          message: "工作流載入成功",
          type: "success",
          duration: 2e3
        });
        return true;
      } catch (error) {
        console.error("載入工作流失敗:", error);
        if (finishWorkflowLoading) {
          finishWorkflowLoading();
        }
        window.notify({
          message: "載入工作流失敗",
          type: "error",
          duration: 2e3
        });
        return false;
      }
    }
  };
  useImperativeHandle(ref, () => ({
    // 導出流程數據的方法
    exportFlowData: () => {
      return {
        id: flowMetadata.id || `flow_${Date.now()}`,
        title: flowMetadata.title || "未命名流程",
        version: flowMetadata.version || 1,
        nodes,
        edges,
        metadata: {
          lastModified: (/* @__PURE__ */ new Date()).toISOString(),
          savedAt: (/* @__PURE__ */ new Date()).toISOString(),
          nodeCount: nodes.length,
          edgeCount: edges.length
        }
      };
    },
    // 設置流程標題的方法
    setFlowTitle: (title) => {
      if (title && typeof title === "string") {
        setFlowMetadata((prev) => ({ ...prev, title }));
        return true;
      }
      return false;
    },
    setFlowId: (flowId) => {
      if (flowId && typeof flowId === "string") {
        setFlowMetadata((prev) => ({ ...prev, flowId }));
        return true;
      }
      return false;
    },
    loadWorkflow: loadWorkflowImpl,
    // saveWorkflow 方法
    saveWorkflow: saveToServer,
    // 暴露 fitViewToNodes 方法給父組件
    fitViewToNodes: () => {
      if (reactFlowControlsRef.current && reactFlowControlsRef.current.fitViewToNodes) {
        reactFlowControlsRef.current.fitViewToNodes();
      }
    }
    // 新增 setToken 方法
    // setToken: (token) => {
    //   if (token && typeof token === 'string') {
    //     // 如果 TokenService 已導入，則直接使用
    //     if (typeof tokenService !== 'undefined') {
    //       tokenService.setToken(token);
    //       return true;
    //     }
    //     // 或者存儲到 localStorage
    //     try {
    //       localStorage.setItem('api_token', token);
    //       console.log('Token 已設置到 FlowEditor');
    //       return true;
    //     } catch (error) {
    //       console.error('保存 token 失敗:', error);
    //       return false;
    //     }
    //   }
    //   return false;
    // }
  }));
  useEffect(() => {
    if (typeof window !== "undefined") {
      window.currentFlowId = flowMetadata.id;
    }
    return () => {
      if (typeof window !== "undefined") {
        delete window.currentFlowId;
      }
    };
  }, [flowMetadata.id]);
  useEffect(() => {
    if (!isInitialized.current) {
      if (updateNodeFunctions) {
        updateNodeFunctions();
      }
      isInitialized.current = true;
    }
  }, [updateNodeFunctions]);
  const handleTitleChange = useCallback(
    (title) => {
      if (isLocked) return;
      setFlowMetadata((prev) => ({ ...prev, title }));
      if (onTitleChange && typeof onTitleChange === "function") {
        onTitleChange(title);
      }
    },
    [onTitleChange, isLocked]
  );
  useCallback(
    (nodeType) => {
      if (!reactFlowInstance) {
        return { x: 400, y: 300 };
      }
      try {
        let centerPosition;
        const reactFlowBounds = reactFlowWrapper.current?.getBoundingClientRect();
        if (reactFlowBounds) {
          const centerX = reactFlowBounds.left + reactFlowBounds.width / 2;
          const centerY = reactFlowBounds.top + reactFlowBounds.height / 2;
          centerPosition = reactFlowInstance.screenToFlowPosition({
            x: centerX,
            y: centerY
          });
        } else {
          const viewport = reactFlowInstance.getViewport();
          const containerWidth = reactFlowWrapper.current?.clientWidth || 800;
          const containerHeight = reactFlowWrapper.current?.clientHeight || 600;
          centerPosition = {
            x: (-viewport.x + containerWidth / 2) / viewport.zoom,
            y: (-viewport.y + containerHeight / 2) / viewport.zoom
          };
        }
        const nodeDimensions = calculateNodeDimensions({
          type: nodeType,
          data: {}
          // 使用預設數據來計算基本尺寸
        });
        const adjustedPosition = {
          x: centerPosition.x - nodeDimensions.width / 2,
          y: centerPosition.y - nodeDimensions.height / 2
        };
        return adjustedPosition;
      } catch (error) {
        console.error("計算視窗中心位置失敗:", error);
        return { x: 400, y: 300 };
      }
    },
    [reactFlowInstance]
  );
  useCallback((sidebarNodeType) => {
    const typeMapping = {
      input: "customInput",
      ai: "aiCustomInput",
      "browser extension input": "browserExtensionInput",
      "browser extension output": "browserExtensionOutput",
      "knowledge retrieval": "knowledgeRetrieval",
      end: "end",
      webhook: "webhook",
      http_request: "httpRequest",
      event: "event",
      timer: "timer",
      line_webhook_input: "line_webhook_input",
      line_send_message: "line_send_message",
      extract_data: "extract_data",
      aim_ml: "aim_ml",
      schedule_trigger: "schedule_trigger",
      webhook_input: "webhook_input",
      webhook_output: "webhook_output",
      combine_text: "combine_text",
      router_switch: "router_switch"
    };
    return typeMapping[sidebarNodeType] || "default";
  }, []);
  const handleNodeTypeSelection = useCallback(
    (nodeType, position = null) => {
      if (isLocked) return;
      let nodePosition = position;
      if (!position && reactFlowInstance) {
        try {
          const reactFlowBounds = reactFlowWrapper.current?.getBoundingClientRect();
          if (reactFlowBounds) {
            const centerX = reactFlowBounds.left + reactFlowBounds.width / 2;
            const centerY = reactFlowBounds.top + reactFlowBounds.height / 2;
            const centerPosition = reactFlowInstance.screenToFlowPosition({
              x: centerX,
              y: centerY
            });
            const reactFlowNodeType = WorkflowMappingService.getOperatorFromType(nodeType);
            const nodeDimensions = calculateNodeDimensions({
              type: reactFlowNodeType,
              data: {}
            });
            nodePosition = {
              x: centerPosition.x - nodeDimensions.width / 2,
              y: centerPosition.y - nodeDimensions.height / 2
            };
          }
        } catch (error) {
          console.error("計算置中位置失敗:", error);
          nodePosition = { x: 400, y: 300 };
        }
      }
      switch (nodeType) {
        case "input":
          handleAddInputNode(nodePosition);
          break;
        case "ai":
          handleAddAINode(nodePosition);
          break;
        case "if/else":
          handleAddIfElseNode(nodePosition);
          break;
        case "browser extension input":
          handleAddBrowserExtensionInput(nodePosition);
          break;
        case "browser extension output":
          handleAddBrowserExtensionOutput(nodePosition);
          break;
        case "knowledge retrieval":
          handleAddKnowledgeRetrievalNode(nodePosition);
          break;
        case "end":
          handleAddEndNode(nodePosition);
          break;
        case "webhook":
          handleAddWebhookNode(nodePosition);
          break;
        case "http_request":
          handleAddHttpRequestNode(nodePosition);
          break;
        case "event":
          handleAddEventNode(nodePosition);
          break;
        case "timer":
          handleAddTimerNode(nodePosition);
          break;
        case "line_webhook_input":
          handleAddLineNode(nodePosition);
          break;
        case "line_send_message":
          handleAddLineMessageNode(nodePosition);
          break;
        case "extract_data":
          handleAddExtractDataNode(nodePosition);
          break;
        case "aim_ml":
          handleAddQOCAAimNode(nodePosition);
          break;
        case "schedule_trigger":
          handleAddScheduleTriggerNode(nodePosition);
          break;
        case "webhook_input":
          handleAddWebhookInputNode(nodePosition);
          break;
        case "webhook_output":
          handleAddWebhookOutputNode(nodePosition);
          break;
        case "combine_text":
          handleAddCombineTextNode(nodePosition);
          break;
        case "router_switch":
          handleAddRouterSwitchNode(nodePosition);
          break;
        default:
          handleAddNode(nodePosition);
      }
    },
    [
      handleAddInputNode,
      handleAddAINode,
      handleAddIfElseNode,
      handleAddBrowserExtensionInput,
      handleAddBrowserExtensionOutput,
      handleAddKnowledgeRetrievalNode,
      handleAddEndNode,
      handleAddWebhookNode,
      handleAddHttpRequestNode,
      handleAddEventNode,
      handleAddTimerNode,
      handleAddLineNode,
      handleAddLineMessageNode,
      handleAddExtractDataNode,
      handleAddQOCAAimNode,
      handleAddNode,
      handleAddScheduleTriggerNode,
      handleAddWebhookInputNode,
      handleAddWebhookOutputNode,
      handleAddCombineTextNode,
      handleAddRouterSwitchNode,
      reactFlowInstance,
      isLocked
    ]
  );
  const onDragOver = useCallback(
    (event) => {
      if (isLocked) return;
      event.preventDefault();
      event.dataTransfer.dropEffect = "move";
      if (reactFlowWrapper.current) {
        reactFlowWrapper.current.classList.add("drag-over");
      }
    },
    [isLocked]
  );
  const onDrop = useCallback(
    (event) => {
      if (isLocked) return;
      event.preventDefault();
      if (!reactFlowInstance) return;
      const type = event.dataTransfer.getData("application/reactflow");
      if (typeof type === "undefined" || !type) {
        return;
      }
      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const position = reactFlowInstance.project({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top
      });
      handleNodeTypeSelection(type, position);
      if (reactFlowWrapper.current) {
        reactFlowWrapper.current.classList.remove("drag-over");
      }
    },
    [reactFlowInstance, handleNodeTypeSelection, isLocked]
  );
  const onDragStart = useCallback(
    (event, nodeType) => {
      if (isLocked) return;
      event.dataTransfer.setData("application/reactflow", nodeType);
      event.dataTransfer.effectAllowed = "move";
    },
    [isLocked]
  );
  const saveToLocalFile = useCallback(async () => {
    try {
      const flowData = {
        id: flowMetadata.id || `flow_${Date.now()}`,
        title: flowMetadata.title || "未命名流程",
        version: flowMetadata.version || 1,
        nodes,
        edges,
        metadata: {
          lastModified: (/* @__PURE__ */ new Date()).toISOString(),
          savedAt: (/* @__PURE__ */ new Date()).toISOString(),
          nodeCount: nodes.length,
          edgeCount: edges.length
        }
      };
      const date = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const safeTitle = (flowMetadata.title || "未命名_流程").replace(
        /\s+/g,
        "_"
      );
      const filename = `${safeTitle}_${date}.json`;
      const result = await FileIOService.saveToFile(flowData, filename);
      if (result.success) {
        console.log(`檔案已儲存為：${result.filename}`);
        window.notify({
          message: `已儲存到 ${result.filename}`,
          type: "success",
          duration: 2e3
        });
        setFlowMetadata({
          ...flowMetadata,
          title: flowMetadata.title || "未命名流程",
          lastSaved: (/* @__PURE__ */ new Date()).toISOString(),
          version: (flowMetadata.version || 0) + 1
        });
      }
      return result;
    } catch (error) {
      console.error("儲存檔案時發生錯誤：", error);
      window.notify({
        message: "無法儲存檔案，請稍後再試",
        type: "error",
        duration: 3e3
      });
      throw error;
    }
  }, [nodes, edges, flowMetadata]);
  useCallback(async () => {
    if (!isInIframe) {
      return saveToLocalFile();
    }
    try {
      const flowData = {
        id: flowMetadata.id || `flow_${Date.now()}`,
        title: flowMetadata.title || "未命名流程",
        version: flowMetadata.version || 1,
        nodes,
        edges,
        metadata: {
          lastModified: (/* @__PURE__ */ new Date()).toISOString(),
          savedAt: (/* @__PURE__ */ new Date()).toISOString(),
          nodeCount: nodes.length,
          edgeCount: edges.length
        }
      };
      const date = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const safeTitle = (flowMetadata.title || "未命名_流程").replace(
        /\s+/g,
        "_"
      );
      const filename = `${safeTitle}_${date}.json`;
      const result = iframeBridge.requestDownload(flowData, filename);
      if (result) {
        window.notify({
          message: `已發送下載請求`,
          type: "success",
          duration: 2e3
        });
      } else {
        window.notify({
          message: "發送下載請求失敗",
          type: "error",
          duration: 3e3
        });
      }
      return { success: result };
    } catch (error) {
      console.error("準備下載數據時發生錯誤：", error);
      window.notify({
        message: "無法發送下載請求，請稍後再試",
        type: "error",
        duration: 3e3
      });
      throw error;
    }
  }, [nodes, edges, flowMetadata, isInIframe, saveToLocalFile]);
  const saveToServer = useCallback(async () => {
    if (isLocked) return;
    setIsSaving(true);
    try {
      debugConnections(edges, "保存前");
      nodes.forEach((node) => {
        if (node.type === "combine_text") {
          console.log(`保存前檢查 Combine Text 節點 ${node.id}:`, {
            textToCombine: node.data.textToCombine,
            editorHtmlContent: node.data.editorHtmlContent,
            activeTab: node.data.activeTab,
            inputHandles: node.data.inputHandles
          });
        }
        if (node.type === "browserExtensionOutput") {
          console.log(`保存前檢查節點 ${node.id}:`, {
            inputHandles: node.data.inputHandles || [],
            node_input: node.data.node_input || {}
          });
          if (node.data.inputHandles && node.data.node_input) {
            const handleMismatch = node.data.inputHandles.some(
              (handle) => !node.data.node_input[handle.id]
            );
            if (handleMismatch) {
              console.warn(
                `節點 ${node.id} 的 inputHandles 和 node_input 不同步`
              );
            }
          }
        }
      });
      const flowData = {
        id: flowMetadata.id || `flow_${Date.now()}`,
        title: flowMetadata.title || "未命名流程",
        version: flowMetadata.version || 1,
        nodes,
        edges,
        metadata: {
          lastModified: (/* @__PURE__ */ new Date()).toISOString(),
          savedAt: (/* @__PURE__ */ new Date()).toISOString(),
          nodeCount: nodes.length,
          edgeCount: edges.length
        }
      };
      const apiData = WorkflowDataConverter.convertReactFlowToAPI(flowData);
      debugAINodeConnections(nodes, edges);
      debugAINodeAPIData(apiData);
      if (apiData && apiData.flow_pipeline) {
        debugNodeInputsBeforeSave(apiData.flow_pipeline);
      }
      console.log("FlowEditor: 將流程數據轉換為 API 格式:", apiData);
      let response;
      let flowIdToUse = flowMetadata.id || null;
      if (flowMetadata.id) {
        response = await workflowAPIService.updateWorkflow(apiData);
        console.log("FlowEditor: 更新流程成功", response);
        window.notify({
          message: "流程更新成功",
          type: "success",
          duration: 2e3
        });
        setFlowMetadata((prev) => ({
          ...prev,
          lastSaved: (/* @__PURE__ */ new Date()).toISOString()
        }));
      } else {
        response = await workflowAPIService.createWorkflow(apiData);
        console.log("FlowEditor: 創建流程成功", response);
        flowIdToUse = response?.flow_id;
        if (flowIdToUse) {
          setFlowMetadata((prev) => ({
            ...prev,
            id: flowIdToUse,
            lastSaved: (/* @__PURE__ */ new Date()).toISOString()
          }));
        }
        const isInIframe2 = window.self !== window.top;
        if (isInIframe2) {
          console.log("在 iframe 中檢測到新創建的流程，發送事件到父窗口");
          try {
            iframeBridge.sendToParent({
              type: "FLOW_SAVED",
              flowId: flowIdToUse,
              success: true,
              title: flowMetadata.title || "未命名流程",
              isNewFlow: true,
              currentPath: window.location.pathname,
              isNewPath: window.location.pathname.includes("/new"),
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            });
          } catch (error) {
            console.error("向父頁面發送事件失敗：", error);
          }
        }
        window.notify({
          message: "流程創建成功",
          type: "success",
          duration: 2e3
        });
      }
      if (flowIdToUse) {
        setTimeout(async () => {
          console.log("使用 flow_id 重新加載工作流:", flowIdToUse);
          await handleLoadWorkflow(flowIdToUse);
          debugConnections(edges, "保存後重新加載");
          debugAINodeConnections(nodes, edges);
        }, 1e3);
      } else {
        console.warn("沒有可用的 flow_id，無法重新加載工作流");
      }
      return response;
    } catch (error) {
      console.error("FlowEditor: 儲存流程時發生錯誤：", error);
      window.notify({
        message: "無法儲存流程，請稍後再試",
        type: "error",
        duration: 3e3
      });
      throw error;
    } finally {
      setIsSaving(false);
    }
  }, [isLocked, nodes, edges, flowMetadata, handleLoadWorkflow]);
  const handleDialogSave = useCallback(
    async (flowName) => {
      if (isLocked) return;
      console.log(`對話框觸發的保存，流程名稱: ${flowName}`);
      console.log("當前 flowMetadata:", flowMetadata);
      setIsSaving(true);
      try {
        const flowDataWithNewTitle = {
          id: flowMetadata.id || `flow_${Date.now()}`,
          title: flowName,
          // 直接使用對話框傳入的標題
          version: flowMetadata.version || 1,
          nodes,
          edges,
          metadata: {
            lastModified: (/* @__PURE__ */ new Date()).toISOString(),
            savedAt: (/* @__PURE__ */ new Date()).toISOString(),
            nodeCount: nodes.length,
            edgeCount: edges.length
          }
        };
        console.log("創建的 flowData:", flowDataWithNewTitle);
        const apiData = WorkflowDataConverter.convertReactFlowToAPI(flowDataWithNewTitle);
        console.log("轉換後的 API 數據:", apiData);
        console.log("API 中的 flow_name:", apiData.flow_name);
        let response;
        let flowIdToUse = flowMetadata.id || null;
        if (flowMetadata.id) {
          console.log("更新現有流程，flow_id:", flowMetadata.id);
          response = await workflowAPIService.updateWorkflow(apiData);
          console.log("更新流程成功:", response);
          window.notify({
            message: "流程更新成功",
            type: "success",
            duration: 2e3
          });
        } else {
          console.log("創建新流程");
          response = await workflowAPIService.createWorkflow(apiData);
          console.log("創建流程成功:", response);
          flowIdToUse = response?.flow_id;
          console.log("獲得新的 flow_id:", flowIdToUse);
          const isInIframe2 = window.self !== window.top;
          if (isInIframe2) {
            console.log("在 iframe 中，發送事件到父頁面");
            try {
              iframeBridge.sendToParent({
                type: "FLOW_SAVED",
                flowId: flowIdToUse,
                success: true,
                title: flowName,
                // 使用正確的標題
                isNewFlow: true,
                currentPath: window.location.pathname,
                isNewPath: window.location.pathname.includes("/new"),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            } catch (error) {
              console.error("向父頁面發送事件失敗：", error);
            }
          }
          window.notify({
            message: "流程創建成功",
            type: "success",
            duration: 2e3
          });
        }
        setFlowMetadata((prev) => {
          const newMetadata = {
            ...prev,
            id: flowIdToUse || prev.id,
            title: flowName,
            // 確保標題正確更新
            lastSaved: (/* @__PURE__ */ new Date()).toISOString()
          };
          console.log("更新 flowMetadata:", newMetadata);
          return newMetadata;
        });
        setShowSaveDialog(false);
        if (flowIdToUse) {
          setTimeout(async () => {
            console.log("重新加載工作流:", flowIdToUse);
            await handleLoadWorkflow(flowIdToUse);
            if (saveDialogCallback) {
              const finalFlowId = flowIdToUse || flowMetadata.id;
              console.log("執行回調函數，flow_id:", finalFlowId);
              saveDialogCallback(finalFlowId);
              setSaveDialogCallback(null);
            }
          }, 1e3);
        }
        return {
          success: true,
          flow_id: flowIdToUse || flowMetadata.id,
          ...response
        };
      } catch (error) {
        console.error("對話框觸發的保存失敗:", error);
        window.notify({
          message: "無法儲存流程，請稍後再試",
          type: "error",
          duration: 3e3
        });
        throw error;
      } finally {
        setIsSaving(false);
      }
    },
    [
      nodes,
      edges,
      flowMetadata,
      saveDialogCallback,
      handleLoadWorkflow,
      isLocked
    ]
  );
  const closeSaveDialog = useCallback(() => {
    setShowSaveDialog(false);
    setSaveDialogCallback(null);
  }, []);
  const showSaveFlowDialog = useCallback(
    (callback) => {
      if (isLocked) return;
      setSaveDialogCallback(() => callback);
      setShowSaveDialog(true);
    },
    [isLocked]
  );
  useCallback(async () => {
    try {
      const result = await FileIOService.readFromFile();
      if (result.success && result.data) {
        console.log("檔案已載入：", result.filename);
        window.notify({
          message: `已載入 ${result.filename}`,
          type: "success",
          duration: 2e3
        });
        if (!result.data.nodes || !result.data.edges) {
          throw new Error("無效的流程檔案格式");
        }
        setFlowNodes(result.data.nodes);
        setFlowEdges(result.data.edges);
        setFlowMetadata({
          id: result.data.id || `flow_${Date.now()}`,
          title: result.data.title || "匯入的流程",
          lastSaved: result.data.metadata?.savedAt || (/* @__PURE__ */ new Date()).toISOString(),
          version: result.data.version || 1
        });
        updateNodeFunctions();
        if (isInIframe && onTitleChange) {
          onTitleChange(result.data.title || "匯入的流程");
        }
        setTimeout(() => {
          if (reactFlowControlsRef.current && reactFlowControlsRef.current.fitViewToNodes) {
            reactFlowControlsRef.current.fitViewToNodes();
          }
        }, 300);
      }
      return result;
    } catch (error) {
      console.error("載入檔案時發生錯誤：", error);
      window.notify({
        message: "無法載入檔案",
        type: "error",
        duration: 3e3
      });
      throw error;
    }
  }, [
    setFlowNodes,
    setFlowEdges,
    updateNodeFunctions,
    isInIframe,
    onTitleChange
  ]);
  const handleSelectionChange = useCallback(
    ({ nodes: selectedNodes }) => {
      if (selectedNodes && selectedNodes.length > 0) {
        handleNodeSelection(selectedNodes[0].id);
      }
    },
    [handleNodeSelection]
  );
  useEffect(() => {
    if (initialTitle) {
      setFlowMetadata((prev) => {
        if (prev.title !== initialTitle) {
          return { ...prev, title: initialTitle };
        }
        return prev;
      });
    }
  }, [initialTitle]);
  useEffect(() => {
    const handleSaveRequest = (event) => {
      if (isLocked) return;
      console.log("收到來自 Line 節點的保存請求", event.detail);
      const { callback } = event.detail;
      if (flowMetadata.id) {
        callback(flowMetadata.id);
      } else {
        showSaveFlowDialog(callback);
      }
    };
    window.addEventListener("requestSaveFlow", handleSaveRequest);
    return () => {
      window.removeEventListener("requestSaveFlow", handleSaveRequest);
    };
  }, [flowMetadata.id, showSaveFlowDialog, isLocked]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative w-full h-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      APAAssistant,
      {
        title: flowMetadata.title,
        onTitleChange: handleTitleChange,
        isLocked
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Notification, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ReactFlowProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "w-full h-full",
        ref: reactFlowWrapper,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ReactFlowWithControls,
          {
            ref: reactFlowControlsRef,
            nodes,
            edges,
            onNodesChange,
            onEdgesChange,
            onConnect,
            onNodesDelete,
            nodeTypes,
            edgeTypes,
            defaultViewport,
            onSelectionChange: handleSelectionChange,
            onInit: setReactFlowInstance,
            onDrop,
            onDragOver,
            sidebarVisible,
            isLocked
          }
        )
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: `absolute top-0 left-0 h-full transition-transform duration-300 transform ${sidebarVisible ? "translate-x-0" : "-translate-x-full"}`,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeSidebar,
            {
              handleButtonClick: handleNodeTypeSelection,
              onDragStart,
              nodes,
              isLocked
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "absolute top-1/2 -right-6 bg-white border border-gray-300 rounded-r-md p-1 shadow-md",
              onClick: toggleSidebar,
              children: sidebarVisible ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "16",
                  height: "16",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  stroke: "currentColor",
                  strokeWidth: "2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "15 18 9 12 15 6" })
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                "svg",
                {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "16",
                  height: "16",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  stroke: "currentColor",
                  strokeWidth: "2",
                  strokeLinecap: "round",
                  strokeLinejoin: "round",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "9 18 15 12 9 6" })
                }
              )
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "absolute top-4 right-4 z-10 flex flex-col items-end", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex space-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadWorkflowButton, { onLoad: handleLoadWorkflow }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-10 w-px bg-gray-300 self-center" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          AutoLayoutButton,
          {
            onLayout: handleAutoLayout,
            disabled: isSaving || nodes.length === 0 || isLocked,
            isLocked
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-10 w-px bg-gray-300 self-center" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SaveButton,
          {
            onSave: saveToServer,
            title: flowMetadata.title,
            flowId: flowMetadata.id,
            disabled: isSaving,
            isLocked
          }
        ) })
      ] }),
      flowMetadata.lastSaved && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-2 bg-white px-3 py-1 rounded-md shadow text-xs text-gray-500 z-10", children: [
        "Last saved: ",
        new Date(flowMetadata.lastSaved).toLocaleTimeString(),
        " ",
        "| Version: ",
        flowMetadata.version,
        isLocked && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "ml-2 text-orange-600 font-medium", children: "🔒 已鎖定" })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SaveFlowDialog,
      {
        isOpen: showSaveDialog,
        onClose: closeSaveDialog,
        onSave: handleDialogSave,
        title: "請先儲存您的 Flow"
      }
    )
  ] });
});
FlowEditor.displayName = "FlowEditor";
const debugConnections = (edges, message) => {
  console.group(`调试连接 - ${message}`);
  const edgesByTarget = {};
  edges.forEach((edge) => {
    if (!edgesByTarget[edge.target]) {
      edgesByTarget[edge.target] = [];
    }
    edgesByTarget[edge.target].push(edge);
  });
  Object.entries(edgesByTarget).forEach(([targetId, targetEdges]) => {
    console.log(`节点 ${targetId} 的输入连接 (${targetEdges.length}):`);
    const byHandle = {};
    targetEdges.forEach((edge) => {
      const handle = edge.targetHandle || "input";
      if (!byHandle[handle]) {
        byHandle[handle] = [];
      }
      byHandle[handle].push(edge);
    });
    Object.entries(byHandle).forEach(([handle, handleEdges]) => {
      console.log(`  句柄 ${handle}: ${handleEdges.length} 个连接`);
      handleEdges.forEach((edge) => {
        console.log(
          `    来源: ${edge.source}, 句柄: ${edge.sourceHandle || "output"}`
        );
      });
    });
  });
  console.groupEnd();
};
const debugBrowserExtensionOutput = (nodes, edges) => {
  console.group("瀏覽器擴展輸出節點調試");
  const outputNodes = nodes.filter(
    (node) => node.type === "browserExtensionOutput"
  );
  console.log(`找到 ${outputNodes.length} 個瀏覽器擴展輸出節點`);
  outputNodes.forEach((node) => {
    console.group(`節點: ${node.id}`);
    const nodeEdges = edges.filter((edge) => edge.target === node.id);
    console.log(`找到 ${nodeEdges.length} 個連接到該節點的邊緣`);
    nodeEdges.forEach((edge) => {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      console.log(`連接 ${edge.id}:`, {
        source: edge.source,
        sourceType: sourceNode?.type,
        sourceHandle: edge.sourceHandle,
        targetHandle: edge.targetHandle,
        returnName: edge.label || "(未設置)",
        sourceNodeData: sourceNode?.data ? Object.keys(sourceNode.data) : "(無數據)"
      });
      if (sourceNode) {
        if (sourceNode.type === "customInput" && sourceNode.data?.fields) {
          const outputIndex = edge.sourceHandle ? parseInt(edge.sourceHandle.split("-")[1] || 0) : 0;
          const field = sourceNode.data.fields[outputIndex];
          console.log(`源節點 ${sourceNode.id} 的欄位 ${outputIndex}:`, {
            inputName: field?.inputName,
            defaultValue: field?.defaultValue
          });
        } else if (sourceNode.type === "browserExtensionInput" && sourceNode.data?.items) {
          const outputIndex = edge.sourceHandle ? parseInt(edge.sourceHandle.split("-")[1] || 0) : 0;
          const item = sourceNode.data.items[outputIndex];
          console.log(`源節點 ${sourceNode.id} 的項目 ${outputIndex}:`, {
            name: item?.name,
            icon: item?.icon
          });
        }
      }
    });
    console.groupEnd();
  });
  console.groupEnd();
};
const debugAINodeConnections = (nodes, edges) => {
  console.group("AI節點連線調試");
  const aiNodes = nodes.filter(
    (node) => node.type === "aiCustomInput" || node.type === "ai"
  );
  console.log(`找到 ${aiNodes.length} 個 AI 節點`);
  aiNodes.forEach((node) => {
    console.group(`節點: ${node.id}`);
    const nodeEdges = edges.filter((edge) => edge.target === node.id);
    console.log(`找到 ${nodeEdges.length} 個連接到該節點的邊緣`);
    const promptEdges = nodeEdges.filter(
      (edge) => edge.targetHandle === "prompt-input"
    );
    const contextEdges = nodeEdges.filter(
      (edge) => edge.targetHandle.includes("context-input") || edge.targetHandle.startsWith("context_")
    );
    console.log(`Prompt 連線: ${promptEdges.length}`);
    console.log(`Context 連線: ${contextEdges.length}`);
    contextEdges.forEach((edge, index) => {
      const sourceNode = nodes.find((n) => n.id === edge.source);
      console.log(`Context 連線 ${index + 1}:`, {
        source: edge.source,
        sourceType: sourceNode?.type,
        sourceHandle: edge.sourceHandle,
        label: edge.label,
        sourceData: sourceNode?.data?.length || Object.keys(sourceNode?.data || {}).length
      });
    });
    console.groupEnd();
  });
  console.groupEnd();
};
const debugAINodeAPIData = (apiData) => {
  console.group("AI節點 API 數據調試");
  if (apiData.flow_pipeline) {
    const aiNodes = apiData.flow_pipeline.filter(
      (node) => node.operator === "ask_ai"
    );
    console.log(`找到 ${aiNodes.length} 個 AI 節點`);
    aiNodes.forEach((node) => {
      console.group(`節點 ${node.id}`);
      if (node.node_input) {
        const contextInputs = Object.keys(node.node_input).filter(
          (key) => key.includes("context-input") || key.startsWith("context_")
        );
        console.log(`Context 輸入數量: ${contextInputs.length}`);
        contextInputs.forEach((key) => {
          const input = node.node_input[key];
          console.log(`輸入 ${key}:`, {
            node_id: input.node_id,
            output_name: input.output_name,
            return_name: input.return_name
          });
        });
        if (node.node_input["prompt-input"]) {
          const promptInput = node.node_input["prompt-input"];
          console.log("Prompt 輸入:", {
            node_id: promptInput.node_id,
            output_name: promptInput.output_name,
            return_name: promptInput.return_name
          });
        }
      }
      console.groupEnd();
    });
  }
  console.groupEnd();
};
if (typeof window !== "undefined") {
  window.debugAINodeConnections = debugAINodeConnections;
  window.debugAINodeAPIData = debugAINodeAPIData;
}
const debugNodeInputsBeforeSave = (flowPipeline) => {
  console.group("保存前節點輸入調試");
  flowPipeline.forEach((node) => {
    if (node.operator === "browser_extension_output" && node.node_input) {
      console.group(`節點 ${node.id} (${node.operator}) 的輸入:`);
      Object.entries(node.node_input).forEach(([key, input]) => {
        const isEmpty = input.is_empty || !input.node_id;
        console.log(`輸入 ${key}:`, {
          node_id: input.node_id || "(空)",
          output_name: input.output_name,
          type: input.type,
          return_name: input.return_name || "(未設置)",
          isEmpty: isEmpty ? "是" : "否"
        });
      });
      console.groupEnd();
    }
  });
  console.groupEnd();
};

export { FlowEditor as default, iframeBridge as i, jsxRuntimeExports as j, tokenService as t };
